We thank the reviewers for their work.
We want to make three main comments and after that, we provide a more detailed list of responses to individual comments and questions below.

* Several reviewers comment on the practical applicability of our calling convention, its performance, its relevance with future evolutions of processors etc.
  While these are relevant considerations, we emphasize that the calling convention is NOT the only contribution of this work.
  In particular, we are the first to study capability machines using approaches and techniques that are at the heart of the POPL community: a condensed formal model of the programming language involved and advanced, rigorous machinery from PL research (Kripke step-indexed logical relations).
  We believe our work demonstrates the value of these techniques in this setting and will prove valuable for studying similar techniques in the future.

* Some other reviewers comment on the motivation of our calling convention, given that CHERI already uses a different calling convention using per-component stacks and a trusted stack manager.
  What should be made clear is that this alternative approach is not well described in the literature (how does it work precisely? what features are supported? etc), not well motivated (what security property is it intended to enforce?), and appears technically limited (how can it support higher-order interfaces together with many fine-grained components?)?
  Our paper does provide all of this for our calling convention: a precisely described calling convention for enforcing well-bracketedness of fine-grained components with higher-order interfaces.

* Reviewer D comments on the fact that we just offer a logical relation and not a verification technique (like a program logic).
  While such a verification technique might be useful for some purposes, our logical relation does constitute a mathematically valid reasoning technique that suffices to prove valuable properties of concrete programs.
  Offering a logical relation that can be used to reason about programs using either a fundamental theorem or direct arguments (but no program logic or similar verification technique) is standard practice in the literature (e.g. Ahmed et al., 2009, Birkedal et al., 2011, Devriese et al., 2016, Dreyer et al., 2012, Hur et al., 2011, Thamsborg and Birkedal, 2011 etc.).

More detailed responses:
Reviewer A:
Q: "What are the performance implications of using local capabilities, as opposed to regular capabilities?"
A: As described previously, this paper presents techniques for reasoning about capability machines which is why we have implemented no artifact and done no performance evaluation. That said, the semantics of local capabilities come with little to no performance penalty. However, some applications that use local capabilities, including our proposed calling convention, will need an instruction to clear memory segments which is very costly.

Reviewer D:
Q: "Itâ€™ll be nice to give some motivating examples to show what unsafe/insecure programs one can write without proper use of the capabilities, and to explain why it is difficult to formulate/verify the correctness?"
A: We appreciate the suggestion and will consider whether we can come up with a sensible example include (imagine the case where all capabilities giver permission to everything. Now try to prove that one entity cannot access another entity's private data. This is going to be impossible because it simply is not true), however, the point of the paper and this line of work is to the study security of programs rather than the lack thereof. We have taken high-level program examples that have proven difficult to prove certain properties as our benchmark, and we have indeed succeeded in showing these examples as can be seen in Section 5 of the paper (specifically with the faitful translation of the awkward example).
