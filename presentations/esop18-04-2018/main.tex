\documentclass{beamer}
\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
  }

\usepackage{pgfpages}
\setbeameroption{show notes}
\setbeameroption{show notes on second screen=right}


\usepackage{listings}
\renewcommand{\ttdefault}{pcr}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\ttfamily\bfseries,
  morekeywords={let, ref, assert, in},
  columns=fullflexible,
  keepspaces=true,
  escapeinside={(*}{*)}
}

\input{../illustrations/preamble}
\input{loc_preamble}
\title{Reasoning About a Machine with Local Capabilities}
\subtitle{Provably Safe Stack and Return Pointer Management}
\author{Lau Skorstengaard\inst{1} \and Dominique Devriese\inst{2} \and Lars Birkedal\inst{1}}
\institute{\inst{1} Aarhus University \and %
  \inst{2} imec-DistriNet, KU Leuven}

\date{ESOP, April 17, 2018}

\tikzset{
    gray on/.style={alt=#1{gray}{}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
}


\begin{document}
\maketitle
        
\begin{frame}[fragile]
  \frametitle{What Does This Program Do?}
  % Motivation
  \centering

  \begin{tabular}{c}
    \begin{lstlisting}
let x = ref 0 in
  (*$\lambda$*)f.(x := 0;
      f();
      x := 1;
      f();
      assert(x == 1))
    \end{lstlisting}
  \end{tabular}
  
  \note{Informally, what does this program do?}
  \note{It allocates a reference to 0 and saves a closure to x. The closure takes a callback, assigns 0 to x, calls the callback, assigns 1 to x, calls the callback another time and finally asserts x to be 1.}
  \note{As a programmer that is how I would think. But what happens if I compile this closure to assembly and let some untrusted piece of code interact with it?}
  \note{My reasoning depends on the assumption that when I call f, then if f returns it returns to a certain point. The low-level machine needs to enforce this if I want to be able to do have this closure interact with arbitrary machine code.} 
\end{frame}



\begin{frame}
  \frametitle{Traditional Stack Pointers}
  \note{Let's first consider what happens with the stack during a call on a traditional low-level machine and what can go wrong.}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    % recurrent parts
    \begin{scope}
      \clip (-.1,-.1) rectangle (6.1,15.1);
      \fill[gray!20,draw=none,opacity=.8] (0,0) rectangle (6,15);
      \draw[draw=gray!80] (0,0) -- (0,15);
      \draw[draw=gray!80] (6,0) -- (6,15);
      \draw[fill=white] (0,-.5) rectangle (6,2.5) node[pos=.5] {\footnotesize lower stack frames...};
    \end{scope}
    \draw (-1.5,0) node {};
    \draw (-1.5,15) node {};
    % \draw[->] (-1,0) -- node[midway,sloped,above] {stack grows upward} (-1,15);

    % traditional:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize caller stack frame};
    \draw<.>[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\footnotesize callee stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);

    % traditional return:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call, attack:
    \draw<+->[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize caller stack frame};
    \draw<.->[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\footnotesize callee stack frame};
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.-> node[right=0cm of sp0] (sp0l) { stack pointer };

    % read other stack frames
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);
    \actadv[.]{(0,5.5)}{(6,8.5)}{callee stack frame}
    \draw<.> (sp0) edge[->,color=red,very thick,out=235,in=0] node[sloped, below] {read/write} (6,4);

    % break well-bracketedness
    \draw<+>[fill=red,opacity=.7] (-.5,2.5) rectangle (6.5,8.5);
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.>[red] (sp0) edge[->,out=235,in=0] (6,1.75);
    \draw<.> node[color=red,align=left,below=of sp0l] {return but\\
      skip caller frame};
  \end{tikzpicture}
  \note{We need something to enforce security properties on a low-level machine.}
\end{frame}

\begin{frame}
  \frametitle{Capability Machine}
  % short description of capability machines

  \begin{columns}
\begin{column}{0.5\textwidth}
  \begin{itemize}
  \item Low-level machine
    \note{Has instructions as you would expect, load, store, jmp, etc.}
  \item Capabilities replace pointers
    \begin{itemize}
    \item Pointer
    \item Range of authority
    \item Kind of authority
      \begin{itemize}
      \item read/write/execute
      \item enter
      \end{itemize}
      \note{Has instructions for manipulating capabilities.}
    \end{itemize}
    \item Authority checked dynamically
  \end{itemize}
\end{column}
\begin{column}{0.5\textwidth}
    \begin{center}
      % Insert capability figure
     \end{center}
\end{column}
\end{columns}
  \note{This particular setup gives a very fine-grained memory control.}
\end{frame}

\begin{frame}
  \frametitle{Stack and Return Capabilities: Attack 1}
  \note{In the following, part of memory is used for the stack and we use capabilities to govern them. Callee not able to read from the caller stack frame, so that is already an improvement.}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    % recurrent parts
    \stdstackstart

    % attacker...
    \begin{onlyenv}<+-+(2)>
      \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,6.5)}{(6,9.5)}{callee stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    \note{Evil callee stores stack pointer on the heap.}
    % stores stack pointer in heap
    \begin{onlyenv}<+->
      \begin{scope}
        \fill[gray!20] (14,6) rectangle (18,13);
        \draw (14,6) -- (14,13);
        \draw (18,6) -- (18,13);
      \end{scope}
      \draw (16,14) node {heap memory};
      \draw[fill=gray!50] (14,8) rectangle node[color=red] {\scriptsize copy of old sp} (18,8.5);
    \end{onlyenv}
    \draw<.> (14,8.25) edge[->,red,thick,bend left] (sp1);
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (11.5,6.5) -- (11.5,16) node[draw=black] (spold) [black,midway,xshift=0.8cm] {};
      \draw (14,8.25) edge[->,red,thick,bend left] (spold);
    \end{onlyenv}

    \note{Evil callee returns to the caller.}
    % attacker returns
    \begin{onlyenv}<+>
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[fill=white] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize current stack frame};
    \end{onlyenv}
    

    \note{caller uses a bit more of the stack and calls the evil callee again.}
    \note{the evil callee can now load the old stack capability from memory and access part of the callers private stack!}
    % attacker gets called again + uses old stack pointer.
    \begin{onlyenv}<+>
      \draw[fill=gray!50] (0,2.5) rectangle (6,10.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,10.5)}{(6,13.5)}{callee stack frame}
      \draw (14,8.25) edge[->,color=red,very thick,out=235,in=0] node[sloped, below] {read/write} (6,8);
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,10.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,2.5) -- (6,16) node (callerframe1) [draw=black,midway,xshift=0.8cm] {};
      % \draw node[fill=gray!50,right=0cm of callerframe1] (rp1l) {return pointer data};
    \end{onlyenv}
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Local Capabilities}
  % Short description of local capabilities
  \begin{itemize}
  \item Capabilities tagged with locality (local or global)   \note{We call non-local capabilities global}
  \item New \emph{write-local} permission.
  \item Local capabilities can only be stored by capabilities with \emph{write-local} permission
  \end{itemize}
  Calling convention highlights
  \begin{itemize}
  \item Stack capability is local with permission read, write-local, and execute.
  \item Clear stack before passing stack capability to untrusted code.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Local Stack Capabilities Prevent Attack 1}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    
    % attacker...
    \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
    \actadv{(0,6.5)}{(6,9.5)}{callee stack frame}
    \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
    \draw node[right=0cm of sp1] { stack pointer };

    % stores stack pointer in heap
    \begin{scope}
      \fill[gray!20] (14,6) rectangle (18,13);
      \draw (14,6) -- (14,13);
      \draw (18,6) -- (18,13);
    \end{scope}
    \draw (16,14) node {heap memory};
    \draw[fill=gray!50] (14,8) rectangle node[color=red] {\scriptsize copy of old sp} (18,8.5);
    \draw (14,8.25) edge[->,red,thick,bend left] (sp1);
    \draw[teal,very thick] (13.5,7.5) -- (18.5,9);
    \draw[teal,very thick] (18.5,7.5) -- (13.5,9);
    \draw node[teal,cloud,cloud puffs=10.8,cloud puff arc=110, aspect=3, draw, fill=white] () at (14,4) {Stack pointer is local!};  
\end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Stack and Return Capabilities: Attack 2}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    % recurrent parts
    \stdstackstart

    % first step: capabilities
    \begin{onlyenv}<+>
      \draw[fill=white] (0,2.5) rectangle (6,4) node[pos=.5] {\footnotesize current stack frame};
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,0) -- (6,16) node (oldframe1) [black,midway,xshift=0.5cm] {};
      % \draw node[fill=gray!50,right=0cm of oldframe1] (rp1l) {return pointer data};
    \end{onlyenv}

    % attacker stores copy of stack pointer high in the stack
    \draw<+->[fill=gray!50] (0,2.5) rectangle (6,4) node[pos=.5] {\footnotesize caller stack frame};
    \begin{onlyenv}<.-.(2)>
      \actadv{(0,4)}{(6,7)}{callee stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,4) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}
    \draw<+->[fill=white] (0,13) rectangle (6,13.5) node[pos=.5,color=red] {\footnotesize copy of sp};
    \draw<.> (6,13.25) edge[red,thick,->,in=45] (sp1);
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (13.5,4) -- (13.5,16) node[draw=black] (spold) [black,midway,xshift=0.8cm] {};
      \draw (6,13.25) edge[red,thick,->,in=45] (spold);
    \end{onlyenv}

    % attacker calls trusted code again
%    \draw<+->[fill=gray!50] (0,4) rectangle (6,7) node[pos=.5] {\footnotesize callee stack frame};
    \begin{onlyenv}<+->
      \inactadv{(0,4)}{(6,7)}{callee stack frame}
    \end{onlyenv}
    \begin{onlyenv}<.>
      \draw[fill=white] (0,7) rectangle (6,9) node[pos=.5] {\footnotesize callee (2) stack frame};
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,7) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    % attacker uses old stack pointer
    \draw<+->[fill=gray!50] (0,7) rectangle (6,9) node[pos=.5] {\footnotesize callee (2) stack frame};
    \begin{onlyenv}<.-.(1)>
      \actadv{(0,9)}{(6,12)}{callee (3) stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,9) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}
    \draw<+> (spold) edge[->,color=red,very thick,out=235,in=0] node[sloped, below] {read/write} (6,8);
  \end{tikzpicture}
  \note{The stack was the only place to store the local capability, so the adversary hid it there.}
\end{frame}

\begin{frame}
  \frametitle{Calling Convention (Continued)}
  \begin{itemize}
  \item $\dots$
  \item Clear stack and non-argument registers before invoking untrusted code.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Stack Clearing Prevents Attack 2}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    % attacker stores copy of stack pointer high in the stack
    \draw[fill=gray!50] (0,2.5) rectangle (6,4) node[pos=.5] {\footnotesize caller stack frame};
    \begin{onlyenv}<+>
      \actadv{(0,4)}{(6,7)}{callee stack frame}
    \end{onlyenv}
    \draw<.-.(2)>[fill=white] (0,13) rectangle (6,13.5) node[pos=.5,color=red] {\footnotesize copy of sp};
    \draw<.-.(2)> [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
    (13.5,4) -- (13.5,16) node[draw=black] (spold) [black,midway,xshift=0.8cm] {};
    \draw<.-.(2)> (6,13.25) edge[red,thick,->,in=45] (spold);

    % attacker calls trusted code again
    \begin{onlyenv}<+->
      \inactadv{(0,4)}{(6,7)}{callee stack frame}
    \end{onlyenv}
    \begin{onlyenv}<.-.(1)>
      \draw[fill=white] (0,7) rectangle (6,9) node[pos=.5] {\footnotesize callee (2) stack frame};
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,7) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    % trusted code clears the stack
    \begin{onlyenv}<+->
      \foreach \x in {9,9.5,...,14}
      {
        \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {\footnotesize 0};
      };
    \end{onlyenv}
    \draw<.>[very thick,color=teal] (10,13.5) -- (13,14.5)
    (13,13.5) -- (10,14.5);
    
    % attacker uses old stack pointer
    \draw<+->[fill=gray!50] (0,7) rectangle (6,9) node[pos=.5] {\footnotesize callee (2) stack frame};
    \begin{onlyenv}<.>
      \actadv{(0,9)}{(6,12)}{callee (3) stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,9) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    % attacker returns
    \draw<+>[fill=white] (0,9) rectangle (6,12) node[pos=.5] {?};
    \begin{onlyenv}<.>
      \draw[fill=white] (0,7) rectangle (6,9) node[pos=.5] {\footnotesize callee (2) stack frame};
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,7) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    % trusted code clears stack again
    \begin{onlyenv}<+->
      \foreach \x in {7,7.5,...,14}
      {
        \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {\footnotesize 0};
      };
    \end{onlyenv}
    % then, the trusted code can return
    \begin{onlyenv}<+>
      \actadv{(0,4)}{(6,7)}{callee stack frame}
    \end{onlyenv}
    
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{(Full) Calling Convention}
  % and stack management
  \note{We need to do a few more things, but this is the rest (just to illustrate that it is fairly simple).}
  \note{Every point is motivated by some attack.}
  \begin{itemize}
  \item Initially:
    \begin{itemize}
    \item Stack capabilitiy local capability with read, write-local, and execute authority.
    \item No global write-local capabilities on the machine.
    \end{itemize}
  \item Prior to returning to untrusted code:
    \begin{itemize}
    \item Clear the stack.
    \item Clear non-return registers.
    \end{itemize}
  \item Prior to calls to untrusted code:
    \begin{itemize}
    \item Push activation record to the stack and create enter-capability.
    \item Restrict the stack pointer to the unused part and clear that part.
    \item Clear non-argument registers.
    \end{itemize}
  \item Only invoke global call-backs.
  \item When invoked by untrusted code
    \begin{itemize}
    \item Make sure the stack pointer has read, write-local and execute authority.
    \end{itemize}
  \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{Formalizing the Guarantees of a Capability Machine}
  \note{How can we be sure calling convention works. Specifically, if a program interacts with intrusted code using the CC, can we formally show the correctness of the program if it relies on well-bracketedness or local-state encapsulation.}

  \note{Need formal statement of the guarantees provided by the capability machine including the specific guarantees for local capabilities.}
  \begin{itemize}
  \item How do we know the calling convention works?
  \item Unary step-indexed Kripke logical relation over recursive worlds
    \begin{itemize}
    \item Statement of guarantees provided by the capability machine
    \end{itemize}
  \end{itemize}
  \note{We state this formal statement in terms of a unary step-indexed Kripke logical relation over recursive worlds}

  \note{Calling convention main application, but it is very general - can be used to reason about other programs.}

  \note{In the following: give some intuition for different parts of LR}

  \note{correctness here could be assert not violated}

  \note{mention better than previous. Define the guarantees}
\end{frame}


\begin{frame}
  \frametitle{Worlds, Safe Values, and Step-Indexing}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{itemize}
    \item<1-> Capabilities represent bound on executing code
    \item<2-> World, $W$      
      \begin{itemize}
      \item Collection of invariants
      \end{itemize}
    \item<4-> Predicate for safe values w.r.t world, $\stdvr(W)$
      \begin{itemize}[<8->]
      \item Recursively defined
      \end{itemize}
    \end{itemize}
\end{column}
\begin{column}{0.5\textwidth}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    \scope
      \clip (-.1,-.1) rectangle (6.1,15.1);
      \fill[fill=white] (0,0) rectangle (6,15);
      \draw (0,0) -- (0,15);
      \draw (6,0) -- (6,15);
    \endscope
    % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
    \draw (-1.5,0) node {};
    \draw (-1.5,15) node {};
    \foreach \x in {0.5,1,...,14}
    {
      \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {};
    };

    
    % One capability
    \draw<1-6> [decorate,decoration={brace,amplitude=3pt,mirror,raise=-2pt},yshift=0pt]
    (6.25,2) -- (6.25,5) node[draw=black] (sp1) [black,midway,xshift=6pt] {}; % ,shape=coordinate,xshift=1pt
    \draw<1-4>  (6,7.25) edge[black,->,in=45] (sp1);

    % Invariant colored
    \fill<2->[red,opacity=.7] (0,1) rectangle (6,6);
    \fill<2->[blue,opacity=.7] (0,7) rectangle (6,10);

    \fill<3-6>[black, fill opacity=0, text opacity=0.7] (0,4) rectangle (6,4.5) node[pos=.5] {\footnotesize 42};

    \draw<5> (6,7.25) edge[black,->,in=45] node[right] {\footnotesize \textsc{r}} (sp1)   ;
    \draw<6> (6,7.25) edge[black,->,in=45] node[right] {\footnotesize \textsc{rw}} (sp1)   ;
    \draw<6>[very thick,color=red] (6.5,6.5) -- (8.5,4.5)
    (6.5,4.5) -- (8.5,6.5);

    \draw<7-> [decorate,decoration={brace,amplitude=3pt,mirror,raise=-2pt},yshift=0pt]
    (6.25,2) -- (6.25,5) node[draw=black] (sp1) [black,midway,xshift=6pt] {}; % ,shape=coordinate,xshift=1pt
    \path<7->  (6,4.25) edge[black,out=30,in=135] node[above right]  {\footnotesize \textsc{r}} (8,5) 
              (8,5) edge[black,->,out=-45,in=45](sp1);


  \end{tikzpicture}

\end{column}
\end{columns}
  % Do this as a series of figures?

  % Figure with memory and one capability to make the bound explicit
  \note{compared to normal assembly, capabilities represent bounds on executing block of code.}

  \note{we have no observable I/O, so the authority bounds we consider are related to memory. However, more fine-grained/detailed than read/write-authority.}

  % Color the memory to illustrate different regions of the world
  \note{a piece of code can be bound by arbitrary memory invariants which we define in a \emph{world}.}

  % Write down a static invariant (some address contains 42, maybe write a legend on the left side of slide.).
  \note{essentially, a world is a collection of invariants and safety of words defined with respect to a world.}

  \note{Define a set of words that are safe w.r.t. world W V(W) in P(Word)}



  \note{Whether a capability is safe depends on the authority it carries}

  % Add a read capability to the address that contains 42, safe
  % Add read/write capability to the address that contains 42, not safe - can be used to violate the invariant.
  \note{Example, w.r.t. a world with the invariant that an address contains constant. Safe for read capability, not write as write capability can break this invariant.}

  % Add a read capability that refers to itself
  \note{safety for a read capability is the case if the read capability only gives access to safe capabilities.}

  \note{What if that part of memory contains a read capability for the same part of memory? Cyclic definition. Solved by step-indexing.}

  \note{related to similar issue with languages with recursive types or higher-order ML-list references.}

  \note{Solved by step-indexing - safety up to a certain number of interaction steps.}
\end{frame}

\begin{frame}
  \frametitle{Future Worlds and Invariants, and Recursive Worlds}
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    \scope
      \clip (-.1,-.1) rectangle (6.1,8.1);
      \fill[fill=white] (0,0) rectangle (6,8);
      \draw (0,0) -- (0,8);
      \draw (6,0) -- (6,8);
    \endscope
    % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
    \draw (-1.5,0) node {};
    \draw (-1.5,8) node {};
    \foreach \x in {0.5,1,...,7}
    {
      \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {};
    };

    \fill[red,opacity=.7] (0,7.5) rectangle (6,6);
    \fill[blue,opacity=.7] (0,6) rectangle (6,4);


    

    \begin{onlyenv}<2->
    \scope
      \clip (11.9,-.1) rectangle (18.1,8.1);
      \fill[fill=white] (12,0) rectangle (18,8);
      \draw (12,0) -- (12,8);
      \draw (18,0) -- (18,8);
    \endscope
    % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
    \draw (-1.5,0) node {};
    \draw (-1.5,8) node {};
    \foreach \x in {0.5,1,...,7}
    {
      \draw[fill=white] (12,\x) rectangle (18,\x+.5) node[pos=.5,color=teal] {};
    };

    \fill[red,opacity=.7] (12,7.5) rectangle (18,6);
    \fill[blue,opacity=.7] (12,6) rectangle (18,4);

    \draw [decorate,decoration={brace,amplitude=3pt,raise=2pt},yshift=0pt]
    (11.75,1) -- (11.75,4) node[draw=black] (sp1) [black,midway,xshift=-12pt] {}; % ,shape=coordinate,xshift=1pt
    \draw  (10,0.5) edge[black,->,in=225] (sp1);
    
    \draw (7,7.5) edge [black,thick, ->] node[above] {\footnotesize Memory allocated} (11,7.5);
  \end{onlyenv}
  \begin{onlyenv}<3->
    \fill[green,opacity=.7] (12,4) rectangle (18,1);

    \draw (9,4) node {\huge $\sqsubseteq$};
  \end{onlyenv}
    %Invariant transition systems
    \begin{onlyenv}<4->
    \node[circle,draw=black, fill=white] (a) at (3,6.75) {};
    \draw[>=stealth] (2,6.75) edge[black,->] (a);

    \node[circle,draw=black, fill=white] (b) at (2,5) {};
    \draw[>=stealth] (1,5) edge[black,->] (b);
    \node[circle,draw=black, fill=white] (c) at (4,5) {};
    \draw[>=stealth] (b) edge[black,->, bend left] (c);
    \draw[>=stealth] (c) edge[black,->, bend left] (b);

    \node[circle,draw=black, fill=white] (a2) at (15,6.75) {};
    \draw[>=stealth] (14,6.75) edge[black,->] (a2);

    \node[circle,draw=black, fill=white] (b2) at (14,5) {};
    \draw[>=stealth] (13,5) edge[black,->] (b2);
    \node[circle,draw=black, fill=white] (c2) at (16,5) {};
    \draw[>=stealth] (b2) edge[black,->, bend left] (c2);
    \draw[>=stealth] (c2) edge[black,->, bend left] (b2);

    \node[circle,draw=black, fill=white] (d) at (14,2.5) {};
    \draw[>=stealth] (13,2.5) edge[black,->] (d);
    \node[circle,draw=black, fill=white] (e) at (16,3.25) {};
    \draw[>=stealth] (d) edge[black,->, bend left] (e);
    \draw[>=stealth] (e) edge[black,->, bend left] (d);
    \node[circle,draw=black, fill=white] (f) at (16,1.75) {};
    \draw[>=stealth] (e) edge[black,->, bend left] (f);
  \end{onlyenv}
\end{tikzpicture}

  \begin{overprint}
\onslide<1-4>
  \begin{itemize}
  \item<1-> Memory evolves over time
  \item<3-> Add invariants in future worlds
  \item<4-> Invariants as state machines
  \end{itemize}
  \onslide<5-6>
  \begin{itemize}
  \item<5-> Each state contains a predicate of accepted memory segments
  \item<6-> World indexed
  \end{itemize}
  \[
    H \; :  \only<5>{\phantom{\; \Worlds \fun {}}}\only<6>{\; \Worlds \fun} \mathrm{Pred}(\mathrm{MemSeg})
  \]
\end{overprint}
  \note{Memory changes over time, for instance new memory may be allocated.}
  \note{Allow worlds to evolve. New invariants can be added to handle freshly allocated memory.}
  \note{Safety of words monotone w.r.t. worlds (which makes it into a Kripke Logical relation).}
\end{frame}

% \begin{frame}
%   \frametitle{Invariants and Recursive Worlds}
%   \note{The purpose of a piece of memory may change over time. Invariants need to be more like protocols.}
%   \note{Take a closer look at invariants.}
%   \note{Each invariant is a state machine to model changes of memory invariants for a piece of code over time.}

%   \note{An invariant contains a mapping from states to predicate of memsegs...


%  for pieces of memory it accepts. Predicate may be world dependent (as the validity may depend on the remainder of the memory, which for instance is the case if it contains a capability(?)) or we might just want to say a specific address contains some safe value, but safety is world dependent. This means that the predicate must be world indexed.}
% \end{frame}

\begin{frame}[fragile]
  \frametitle{Local Capabilities}
  \texttt{f} is unknown code and \texttt{c} is a capability.
  \begin{lstlisting}
    f(c);
    f(1)
  \end{lstlisting}
  \begin{itemize}
  \item<2-> \texttt{c} global $\Rightarrow$ available in second invocation of \texttt{f}

    \note{when c global, second invocation in a world where c is safe}
  \item<3-> \texttt{c} local $\Rightarrow$ not available in second invocation of \texttt{f}
    \note{when c local, second invocation in a world where c is not (necessarily) safe}
    \note{c essentially revoked, so the invariants it relies on need not hold.}
  \end{itemize}

  \note{Two future world relations, one for all capabilities and one for non-local capabilities}
  \note{If c global, then second invocation must happen in public future world, so c valid.}
  \note{If c local, then second invocation may happen in a private future world.}
  \begin{onlyenv}<4->
  \begin{lemma}[Double monotonicity of value relation]
    \begin{itemize}
    \item If $\npair{w} \in \stdvr(W)$ and $W' \futurewk W$ then $\npair{w} \in
      \stdvr(W')$.
    \item If $\npair{w} \in \stdvr(W)$ and $W' \futurestr W$ and $w$ is
      not a local capability, then $\npair{w} \in \stdvr(W')$.
    \end{itemize}
  \end{lemma}
\end{onlyenv}
  \note{How does local/global capabilities affect all this.}
  \note{If we hand a global capability to untrusted code, then it may be stored in memory, so we will only be able to reinvoke that code if we can guarantee that those values are still valid. }
  \note{Formally, the worlds contain the invariants that the global capability depend on and reinvocation is only possible in future worlds where these invariants are respected.}
  \note{Local capabilities on the other provides a means to revoke capabilities. If we invoke untrusted code and give them a local capability, then they have no way to store it aside from the register file (and the stack), so when they return we can be sure that the local capability resides nowhere but the register file and the stack.}
  \note{If we clear the register file and stack for old local capabilities before we invoke the untrusted code again, then we have essentially revoked those local capabilities and we can safely invoke the untrusted code again with the assumption that it does not have access to the local capability from the first call.}
  \note{Formally, we allow this call to happen in a \emph{private future} world in which all global capabilities remain safe, but local capabilities don't.}
  \note{We also have a \emph{public future} world relation in which \emph{all} capabilities remain safe.}
  \note{Concretely, worlds may contain temporary regions on which local capabilities may depend. These regions persist in public future worlds which allows the local capabilities to rely on them. On the other hand, in private future worlds temporary regions may be revoked which is why local capabilities may not be safe in private future worlds.}

  \note{include comment about priv/pub future worlds + interplay with monotonicity?}
\end{frame}

\begin{frame}
  \frametitle{Fundamental Theorem of Logical Relations}
    \begin{itemize}
  \item General statement about the guarantees provided by the capability machine.
  \item Intuitively: any program is safe as long as it only has access to safe values.
  \end{itemize}
  \begin{theorem}[Fundamental theorem (simplified)]
      If 
      \[
        \npair{(\start,\addrend)} \in \readCond{}(\gl)(W)
      \]
      then
      \[
        \npair{((\exec,\gl),\start,\addrend,\addr)} \in \stder(W)
      \]
  \end{theorem}

  % Comments/present high-level perspective
  \note{readCond is the assumption that every thing in the interval [a,e] is safe to read.}
  \note{$\stder$ is safe to execute relation. That is, it will respect all the memory invariants.}
  \note{That is take an arbitrary capability. If it only has access to safe capabilities then it will preserve the invariants of the world.}
  \note{Remeber, dynamic checks = failing is concidered secure} 
\end{frame}

\begin{frame}[fragile]
  \frametitle{``Awkward Example''}
    \begin{tabular}{c}
    \begin{lstlisting}
let x = ref 0 in
  (*$\lambda$*)f.(x := 0;
      f();
      x := 1;
      f();
      assert(x == 1))
    \end{lstlisting}
  \end{tabular}
\note{example known from the litterature}
\note{even just in ML difficult as f can be the closure.}
\note{the assert can fail if the calls are not well-bracketed!}  
\note{the local state is difficult to handle as the closure and the contex needs to be able to update the invariant for x in different ways. (closure can switch between 0 and 1 as it pleases, but context can transition only from 0 to 1.)}
\note{relies heavily on well-bracketedness}
\note{we have made a faithfull translation and proved correctness (i.e., the assertion never fails).}
\note{more semantic statement of guarantees allows us to do this.}
\end{frame} 

% \begin{frame}
%   \frametitle{Contributions}
%   \begin{itemize}
%     \item Formalisation of a capability machine with local capabilities
%     \item Novel calling convention for enforcing control-flow correctness and local-state encapsulation
%     \item A calling convention utilizing local capabilities to ensure well-bracketed control-flow and local-state encapsulation
%     \item Step-indexed Kripke Logical Relation to reason about programs on said machine
%       \begin{itemize}
%         \item Single orthogonal closure
%         \item Variant of public/private future world relation to express nature of local capabilities
%       \end{itemize}
%       %new insights for low-level systems?
%     \item FTLR
%       \begin{itemize}
%       \item Semantic statement of guarantees offered by capability machine
%       \end{itemize}
%     \item Logical relation applied to a number of examples
%       \begin{itemize}
%       \item ``Awkward example''
%       \end{itemize}
%     \end{itemize}
% \end{frame}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
  \item Capability machines can guarantee properties of high-level languages
  \item Calling convention for well-bracketedness and local-state encapsulation
  \item Unary step-indexed Kripke logical relation over recursive worlds
    \begin{itemize}
    \item Formal statement about guarantees provided by capability machine
    \item Reasoning about programs in general
    \end{itemize}
  \item Applied on the ``awkward example''
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
  Thank you!
\end{frame}

\end{document}