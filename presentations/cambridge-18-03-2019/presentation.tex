\documentclass[aspectratio=169]{beamer}
\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
  }

\usepackage{appendixnumberbeamer}
\usepackage{xcolor}
\input{preamble}
\input{illu-preamble}

\usepackage{pgfpages}
\setbeameroption{hide notes}
%\setbeameroption{show notes on second screen=right}

\definecolor{myred}{RGB}{192,58,45}
\definecolor{mypurple}{RGB}{180,52,202}
\definecolor{myblue}{RGB}{51,51,179}
\definecolor{mylblue}{RGB}{52,178,204}
\definecolor{mygreen}{RGB}{66,192,103}

\usetikzlibrary{positioning}
\usetikzlibrary{fit}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,shapes}
\usepackage{graphicx}
\usepackage{dashrule}

\renewcommand{\ttdefault}{pcr}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  mathescape=true,
  literate={\$}{\$}{1},
  keywordstyle=\color{mylblue},
  tabsize=2
}

\lstdefinelanguage
   [x64]{Assembler}     % add a "x64" dialect of Assembler
   [x86masm]{Assembler} % based on the "x86masm" dialect
   % with these extra keywords:
   {morekeywords={CDQE,CQO,CMPSQ,CMPXCHG16B,JRCXZ,LODSQ,MOVSXD, %
                  POPFQ,PUSHFQ,SCASQ,STOSQ,IRETQ,RDTSCP,SWAPGS, %
                  rax,rdx,rcx,rbx,rsi,rdi,rsp,rbp, %
                  r8,r8d,r8w,r8b,r9,r9d,r9w,r9b, %
                  r10,r10d,r10w,r10b,r11,r11d,r11w,r11b, %
                  r12,r12d,r12w,r12b,r13,r13d,r13w,r13b, %
                  r14,r14d,r14w,r14b,r15,r15d,r15w,r15b}} % etc.

\tikzset{
  lock/.pic = {
    \draw[even odd rule,fill=gray] (.1,.2) circle[radius=.08]
    (.1,.2) circle[radius=.06];
    \draw[fill=gray] (0,0) rectangle (.2,.2);

    \draw (.086,.054) rectangle (.114,.14);
    \draw (.1,.13) circle[radius=.03];

    \draw[fill=white,draw=none](.096,.064) rectangle (.104,.13);
    \draw[fill=white,draw=none] (.1,.13) circle[radius=.02];
  }
}

\tikzset{capa/.style={decoration={markings,mark=at position 0 with %
      {\fill[black] circle(1.5pt);}}}}

\tikzset{capar/.style={decoration={markings,mark=at position 0 with %
      {\fill[myred] circle(1.5pt);}}}}


\usepackage{tikz-cd}
\pgfdeclarelayer{bg}
\pgfdeclarelayer{mg}
\pgfsetlayers{bg,mg,main}


% \draw <coord> pic {lock};

% \AtBeginSection[]
% {
%   \begin{frame}<beamer>
%     \frametitle{Overview}
%     \tableofcontents[currentsection]
%   \end{frame}
% }


%\input{../illustrations/preamble}
%\input{loc_preamble}
\title{\stktokens{}: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities}
\author{Lau Skorstengaard\inst{1} \and Dominique Devriese\inst{2} \and Lars Birkedal\inst{1}}
\institute{\inst{1} Aarhus University \and %
  \inst{2} Vrije Universiteit Brussel}

\date{Cambridge, March, 2019}


\begin{document}
\beamertemplatenavigationsymbolsempty
\maketitle

\newsavebox{\assem}
\begin{lrbox}{\assem}
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
main:
	.cfi_startproc
# BB#0:
	pushq	%rbp
.Ltmp0:
	.cfi\_def\_cfa\_offset 16
.Ltmp1:
	.cfi\_offset %rbp, -16
	movq	%rsp, %rbp
.Ltmp2:
	.cfi\_def\_cfa\_register %rbp
	subq	$\mbox{\textdollar}$16, %rsp
	movabsq	$\mbox{\textdollar}$.L.str, %rdi
	movl	$\mbox{\textdollar}$0, -4(%rbp)
	movb	$\mbox{\textdollar}$0, %al
	callq	printf
	xorl	%ecx, %ecx
	movl	%eax, -8(%rbp)
	movl	%ecx, %eax
	addq	$\mbox{\textdollar}$16, %rsp
	popq	%rbp
	retq
.Lfunc\_end0:
	.size	main, .Lfunc\_end0-main
	.cfi\_endproc
\end{lstlisting}
\end{lrbox}

\newsavebox{\hello}
\begin{lrbox}{\hello}
\begin{lstlisting}[basicstyle=\tiny\ttfamily, language=C, keywordstyle=\color{mylblue}]
#include <stdio.h>
int main()
{
  int t = 5;
  printf("Hello, World!");

  return 0;
}
\end{lstlisting}
\end{lrbox}


% \begin{frame}
%   \frametitle{Overview}
%   \tableofcontents
% \end{frame}

\section{\stktokens{}-paper in the big picture}
\begin{frame}[fragile]
  \frametitle{Abstractions all the way down}
  \centering
  \begin{tikzpicture}
    % \draw (9.5,0.25) rectangle (13.5,4.75);
    \draw (0,0) node {};
    \node<1->[inner sep=0pt, anchor=west] (hardware) at (9.5,2.5) {\includegraphics[angle=90,width=.285\textwidth]{hardware3-2}};

    \draw<2->[dashed] (9,-.5) -- (9,5.5);
    % \draw (4.75,n0.25) rectangle (8.75,4.75);
    \node<2->[inner sep=0pt, anchor=west] (assem) at (4.4,2.5) {\usebox{\assem}};

    \draw<3->[dashed] (3.9,-.5) -- (3.9,5.5);
    % \draw (0,0.25) rectangle (4,4.75);
    \node<3->[inner sep=0pt, anchor=west] (hello) at (0,2.5) {\usebox{\hello}};

    \draw<4> (.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center] node[above] {\phantom{secure}\\compilation} (4.3, 3.7);
    \draw<5-6> (.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center] node[above] {{\color{myred} secure}\\compilation} (4.3, 3.7);
    \node<6->[rectangle,rotate=-25,fill=white,rounded corners,draw] at (11.5,2.5) {{\color{myred}Capability machine}};

    \begin{onlyenv}<7->
      \draw (0.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center,color=white] node[above] {{\color{myred} secure}\\compilation} (4.3, 3.7);
      \draw node[rectangle,fill=white,draw] at (1.93,3.7) (ir1) {...};
      \draw node[rectangle,fill=white,rounded corners,draw] at (3.15,3.7) (ir2) {IR};
      \draw (0.8, 3.7) edge[-stealth,bend left,very thick] node[above] {} (ir1);
      \draw (ir1) edge[-stealth,bend left,very thick] node[above] {} (ir2);
      \draw (ir2) edge[-stealth,bend left,very thick] node[above] {} (4.3,3.7);
    \end{onlyenv}

    \draw<8-> node at (4.3,3.7) (p) { };
    \draw<8-> node[rectangle, fit=(ir2) (p),draw={rgb:red,192;green,58;blue,45}] (lastphase) {};
  \end{tikzpicture}

  \note[item]{Compbuter at the hardware level is a lot of physics going on very, very quickly.}
  \note[item]{Abstractions: instead of currents, bits.}
  \note[item]{Assembler - a lot more abstraction. We can make sense of it, but still not nice to work with.}
  \note[item]{High-level languages - enough abstractions to work with it and
    build incredible software systems.}
  \note[item]{In order to move between abstractions, we compile programs}
  \note[item]{Most compilers do not provably preserve the abstractions of
    high-level language.}
  \note[item]{This leads to security vulnerabilities}
  \note[item]{Important for compilation to preserve abstractions.}
  \note[item]{A compilation that preserves abstractions, even when linked with
    unknown assembly,is known as a \emph{secure} compilation}
  \note[item]{Little hope that it is possible to make a secure compilation to
    a traditional processor - they have no way to enforce the abstraction.}
  \note[item]{Necessary with hardware with enforcement mechanisms.}
  \note[item]{Our take is that this could be a capability machine}
  \note[item]{Capability machine explained briefly: Basically a processor as
    you know it except pointers are replaced with capabilities. Capabilities
    do not just point to memory, they also carry permissions that specify what
    operations they can be used for and on what part of the memory they can operate.}
  \note[item]{Naturally, this means that the assembly language must be
    capability aware.}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Well-bracketed control flow and local state encapsulation}
  \begin{columns}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[language=C, escapechar=!]
!\tikz[remember picture] \node[] (a) {};!void a()       !\tikz[remember picture] \node[] (bt) {};! 
 {
   !\tikz[remember picture] \node[] (pc6) {};!...
   !\tikz[remember picture] \node[] (pc7) {};!return;!\tikz[remember picture] \node[] (ret) {};!      
 }              !\tikz[remember picture] \node[] (bb) {};!

 void b()
 {
   !\tikz[remember picture] \node[] (pc1) {};!int x = 5;
   !\tikz[remember picture] \node[] (pc2) {};!a();
   !\tikz[remember picture] \node[] (pc3) {};!...
   !\tikz[remember picture] \node[] (pc4) {};!a();
   !\tikz[remember picture] \node[] (pc5) {};!return;   
 }
\end{lstlisting}
% Mention that our work support high-order
% No good definition. We appeal to you intuitive definition
      \begin{tikzpicture}[remember picture, overlay]
%        \draw<1> node { };
        \draw<2>[decorate,decoration={brace,amplitude=6pt,raise=4pt},yshift=0pt] ($(bt) + (0,0.2)$) -- ($(bb) + (0,-0.2)$) node[xshift=0.2cm] (brace) [midway] {};
        \draw<2> node[right = -0cm of brace, text width = 3cm] {Function \texttt{a} cannot access variable \texttt{x}};

        \draw<3> ($(pc4) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc4);
        \draw<4> ($(a) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (a);
        \draw<5> ($(pc6) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc6);
        \draw<6> ($(pc7) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc7);
        \draw<7-> node[below right = of ret] (w) {\huge ?};
        \draw<7-> (ret) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202},bend left] (w);
        \draw<8> ($(pc5) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc5);
        \draw<9> ($(pc3) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc3);
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
      \only<2>{Local-state encapsulation (LSE)}
      \only<3->{Well-bracketed control flow (WBCF)}
    \end{column}
    % What is LSE and WBCF
    % Quick example?
  \end{columns}
\end{frame}

% Secure compilations: If security properties in target can be proven in source.


% 	.type	.L.str,@object          # @.str
% 	.section	.rodata.str1.1,"aMS",@progbits,1
% .L.str:
% 	.asciz	"Hello, World!"
% 	.size	.L.str, 14


% #include <stdio.h>
% int main()
% {
%   printf("Hello, World!");
%   return 0;
% }

%\section{Paper Overview}
% \begin{frame}
%   \frametitle{Linear capability machine}
%   \begin{columns}
% \begin{column}{0.5\textwidth}
%   \begin{itemize}
%   \item<1-> Low-level machine
%     \note<1->[item]{Capability machines are low-level machines proposed in the systems community.}
%     \note<1->[item]{For instance, the CHERI OS operates on one.}
%     \note<1->[item]{Has all the instructions we expect, load, store, jmp, etc.}
%     % \note{Has instructions as you would expect, load, store, jmp, etc.}
%   \item<2-> Capabilities replace pointers
%     \begin{itemize}
%     \item<3-> Pointer
%     \item<4-> Range of authority
%     \item<5-> Kind of authority
%       \note<5->[item]{Roughly two kinds of capabilities:}
%       \begin{itemize}
%       \item read, write, and execute
%         \note<5->[item]{Memory capabilities, allows you to do all the standard memory operations.}
%       \item sealed
%         \note<5->[item]{Provides encapsulation mechanism which allows seperation of security domains.}
%         \note<5->[item]{Can not be used for anything but jump, when jumped to becomes read/execute.}
%       \end{itemize}
%     \end{itemize}
%     \item<6-> Capability manipulation instructions
%     \item<7-> Authority checked dynamically
%     \item<8-> Linear capabilities non-copyable
%       \begin{itemize}
%       \item<9-> Split and splice instructions
%       \end{itemize}
%     \end{itemize}
% \end{column}

% \begin{column}{0.5\textwidth}
%   \begin{tikzpicture}[scale=.5, every node={scale=.5}]
%     \draw (1,9) node {Memory};
%     \draw (-3.5,0) node {\phantom{.}};
%     \scope
%       \clip (-.1,-.1) rectangle (6.1,8.1);
%       \fill[fill=white] (0,0) rectangle (6,8);
%       \draw (0,0) -- (0,8);
%       \draw (6,0) -- (6,8);
%     \endscope
%     % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
%     \draw (-1.5,0) node {};
%     \draw (-1.5,8) node {};
%     \foreach \x in {0.5,1,...,7}
%     {
%       \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {};
%     };

%     \draw<3>  (-3,1.5) edge[black,->,in=180] (0,2.75);

%     \draw<4-9> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,4.5) node[draw=black] (sp1) [black,midway,xshift=-12pt] {};
%     \draw<4>  (-3,1.5) edge[black,->,in=180] node[above left]
%     {\footnotesize\phantom{\textsc{rw}}} (sp1);
%     \draw<5-7>  (-3,1.5) edge[black,->,in=180] node[above left] {\footnotesize \textsc{rw}} (sp1);
    
%     \draw<8-9>  (-3,1.5) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp1);
    
%     \draw<10> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,2.5) node[draw=black] (sp2) [black,midway,xshift=-12pt] {};
%     \draw<10> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,2.5) -- (-0.25,4.5) node[draw=black] (sp3) [black,midway,xshift=-12pt] {};
%     \draw<10>  (-3,2) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp3);
%     \draw<10>  (-3,1) edge[black,->,in=180, dashed] node[below right] {\footnotesize \textsc{rw}} (sp2);
    
%     \draw<11-> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,4.5) node[draw=black] (sp1) [black,midway,xshift=-12pt] {};
%     \draw<11->  (-3,1.5) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp1);
%   \end{tikzpicture}
% \end{column}
% \end{columns}
% \end{frame}
\section{Capability machines and \stktokens{}}

\begin{frame}
  \centering
  \frametitle{Traditional stack pointers}
  \begin{tikzpicture}[scale=.45, every node={scale=.45}]
    % recurrent parts
    \begin{scope}
      \clip (-.1,-.1) rectangle (6.1,15.1);
      \fill[gray!20,draw=none,opacity=.8] (0,0) rectangle (6,15);
      \draw[draw=gray!80] (0,0) -- (0,15);
      \draw[draw=gray!80] (6,0) -- (6,15);
      \draw[fill=white] (0,-.5) rectangle (6,2.5) node[pos=.5] {\scriptsize lower stack frames...};
    \end{scope}
    \draw (-1.5,0) node {};
    \draw (-1.5,15) node {};
    % \draw[->] (-1,0) -- node[midway,sloped,above] {stack grows upward} (-1,15);
    \draw (20,14) node {\phantom{heap memory}};

    % traditional:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.>[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\scriptsize callee stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);

    % traditional return:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call, attack:
    \draw<+->[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.->[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\scriptsize callee stack frame};
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.-> node[right=0cm of sp0] (sp0l) { stack pointer };

    % read other stack frames
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);
    \actadv[.]{(0,5.5)}{(6,8.5)}{callee stack frame}
    \draw<.> (sp0) edge[->,color=myred,very thick,out=235,in=0] node[sloped, below] {read/write} (6,4);

    % break well-bracketedness
    \draw<+>[fill=myred,opacity=.7] (-.5,2.5) rectangle (6.5,8.5);
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.>[myred] (sp0) edge[->,out=235,in=0] (6,1.75);
    \draw<.> node[color=myred,align=left,below=of sp0l] {return but\\
      skip caller frame};
  \end{tikzpicture}

\end{frame}

\begin{frame}
  \frametitle{Naive stack and return capabilities}
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    \draw (20,14) node {\phantom{heap memory}};
    \regfile

    % first step: capabilities
    \begin{onlyenv}<+-+(4)>
      \draw[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize current stack frame};
    \end{onlyenv}
    \begin{onlyenv}<.-.(3)>
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack capability };
      \draw[capa] (r1) edge[->,postaction={decorate},bend left] (sp1);
    \end{onlyenv}
    \begin{onlyenv}<.-.(1)>
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,0) -- (6,16) node (oldframe1) [black,midway,xshift=0.5cm] {};
      \begin{pgfonlayer}{bg}
        \draw<.-.(1)> (7.5,4) node[right,fill=gray!50] (rp1l) {return capability data};
      \end{pgfonlayer}
      \draw (7.4,4.3) pic {lock};
    \end{onlyenv}

    % prepare call: store old return capability
    \draw<+-+(3)>[fill=gray!50] (0,6) rectangle node {\tiny old return cap code} (6,6.5);
    \begin{onlyenv}<+-+(2)>
      \draw[fill=gray!50] (0,5.5) rectangle node {\tiny old return cap data} (6,6);
      % \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt]
      % (0,0) -- (0,16) node (oldframe1) [black,midway,xshift=-0.5cm] {};
      % \draw (0,5.75) edge[->,out=180,in=225] (oldframe1);
    \end{onlyenv}

    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt,aspect=.35},yshift=0pt] (6,2.5) -- (6,16) node (callerframe1) [draw=black,pos=.35,xshift=0.8cm] {};
      \begin{pgfonlayer}{bg}
        \draw<.-> node[fill=gray!50,right=0cm of callerframe1] (rp1l) {new return capability data};
      \end{pgfonlayer}
      \draw[capa] (r2) edge[->,postaction={decorate},bend left] (callerframe1);
      \draw ($(rp1l.west) + (-.1,.3)$) pic {lock};
    \end{onlyenv}
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] (nsp) { new stack capability };
      \draw[capa] (r1) edge[->,postaction={decorate},bend left] (sp1);
    \end{onlyenv}
    
    % call using capabilities
    \begin{onlyenv}<+->
      \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
      \draw[fill=white] (0,6.5) rectangle (6,9.5) node[pos=.5] {\footnotesize callee stack frame};
    \end{onlyenv}
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Attack on naive stack and return capabilities }
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    \regfile

    % attacker...
    \begin{onlyenv}<+-+(2)>
      \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,6.5)}{(6,9.5)}{callee stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};

      \draw node[right=0cm of sp1] { stack pointer };
      \draw[capa] (r1) edge[->,postaction={decorate},bend left] (sp1);
    \end{onlyenv}

    % stores stack pointer in heap
    \begin{onlyenv}<+->
      \begin{scope}
        \fill[gray!20] (18,6) rectangle (22,13);
        \draw (18,6) -- (18,13);
        \draw (22,6) -- (22,13);
      \end{scope}
      \draw (20,14) node {heap memory};
      \draw[fill=gray!50] (18,8) rectangle node[color=myred] {\tiny copy of old sp} (22,8.5);
    \end{onlyenv}
    \draw<.> (18,8.25) edge[->,myred,thick,bend left] (sp1);
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (13.5,6.5) -- (13.5,16) node[draw=black] (spold) [black,midway,xshift=0.8cm] {};
      \draw (18,8.25) edge[->,myred,thick,bend left] (spold);
    \end{onlyenv}

    % attacker returns
    \begin{onlyenv}<+>
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[capa] (r1) edge[->,postaction={decorate},bend left] (sp1);
      \draw[fill=white] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize current stack frame};
    \end{onlyenv}

    % attacker gets called again + uses old stack pointer.
    \begin{onlyenv}<+>
      \draw[fill=gray!50] (0,2.5) rectangle (6,10.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,10.5)}{(6,13.5)}{callee stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,10.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw[capa] (r1) edge[->,postaction={decorate},bend left] (sp1);
      \draw node[right=0cm of sp1] { stack pointer };
      \draw (18,8.25) edge[->,color=myred,very thick,out=235,in=0,near end] node[sloped, below] {read/write} (6,8);
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,2.5) -- (6,16) node (callerframe1) [draw=black,midway,xshift=0.8cm] {};
      % \draw node[fill=gray!50,right=0cm of callerframe1] (rp1l) {return pointer data};
    \end{onlyenv}
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Linear capabilities}
  \begin{columns}
    \begin{column}{.6\textwidth}
      \begin{tikzpicture}[scale=.45, every node={scale=.5}]
        \scope
          \clip (-.1,.1) rectangle (6.1,14.9);
          \fill[draw,fill=white] (0,0) rectangle (6,15);
        \endscope
        % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward}
        % (-2,15);
        \foreach \X in {0.5,1,...,14} {
          \fill[draw,fill=white] (0,\X) rectangle (6,\X+.5) node[pos=.5] { };
        };

        \begin{scope}
          \clip (11.9,2.6) rectangle (13.6,11.6);
          \foreach \X in {0,1.5,...,7.5} {
            \fill[draw,fill=white] (12,10 - \X) rectangle (13.5,11.5-\X) node[pos=.5] { };
          };
        
        \end{scope}
        \coordinate (r1) at (12.75,10.75) {};
        \node[anchor=west] at (13.6,10.75) {$r_1$};
        \coordinate (r2) at (12.75,9.25) {};
        \node[anchor=west] at (13.6,9.25) {$r_2$};
        \coordinate (r3) at (12.75,7.75) {};
        \node[anchor=west] at (13.6,7.75) {$r_3$};
        \coordinate (r4) at (12.75,6.25) {};
        \node[anchor=west] at (13.6,6.25) {$r_4$};

        \draw (12.75,12.25) node[align=center] {Register File};
        \draw (6.5,14.325) node[anchor=west, align=left] {Memory};
        
        % move
        \draw<1-2>[capa] (r2) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,11.25);
        \draw<1-5>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,10) -- (6.1,12.5) node (e) [black,midway,xshift=0.8cm] {};
        \draw<3-4>[capa] (r1) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,11.25);
        \node<3> at (r2) {0};

        % store 
        \draw<4-5>[capa] (r4) edge[->,postaction={decorate},out=180,in=0] node[above] {\tiny\textsc{rw}} (6.3,7.75);
        \draw<4-5>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,6.5) -- (6.1,9) node (e) [black,midway,xshift=0.8cm] {};
        \draw<5>[capa] (3,8.25) edge[postaction={decorate},dashed] (6.3,8.25);
        \draw<5> (6.3,8.25) edge[->,out=0,in=0,dashed] (6.3,11.25);
        \node<5> at (r1) {0};

        % split
        \draw<6>[capa] (r3) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,10);
        \draw<6>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,7.5) -- (6.1,12.5) node (e) [black,midway,xshift=0.8cm] {};

        \draw<7-8>[capa] (r2) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,8.75);
        \draw<7-8>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,7.5) -- (6.1,10) node (e) [black,midway,xshift=0.8cm] {};
        \draw<7-8>[capa] (r1) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,11.25);
        \draw<7-8>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,10) -- (6.1,12.5) node (e) [black,midway,xshift=0.8cm] {};
        \node<7-8> at (r3) {0};

        % splice
        \draw<9>[capa] (r3) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,10);
        \draw<9>[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,7.5) -- (6.1,12.5) node (e) [black,midway,xshift=0.8cm] {};

        \node<9> at (r1) {0};
        \node<9> at (r2) {0};
        
        % splice fail
        \draw<10->[capa] (r1) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,11.25);
        \draw<10->[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,10) -- (6.1,12.5) node (e) [black,midway,xshift=0.8cm] {};
        \draw<10->[capa] (r2) edge[->,postaction={decorate},out=180,in=0,dashed] (6.3,7.75);
        \draw<10->[decorate,decoration={brace,amplitude=2pt,raise=0pt,aspect=0.5,mirror},yshift=0pt] (6.1,6.5) -- (6.1,9) node (e) [black,midway,xshift=0.8cm] {};

        \draw<11>[mygreen,very thick] (5.6,10) -- (6.6,9);
        \draw<11>[mygreen,very thick] (5.6,9) -- (6.6,10);
        \draw<11> node[mygreen,cloud,cloud puffs=10.8,cloud puff arc=110, aspect=3, draw, fill=white, anchor=west] () at (7,9.5) { Splice fails};  
        
      \end{tikzpicture}
    \end{column}
\begin{column}{0.4\textwidth}
  \onslide<1->{Linear capabilities}
  \begin{itemize}
  \item<1-> Non-duplicable
  \item<2-> \texttt{move $r_1$ $r_2$}
  \item<4-> \texttt{store $r_4$ $r_1$}
  \item<6-> \texttt{split $r_1$ $r_2$ $r_3$ $n$}
  \item<8-> \texttt{splice $r_3$ $r_1$ $r_2$}
  \end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
  \frametitle{Call with \stktokens{}}
  % Emphazise that it is dynamically enforced.
  % Other cases, see paper.
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    \draw (20,14) node {\phantom{heap memory}};

    \regfile

    % Caller 
    \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
    \begin{onlyenv}<+>
      \capbrace[sp1]{(6.5,2.5)}{(6.5,16)}
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[capar] (r1) edge[->,myred,thick,bend left,dashed,postaction={decorate}] (sp1);
    \end{onlyenv}


    % Split the stack pointer
    \begin{onlyenv}<+>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw[capar] (r2) edge[->,myred,thick,bend left, dashed,postaction={decorate}] (sp2);
      \draw node[right=0cm of sp2] { private stack pointer };
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw[capar] (r1) edge[->,myred,thick,bend left,dashed,postaction={decorate}] (usp);
      \draw node[right=0cm of usp] { stack pointer };
    \end{onlyenv}


    % Callee called
    \begin{onlyenv}<+>

      \draw node[fill=gray,opacity=0.5, right=0cm of sp2] { \phantom{return token} };
      \draw node[right=0cm of sp2] (rdp) { return token };
      \draw ($(rdp.west) + (-.1,.3)$) pic {lock};
      \inactsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \actsf{(0,5)}{(6,8)}{callee stack frame}
    \end{onlyenv}
    \begin{onlyenv}<.-.(1)>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
    \draw[capar] (r2) edge[->,myred,bend left,dashed,postaction={decorate}] (sp2);

    \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
    \draw[capar] (r1) edge[->,myred,bend left,dashed,postaction={decorate}] (usp);
    \draw node[right=0cm of usp] { stack pointer };
    \end{onlyenv}

    % Return from callee
    \begin{onlyenv}<+>
      \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw node[right=0cm of sp2] { private stack pointer };
    \end{onlyenv}

    \begin{onlyenv}<+>
      \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \capbrace[sp1]{(6.5,2.5)}{(6.5,16)}
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[capar] (r1) edge[->,myred,thick,bend left,dashed,postaction={decorate}] (sp1);
    \end{onlyenv}
  \end{tikzpicture}  
\end{frame}

\begin{frame}
  \frametitle{\stktokens{} prevents the attack}
  % Emphazise that it is dynamically enforced.
  % Other cases, see paper.
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    \draw (20,14) node {\phantom{heap memory}};

    \regfile

    % Caller 
    \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
    \begin{onlyenv}<+>
      \capbrace[sp1]{(6.5,2.5)}{(6.5,16)}
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[capar] (r1) edge[->,myred,thick,bend left,dashed,postaction={decorate}] (sp1);
    \end{onlyenv}


    % Split the stack pointer
    \begin{onlyenv}<+>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw[capar] (r2) edge[->,myred,thick,bend left, dashed,postaction={decorate}] (sp2);
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt] (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw[capar] (r1) edge[->,myred,thick,bend left,dashed,postaction={decorate}] (usp);
      \draw node[right=0cm of usp] { stack pointer };
      \draw node[right=0cm of sp2] { private stack pointer };
    \end{onlyenv}


    % Callee called
    \begin{onlyenv}<+>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw[capar] (r1) edge[->,myred,bend left,dashed,postaction={decorate}] (usp);
      \draw node[right=0cm of usp] { stack pointer };

      \draw node[fill=gray,opacity=0.5, right=0cm of sp2] { \phantom{return token} };
      \draw node[right=0cm of sp2] (rdp) { return token };
      \draw ($(rdp.west) + (-.1,.3)$) pic {lock};
      \inactsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \actadv{(0,5)}{(6,8)}{callee stack frame}
    \end{onlyenv}
    \draw<.->[capar] (r2) edge[->,myred,bend left,dashed,postaction={decorate}] (sp2);


    \begin{onlyenv}<+->
      \begin{scope}
        \fill[gray!20] (14,9) rectangle (18,14);
        \draw (14,9) -- (14,14);
        \draw (18,9) -- (18,14);
      \end{scope}
    \end{onlyenv}
    \draw<.>[fill=white] (14,10) rectangle node[color=myred] {} (18,10.5);

    % Callee stores stack pointer
    \begin{onlyenv}<.->
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (8,5) -- (8,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw (16,15) node {heap memory};
      \node at (r1) {0};
    \end{onlyenv}

    \begin{onlyenv}<.>
      \draw (14,10.25) edge[->,myred,thick,bend right,dashed] (usp);
      \draw[fill=white] (14,10) rectangle node[color=myred] {\tiny old sp} (18,10.5);
      \draw node[right=0cm of usp] { stack pointer };
      \inactsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \actadv{(0,5)}{(6,8)}{callee stack frame}
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw node[fill=gray,opacity=0.5, right=0cm of sp2] { \phantom{return token} };
      \draw node[right=0cm of sp2] (rdp2) { return token };
      \draw ($(rdp2.west) + (-.1,.3)$) pic {lock};
    \end{onlyenv}

    % Return from callee
    \begin{onlyenv}<+->
      \draw (14,10.25) edge[->,myred,bend right,dashed] (usp);
      \draw[fill=gray!50] (14,10) rectangle node[color=myred] {\tiny old sp} (18,10.5);
      \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw node[right=0cm of sp2] { private stack pointer };
      \draw node[right=0cm of usp] { stack pointer };
    \end{onlyenv}

    \draw<+>[mygreen,very thick] (6.4,4.4) -- (7.4,5.4);
    \draw<.>[mygreen,very thick] (7.4,4.4) -- (6.4,5.4);
    \draw<.> node[mygreen,cloud,cloud puffs=10.8,cloud puff arc=110, aspect=3, draw, fill=white, align=center] () at (14,4) { Splice fails,\\ stack pointer is linear!};  
  \end{tikzpicture}  
\end{frame}

% \begin{frame}
%   \frametitle{\stktokens{} enforces single stack}
%   \begin{tikzpicture}[scale=.5, every node={scale=.5}]
%     % recurrent parts
%   \scope
%     \clip (-.1,-.1) rectangle (6.1,15.1);
%     \fill[fill=white] (0,0) rectangle (6,15);
%     \draw (0,0) -- (0,15);
%     \draw (6,0) -- (6,15);
%     \draw[fill=gray!50] (0,-.5) rectangle (6,1.5) node[pos=.5,color=black] {\footnotesize higher stack frames...};
%   \endscope
%   % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
  
%   \begin{scope}
%     \fill[gray!50] (13,0) rectangle (18,13);
%     \draw (13,0) -- (13,13);
%     \draw (18,0) -- (18,13);
%     \draw (15.5,14) node {heap};
%   \end{scope}

% \note{Caller calls callee (split stack pointer to make ret-ptr-d)}
%   \begin{onlyenv}<+>
%     \actsf{(0,1.5)}{(6,4.5)}{caller stack frame}
%   \end{onlyenv}
%   \begin{onlyenv}<.>
%     \capbrace[sp]{(6.1,1.5)}{(6.1,15)}
%     \draw node[right=0cm of sp] { sp };
%   \end{onlyenv}

%   \begin{onlyenv}<+->
%     \inactsf{(0,1.5)}{(6,4.5)}{caller stack frame}
%   \end{onlyenv}
%   \begin{onlyenv}<.>
%     \actadv{(0,4.5)}{(6,7.5)}{callee stack frame}
%     \draw[fill=white] (13,6) rectangle (18,9) node[pos=.5] {\footnotesize adv mem};
%   \end{onlyenv}
%   \begin{onlyenv}<.>
%     \capbrace[sp2]{(6.1,4.5)}{(6.1,15)}
%     \capbrace[sp]{(6.1,1.5)}{(6.1,4.5)}
%     \draw node[right=0cm of sp2] { sp2 };
%     \draw node[right=0cm of sp, fill=gray!50] { ret-ptr-d };
%     \draw (13,6.5) edge[myred,bend right,thick,->,dashed] (sp);
%   \end{onlyenv}

%   \begin{onlyenv}<+>
%     \capbrace[sp3]{(6.1,9.5)}{(6.1,15)}
%     \capbrace[sp2]{(6.1,4.5)}{(6.1,9.5)}
%     \capbrace[sp]{(6.1,1.5)}{(6.1,4.5)}
%     \draw node[right=0cm of sp3] { sp3 };
%     \draw node[right=0cm of sp2] { sp2 };
%     \draw node[right=0cm of sp, fill=gray!50] { ret-ptr-d };
%     \draw (13,7.5) edge[myred,bend right,thick,->,dashed] (sp2);
%     \draw (13,6.5) edge[myred,bend right,thick,->,dashed] (sp);
%   \end{onlyenv}
%   \begin{onlyenv}<.->
%     \actsf{(0,9.5)}{(6,11.5)}{callee stack frame (1)}
%   \end{onlyenv}
%   \begin{onlyenv}<.>
%     \inactadv{(0,4.5)}{(6,7.5)}{callee stack frame}
%     \draw[fill=gray!30] (13,6) rectangle (18,9) node[pos=.5] {\footnotesize adv mem};
%   \end{onlyenv}

%   \begin{onlyenv}<+>
%     \capbrace[sp4]{(6.1,11.5)}{(6.1,15)}
%     \capbrace[sp3]{(6.1,9.5)}{(6.1,11.5)}
%     \capbrace[sp2]{(6.1,4.5)}{(6.1,9.5)}
%     \capbrace[sp]{(6.1,1.5)}{(6.1,4.5)}
%     \draw node[right=0cm of sp4] { sp4 };
%     \draw node[right=0cm of sp3, fill=gray!50] { sp3 };
%     \draw node[right=0cm of sp2] { sp2 };
%     \draw node[right=0cm of sp, fill=gray!50] { ret-ptr-d };
%     \draw (13,8.5) edge[myred,bend right,thick,->,dashed] (sp3);
%     \draw (13,7.5) edge[myred,bend right,thick,->,dashed] (sp2);
%     \draw (13,6.5) edge[myred,bend right,thick,->,dashed] (sp);
%   \end{onlyenv}
%   \begin{onlyenv}<.->
%     \inactsf{(0,9.5)}{(6,11.5)}{callee stack frame (1)}
%     \actadv{(0,11.5)}{(6,14.5)}{callee stack frame (2)}
%   \end{onlyenv}
%   \begin{onlyenv}<.>
%     \actadv{(0,4.5)}{(6,7.5)}{callee stack frame}
%     \draw[fill=white] (13,6) rectangle (18,9) node[pos=.5] {\footnotesize adv mem};
%   \end{onlyenv}

%   \begin{onlyenv}<+->
%     \capbrace[sp4]{(6.1,11.5)}{(6.1,15)}
%     \capbrace[sp3]{(6.1,9.5)}{(6.1,11.5)}
%     \capbrace[sp]{(6.1,1.5)}{(6.1,9.5)}
%     \draw node[right=0cm of sp4, fill=gray!50] { sp4 };
%     \draw node[right=0cm of sp3, fill=gray!50] { sp3 };
%     \draw node[right=0cm of sp] { sp };
%     \draw (13,8.5) edge[myred,bend right,thick,->,dashed] (sp3);
%   \end{onlyenv}
%   \begin{onlyenv}<.->
%     \inactsf{(0,9.5)}{(6,11.5)}{callee stack frame (1)}
%     \inactadv{(0,11.5)}{(6,14.5)}{callee stack frame (2)}
%     \actsf{(0,1.5)}{(6,4.5)}{caller stack frame}
%     \draw[fill=white] (13,6) rectangle (18,9) node[pos=.5] {\footnotesize adv mem};
%   \end{onlyenv}
%   \begin{onlyenv}<+->
%     \draw[mygreen,very thick] (2.5,10) -- (3.5,9);
%     \draw[mygreen,very thick] (3.5,10) -- (2.5,9);
%     \draw node[mygreen,cloud,cloud puffs=10.8,cloud puff arc=110, aspect=3, draw, fill=white, align=center, anchor=west] () at (4,9.5) { Base check fails!};  
%   \end{onlyenv}
% \end{tikzpicture}
% \end{frame}

% \begin{frame}
%   \frametitle{\stktokens{}}
%  \begin{itemize}
%  \item Use linear capability for stack.
% \item On call, split off local stack frame and encapsulate it.
% \item   On return, require that the local stack frame is returned.
% \item   The encapsulated stack frame works like a token that permits you to return. You must use the token when returning.
% \item   A good number of details to get right - see the paper.
%    \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{\stktokens{}: ``Base address'' check}
%   \includegraphics[width=\textwidth]{stk-fig1}
% \end{frame}

\section{Defining well-bracketed control flow and local state encapsulation by fully-abstract overlay semantics}

\begin{frame}[fragile]
  \frametitle{Fully-abstract overlay semantics}
\onslide<7->{\hdashrule[0.1ex]{12cm}{1pt}{5pt}}
\begin{tabular}{p{3.2cm} p{3.2cm}}
\begin{lstlisting}[basicstyle=\tiny\ttfamily,escapechar=!]
   !\tikz[remember picture] \node[] (srccodetl) {};!move  rtmp1 42
   !\tikz[remember picture] \node[] (calltl) {};!store rstk rtmp1
    cca   rstk -1
    geta  rtmp1 rstk
    cca   rretc 5      !\tikz[remember picture] \node[] (callbr) {};!
    move  rtmp1 pc
    cca   rtmp1 -20
\end{lstlisting}& \tikz[remember picture] \node[] (srcm) {};
\begin{lstlisting}[basicstyle=\tiny\ttfamily,escapechar=!]
    load  rtmp1 rtmp1
    cca   rtmp1 -21
    cseal rretd rtmp1
    move  rretc pc
   !\tikz[remember picture] \node[] (retl) {};!xjmp  r1 r2 !\tikz[remember picture] \node[] (retr) {};!
    cseal rretc rtmp1
    move  rtmp1 0    !\tikz[remember picture] \node[] (srccodebr) {};!
\end{lstlisting}
\end{tabular}\tikz[remember picture] \node[] (srcr) {};\\
\onslide<2->{\hdashrule[0.1ex]{12cm}{1pt}{5pt}}
\\\begin{tabular}{p{3.2cm} p{3.2cm}}
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    move  rtmp1 42
    store rstk rtmp1
    cca   rstk -1
    geta  rtmp1 rstk
    cca   rretc 5
    move  rtmp1 pc
    cca   rtmp1 -20
\end{lstlisting}& \tikz[remember picture] \node[] (trgm) {};
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    load  rtmp1 rtmp1
    cca   rtmp1 -21
    cseal rretd rtmp1 
    move  rretc pc
    xjmp  r1 r2
    cseal rretc rtmp1
    move  rtmp1 0
\end{lstlisting}
\end{tabular}\tikz[remember picture] \node[] (trgr) {};
    \begin{tikzpicture}[remember picture, overlay]
      %White overlay
      \draw<1> node[rectangle,fit=(srccodetl) (srccodebr), fill=white] (whiteoverlay) {};

      % Call red overlay
      \draw<4-> node[rectangle, fit=(calltl) (callbr),fill={rgb:red,192;green,58;blue,45},fill opacity=0.6, rounded corners] (call) {};
      \draw<4-> node[rectangle, fit=(calltl) (callbr)] (calltext) [yshift=-0.1cm] {\textbf{\texttt{call}}};

      % LCM text
      \draw node[right = 3.3cm of trgr, text width = 3cm] {Linear Capability Machine};

      % Call stack
      \begin{scope}
        \clip<3-> ($(srcr) + (0.1,-1.2)$) rectangle ($(srcr) + (2.1,-.75)$);
        \draw<3-> ($(srcr) + (0.2,-1.5)$) rectangle ($(srcr) + (2,-.75)$) node[pos=.5,align=center] {\scriptsize{...}};
      \end{scope}
      \draw<3-> ($(srcr) + (0.2,-0.75)$) rectangle ($(srcr) + (2,-0.25)$) node[pos=.5,align=center] {\scriptsize{frame 1}};
      \draw<3-> ($(srcr) + (0.2,-0.25)$) rectangle ($(srcr) + (2,0.25)$) node[pos=.5,align=center] {\scriptsize{frame 2}};
      \draw<3-> ($(srcr) + (0.2,.25)$) rectangle ($(srcr) + (2,.75)$) node[pos=.5,align=center] {\scriptsize{frame 3}};

      \draw<3-> ($(srcr) + (1.1,1.25)$) node[align=center] {\footnotesize{Builtin call stack}};
      \draw<3-> ($(srcr) + (0.2,-.75)$) -- ($(srcr) + (0.2,-1)$);
      \draw<3-> ($(srcr) + (2,-.75)$) -- ($(srcr) + (2,-1)$);
      
      % Return red overlay
      \draw<4-> node[rectangle, fit=(retl) (retr),fill={rgb:red,192;green,58;blue,45},fill opacity=0.6, rounded corners] (ret) {};
      \draw<4-> node[rectangle, fit=(retl) (retr)] (rettext) [yshift=-0.1cm] {\textbf{\texttt{return}}};

      %oLCM text
      \draw<2-> node[right = 3.3cm of srcr, text width = 3cm] {Overlay Semantics};
      % \draw[dashed] (mid) -- ($(mid) + (7,0)$);

      % Compilation, no id
      \draw<5> ($(srcm) + (-0.3,-1)$) edge[bend left, -stealth, very thick] ($(trgm) + (-0.3,-1)$);

      % Compilation with id
      \draw<6-> ($(srcm) + (-0.3,-1)$) edge[bend left, -stealth, very thick] node[right] {$id$} ($(trgm) + (-0.3,-1)$); 

      % % Call stack
      % \begin{scope}
      %   \clip<7-> ($(trgr) + (0.1,-1.2)$) rectangle ($(trgr) + (2.1,-.75)$);
      %   \draw<7-> ($(trgr) + (0.2,-1.5)$) rectangle ($(trgr) + (2,-.75)$) node[pos=.5,align=center] {\scriptsize{...}};
      % \end{scope}
      % \draw<7-> ($(trgr) + (0.2,-0.75)$) rectangle ($(trgr) + (2,-0.25)$) node[pos=.5,align=center] {\scriptsize{frame 1}};
      % \draw<7-> ($(trgr) + (0.2,-0.25)$) rectangle ($(trgr) + (2,0.25)$) node[pos=.5,align=center] {\scriptsize{frame 2}};
      % \draw<7-> ($(trgr) + (0.2,.25)$) rectangle ($(trgr) + (2,.75)$) node[pos=.5,align=center] {\scriptsize{frame 3}};

      % \draw<7-> ($(trgr) + (1.1,1.25)$) node[align=center] {\footnotesize{Builtin call stack}};
      % \draw<7-> ($(trgr) + (0.2,-.75)$) -- ($(trgr) + (0.2,-1)$);
      % \draw<7-> ($(trgr) + (2,-.75)$) -- ($(trgr) + (2,-1)$);
      % \fill<7->[white,opacity=0.75] ($(trgr) + (-.1,1.5)$) rectangle($(trgr) + (2.5,-1.25)$);

      % Higher compilations
      \draw<7> ($(srcm) + (0.2,0.65)$) edge[-stealth,out=-90,in=45,very thick,align=center] ($(srcm) + (-0.3,-0.9)$);
    \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Proof sketch for a realistic secure compiler}
  \begin{center}
  \begin{tikzpicture}[scale=.5, every node={scale=.5},distance=1cm]
    % \draw<1-6> (-5,0) node {};
    % \draw (5,0) node {};
    % \draw (0,-14) node {};
    \draw<1-> node[draw=black,rounded corners,above] (source) {High-level language};
    \draw<1-> node[draw=black,rounded corners,below=of source] (mca) {Assembly w/ many abstractions};
    \draw<1-> node[draw=black,rounded corners,below=1cm of mca] (mcir) {...};
    \draw<1-> node[draw=black,rounded corners,below=1cm of mcir] (mcs) {Assembly w/ built-in stack};
    \draw<1-> node[draw=black,rounded corners,below=of mcs] (target) {Assembly};

    \draw<1-> (source) edge[bend left, ->] (mca);
    \draw<1-> (mca) edge[bend left, ->] (mcir);
    \draw<1-> (mcir) edge[bend left, ->] (mcs);
    \draw<1-> (mcs) edge[bend left, ->] (target);
    \begin{visibleenv}<2->
      \draw node[rectangle, fit=(mca) (target), draw=myred,inner sep=10pt, rounded corners] (lowlevel) {};
      \draw (lowlevel) node[rectangle, inner sep=10pt, opaque=0.5, fill=myred,fill opacity=0.75, text opacity=1,rotate=-30] (text) {Overlay semantics stack};
    \end{visibleenv}
  \end{tikzpicture}                      
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Full abstraction}
  \begin{theorem}[Full abstraction]
  For \tikz[remember picture] \node[inner sep=0pt, outer sep=0pt] (rea) {reasonable};, \tikz[remember picture] \node[inner sep=0pt, outer sep=0pt] (wf) {well-formed};\ $\comp_1$ and $\comp_2$, we have
  \begin{gather*}
    \src{\comp_1} \sconeq \src{\comp_2} \quad \Leftrightarrow \quad    \src{\comp_1} \tconeq \src{\comp_2} \qedhere
  \end{gather*}
\end{theorem}
\vspace{-0.5cm}
\rule{1\textwidth}{0.4pt}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{itemize}[<3->]
    \item \stktokens{} reasonable use of return seals
      \begin{itemize}
      \item Return seals are only used to seal old program pointers.
      \item Every return seal is only used for one call site.
      \item Return seals are not leaked.
      \end{itemize}
    \item<4-> No measures against us
  \end{itemize}
  \end{column}
  \begin{column}{0.5\textwidth}
    \begin{itemize}[<6->]
    \item Component structure
    \item Sane linker behaviour
    \end{itemize}
  \end{column}
\end{columns}
\vspace{0.5cm}
\onslide<7>{\centering Should be handled in earlier compiler phase}
\begin{tikzpicture}[remember picture, overlay]
  \draw<2-4> node[rectangle, fit=(rea), draw=myred, rounded corners, inner sep=2pt, yshift=-1pt, xshift=0.75pt] (n1) {};
  \draw<5-6> node[rectangle, fit=(wf), draw=myred, rounded corners, inner sep=2pt, yshift=-1pt, xshift=0.75pt] (n1) {};
\end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Conclusion}
\begin{itemize}
\item \stktokens{} ensures well-bracketed control flow and local-state encapsulation.
\item Overlay semantics used to define well-bracketed calls and local-state encapsulation.
\item Capability machines may be a good target for secure compilation.
\end{itemize}
  % \begin{description}
  % \item[Formalization of CHERI-like capability machine with linear capabilities]
  % \item[\stktokens{}] a calling convention that provably guarantees LSE and well-bracketed control-flow WBCF
  % \item[Fully-abstract overlay semantics] a novel way to prove LSE and WBCF claims
  %   \begin{itemize}
  %   \item Proven with cross-language logical relations
  %   \end{itemize}
  %   % TODO Mention the proof and logical relation, move to end?
  % \end{description}
\end{frame}

\begin{frame}
  \centering
  Thank you!
\end{frame}

\appendix

\begin{frame}
  \frametitle{\stktokens{} summary}
  \begin{itemize}
  \item Check the base address of the stack capability before and after calls.
  \item Make sure that local stack frames are non-empty.
    % Not illustrated. Trusted code must claim spot on the call stack to make
    % sure that they are returned to.
  \item Create token and data return capability on call: split the stack
    capability in two to get a stack capability for your local stack frame and a
    stack capability for the unused part of the stack. The former is sealed and
    used for the data part of the return pair.
  \item Create code return capability on call: Seal the old program pointer.
  \item Reasonable use of seals: Return seals are only used to seal old program
    pointers, every return seal is only used for one call site, and they are not
    leaked. % If return seals are used for other things, like sealing arbitrary
            % code pointers, then they can be used as an unsealing mechanism.
            % If the same seal is used for multiple call sites, then we lose the
            % guarantee that we return to the correct place. One could use the
            % wrong return capability to return "out of order"
            % If return seals are leaked, then we have no guarantee about what
            % they are used for.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\stktokens{} FAQ}
  \begin{itemize}
  \item \textit{Do you support tail calls?}
    \begin{itemize}
    \item Yes.
    \end{itemize}
  \item \textit{Do you support higher-order functions?}
    \begin{itemize}
    \item Yes.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\stktokens{} vs. CHERI stack}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \textbf{\stktokens{}}
      \begin{itemize}
      \item Single stack
      \item Fine granularity of security domains
      \item No context switch on call
      \item Caller has the full responsibility for securing call
      \item Supports higher-order functions
      \end{itemize}
    \end{column}
    \begin{column}{0.5\textwidth}
      \textbf{CHERI stack}
      \begin{itemize}
      \item Per component stack and trusted centrally-managed stack
      \item Call and return instructions interact with stack
      \item Context switch on call/return
      \item Local capabilities cannot cross security boundary
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}
\end{document}