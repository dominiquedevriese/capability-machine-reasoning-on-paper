\documentclass[aspectratio=169]{beamer}
\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
  }

\usepackage{appendixnumberbeamer}
\usepackage{xcolor}
\input{preamble}
\input{illu-preamble}

\usepackage{pgfpages}
\setbeameroption{hide notes}
%\setbeameroption{show notes on second screen=right}

\definecolor{myred}{RGB}{192,58,45}
\definecolor{mypurple}{RGB}{180,52,202}
\definecolor{myblue}{RGB}{51,51,179}
\definecolor{mylblue}{RGB}{52,178,204}
\definecolor{mygreen}{RGB}{66,192,103}

\usetikzlibrary{positioning}
\usetikzlibrary{fit}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,shapes}
\usepackage{graphicx}
\usepackage{dashrule}

\renewcommand{\ttdefault}{pcr}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  mathescape=true,
  literate={\$}{\$}{1},
  keywordstyle=\color{mylblue},
  tabsize=2
}

\lstdefinelanguage
   [x64]{Assembler}     % add a "x64" dialect of Assembler
   [x86masm]{Assembler} % based on the "x86masm" dialect
   % with these extra keywords:
   {morekeywords={CDQE,CQO,CMPSQ,CMPXCHG16B,JRCXZ,LODSQ,MOVSXD, %
                  POPFQ,PUSHFQ,SCASQ,STOSQ,IRETQ,RDTSCP,SWAPGS, %
                  rax,rdx,rcx,rbx,rsi,rdi,rsp,rbp, %
                  r8,r8d,r8w,r8b,r9,r9d,r9w,r9b, %
                  r10,r10d,r10w,r10b,r11,r11d,r11w,r11b, %
                  r12,r12d,r12w,r12b,r13,r13d,r13w,r13b, %
                  r14,r14d,r14w,r14b,r15,r15d,r15w,r15b}} % etc.



% \AtBeginSection[]
% {
%   \begin{frame}<beamer>
%     \frametitle{Overview}
%     \tableofcontents[currentsection]
%   \end{frame}
% }


%\input{../illustrations/preamble}
%\input{loc_preamble}
\title{\stktokens{}: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities}
\author{Lau Skorstengaard\inst{1} \and Dominique Devriese\inst{2} \and Lars Birkedal\inst{1}}
\institute{\inst{1} Aarhus University \and %
  \inst{2} Vrije Universiteit Brussel}

\date{POPL, January 19, 2019}


\begin{document}
\maketitle

\newsavebox{\assem}
\begin{lrbox}{\assem}
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
main:
	.cfi_startproc
# BB#0:
	pushq	%rbp
.Ltmp0:
	.cfi\_def\_cfa\_offset 16
.Ltmp1:
	.cfi\_offset %rbp, -16
	movq	%rsp, %rbp
.Ltmp2:
	.cfi\_def\_cfa\_register %rbp
	subq	$\mbox{\textdollar}$16, %rsp
	movabsq	$\mbox{\textdollar}$.L.str, %rdi
	movl	$\mbox{\textdollar}$0, -4(%rbp)
	movb	$\mbox{\textdollar}$0, %al
	callq	printf
	xorl	%ecx, %ecx
	movl	%eax, -8(%rbp)
	movl	%ecx, %eax
	addq	$\mbox{\textdollar}$16, %rsp
	popq	%rbp
	retq
.Lfunc\_end0:
	.size	main, .Lfunc\_end0-main
	.cfi\_endproc
\end{lstlisting}
\end{lrbox}

\newsavebox{\hello}
\begin{lrbox}{\hello}
\begin{lstlisting}[basicstyle=\tiny\ttfamily, language=C, keywordstyle=\color{mylblue}]
#include <stdio.h>
int main()
{
  printf("Hello, World!");
  return 0;
}
\end{lstlisting}
\end{lrbox}


% \begin{frame}
%   \frametitle{Overview}
%   \tableofcontents
% \end{frame}

\section{\stktokens{}-paper in the big picture}
\begin{frame}[fragile]
  \frametitle{Abstractions all the way down}
  \centering
  \begin{tikzpicture}
    % \draw (9.5,0.25) rectangle (13.5,4.75);
    \draw (0,0) node {};
    \node<1->[inner sep=0pt, anchor=west] (hardware) at (9.5,2.5) {\includegraphics[angle=90,width=.285\textwidth]{hardware3-2}};

    \draw<2->[dashed] (9,-.5) -- (9,5.5);
    % \draw (4.75,n0.25) rectangle (8.75,4.75);
    \node<2->[inner sep=0pt, anchor=west] (assem) at (4.4,2.5) {\usebox{\assem}};

    \draw<3->[dashed] (3.9,-.5) -- (3.9,5.5);
    % \draw (0,0.25) rectangle (4,4.75);
    \node<3->[inner sep=0pt, anchor=west] (hello) at (0,2.5) {\usebox{\hello}};

    \draw<4> (.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center] node[above] {\phantom{secure}\\compilation} (4.3, 3.7);
    \draw<5-6> (.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center] node[above] {{\color{myred} secure}\\compilation} (4.3, 3.7);
    \node<6->[rectangle,rotate=-25,fill=white,rounded corners,draw] at (11.5,2.5) {{\color{myred}Capability machine}};

    \begin{onlyenv}<7->
      \draw (0.8, 3.7) edge[-stealth,out=25,in=155,very thick,align=center,color=white] node[above] {{\color{myred} secure}\\compilation} (4.3, 3.7);
      \draw node[rectangle,fill=white,draw] at (1.93,3.7) (ir1) {...};
      \draw node[rectangle,fill=white,rounded corners,draw] at (3.15,3.7) (ir2) {ir};
      \draw (0.8, 3.7) edge[-stealth,bend left,very thick] node[above] {} (ir1);
      \draw (ir1) edge[-stealth,bend left,very thick] node[above] {} (ir2);
      \draw (ir2) edge[-stealth,bend left,very thick] node[above] {} (4.3,3.7);
    \end{onlyenv}

    \draw<8-> node at (4.3,3.7) (p) { };
    \draw<8-> node[rectangle, fit=(ir2) (p),draw={rgb:red,192;green,58;blue,45}] (lastphase) {};
  \end{tikzpicture}

  \note[item]{Compbuter at the hardware level is a lot of physics going on very, very quickly.}
  \note[item]{Abstractions: instead of currents, bits.}
  \note[item]{Assembler - a lot more abstraction. We can make sense of it, but still not nice to work with.}
  \note[item]{High-level languages - enough abstractions to work with it and
    build incredible software systems.}
  \note[item]{In order to move between abstractions, we compile programs}
  \note[item]{Most compilers do not provably preserve the abstractions of
    high-level language.}
  \note[item]{This leads to security vulnerabilities}
  \note[item]{Important for compilation to preserve abstractions.}
  \note[item]{A compilation that preserves abstractions, even when linked with
    unknown assembly,is known as a \emph{secure} compilation}
  \note[item]{Little hope that it is possible to make a secure compilation to
    a traditional processor - they have no way to enforce the abstraction.}
  \note[item]{Necessary with hardware with enforcement mechanisms.}
  \note[item]{Our take is that this could be a capability machine}
  \note[item]{Capability machine explained briefly: Basically a processor as
    you know it except pointers are replaced with capabilities. Capabilities
    do not just point to memory, they also carry permissions that specify what
    operations they can be used for and on what part of the memory they can operate.}
  \note[item]{Naturally, this means that the assembly language must be
    capability aware.}
\end{frame}

% Secure compilations: If security properties in target can be proven in source.


% 	.type	.L.str,@object          # @.str
% 	.section	.rodata.str1.1,"aMS",@progbits,1
% .L.str:
% 	.asciz	"Hello, World!"
% 	.size	.L.str, 14


% #include <stdio.h>
% int main()
% {
%   printf("Hello, World!");
%   return 0;
% }

%\section{Paper Overview}
% \begin{frame}
%   \frametitle{Linear capability machine}
%   \begin{columns}
% \begin{column}{0.5\textwidth}
%   \begin{itemize}
%   \item<1-> Low-level machine
%     \note<1->[item]{Capability machines are low-level machines proposed in the systems community.}
%     \note<1->[item]{For instance, the CHERI OS operates on one.}
%     \note<1->[item]{Has all the instructions we expect, load, store, jmp, etc.}
%     % \note{Has instructions as you would expect, load, store, jmp, etc.}
%   \item<2-> Capabilities replace pointers
%     \begin{itemize}
%     \item<3-> Pointer
%     \item<4-> Range of authority
%     \item<5-> Kind of authority
%       \note<5->[item]{Roughly two kinds of capabilities:}
%       \begin{itemize}
%       \item read, write, and execute
%         \note<5->[item]{Memory capabilities, allows you to do all the standard memory operations.}
%       \item sealed
%         \note<5->[item]{Provides encapsulation mechanism which allows seperation of security domains.}
%         \note<5->[item]{Can not be used for anything but jump, when jumped to becomes read/execute.}
%       \end{itemize}
%     \end{itemize}
%     \item<6-> Capability manipulation instructions
%     \item<7-> Authority checked dynamically
%     \item<8-> Linear capabilities non-copyable
%       \begin{itemize}
%       \item<9-> Split and splice instructions
%       \end{itemize}
%     \end{itemize}
% \end{column}

% \begin{column}{0.5\textwidth}
%   \begin{tikzpicture}[scale=.5, every node={scale=.5}]
%     \draw (1,9) node {Memory};
%     \draw (-3.5,0) node {\phantom{.}};
%     \scope
%       \clip (-.1,-.1) rectangle (6.1,8.1);
%       \fill[fill=white] (0,0) rectangle (6,8);
%       \draw (0,0) -- (0,8);
%       \draw (6,0) -- (6,8);
%     \endscope
%     % \draw[->] (-2,0) -- node[midway,sloped,above] {stack grows upward} (-2,15);
%     \draw (-1.5,0) node {};
%     \draw (-1.5,8) node {};
%     \foreach \x in {0.5,1,...,7}
%     {
%       \draw[fill=white] (0,\x) rectangle (6,\x+.5) node[pos=.5,color=teal] {};
%     };

%     \draw<3>  (-3,1.5) edge[black,->,in=180] (0,2.75);

%     \draw<4-9> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,4.5) node[draw=black] (sp1) [black,midway,xshift=-12pt] {};
%     \draw<4>  (-3,1.5) edge[black,->,in=180] node[above left]
%     {\footnotesize\phantom{\textsc{rw}}} (sp1);
%     \draw<5-7>  (-3,1.5) edge[black,->,in=180] node[above left] {\footnotesize \textsc{rw}} (sp1);
    
%     \draw<8-9>  (-3,1.5) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp1);
    
%     \draw<10> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,2.5) node[draw=black] (sp2) [black,midway,xshift=-12pt] {};
%     \draw<10> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,2.5) -- (-0.25,4.5) node[draw=black] (sp3) [black,midway,xshift=-12pt] {};
%     \draw<10>  (-3,2) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp3);
%     \draw<10>  (-3,1) edge[black,->,in=180, dashed] node[below right] {\footnotesize \textsc{rw}} (sp2);
    
%     \draw<11-> [decorate,decoration={brace,amplitude=3pt,raise=0pt},yshift=0pt]
%     (-0.25,1) -- (-0.25,4.5) node[draw=black] (sp1) [black,midway,xshift=-12pt] {};
%     \draw<11->  (-3,1.5) edge[black,->,in=180, dashed] node[above left] {\footnotesize \textsc{rw}} (sp1);
%   \end{tikzpicture}
% \end{column}
% \end{columns}
% \end{frame}
\section{Capability machines and \stktokens{}}

\begin{frame}
  \centering
  \frametitle{Traditional stack pointers}
  \begin{tikzpicture}[scale=.45, every node={scale=.45}]
    % recurrent parts
    \begin{scope}
      \clip (-.1,-.1) rectangle (6.1,15.1);
      \fill[gray!20,draw=none,opacity=.8] (0,0) rectangle (6,15);
      \draw[draw=gray!80] (0,0) -- (0,15);
      \draw[draw=gray!80] (6,0) -- (6,15);
      \draw[fill=white] (0,-.5) rectangle (6,2.5) node[pos=.5] {\scriptsize lower stack frames...};
    \end{scope}
    \draw (-1.5,0) node {};
    \draw (-1.5,15) node {};
    % \draw[->] (-1,0) -- node[midway,sloped,above] {stack grows upward} (-1,15);

    % traditional:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.>[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\scriptsize callee stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);

    % traditional return:
    \draw<+>[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.> (8,7) node[draw=black] (sp0) {};
    \draw<.> node[right=0cm of sp0] (sp0l) { stack pointer };
    \draw<.> (sp0) edge[->,out=235,in=0] (6,5.25);

    % traditional call, attack:
    \draw<+->[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\scriptsize caller stack frame};
    \draw<.->[fill=white] (0,5.5) rectangle (6,8.5) node[pos=.5] {\scriptsize callee stack frame};
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.-> node[right=0cm of sp0] (sp0l) { stack pointer };

    % read other stack frames
    \draw<.> (sp0) edge[->,out=235,in=0] (6,8.25);
    \actadv[.]{(0,5.5)}{(6,8.5)}{callee stack frame}
    \draw<.> (sp0) edge[->,color=red,very thick,out=235,in=0] node[sloped, below] {read/write} (6,4);

    % break well-bracketedness
    \draw<+>[fill=red,opacity=.7] (-.5,2.5) rectangle (6.5,8.5);
    \draw<.-> (8,7) node[draw=black] (sp0) {};
    \draw<.>[red] (sp0) edge[->,out=235,in=0] (6,1.75);
    \draw<.> node[color=red,align=left,below=of sp0l] {return but\\
      skip caller frame};
  \end{tikzpicture}

\end{frame}

\begin{frame}
  \frametitle{Naive stack and return capabilities}
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart

    % first step: capabilities
    \begin{onlyenv}<+-+(4)>
      \draw[fill=white] (0,2.5) rectangle (6,5.5) node[pos=.5] {\footnotesize current stack frame};
    \end{onlyenv}
    \begin{onlyenv}<.-.(3)>
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack capability };
    \end{onlyenv}
    \begin{onlyenv}<.-.(1)>
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,0) -- (6,16) node (oldframe1) [black,midway,xshift=0.5cm] {};
      \draw (7.5,4) node[right,fill=gray!50] (rp1l) {return capability data};
    \end{onlyenv}

    % prepare call: store old return capability
    \draw<+-+(3)>[fill=gray!50] (0,6) rectangle node {\tiny old return cap code} (6,6.5);
    \begin{onlyenv}<+-+(2)>
      \draw[fill=gray!50] (0,5.5) rectangle node {\tiny old return cap data} (6,6);
      % \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt]
      % (0,0) -- (0,16) node (oldframe1) [black,midway,xshift=-0.5cm] {};
      % \draw (0,5.75) edge[->,out=180,in=225] (oldframe1);
    \end{onlyenv}
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt,aspect=.4},yshift=0pt]
      (6,2.5) -- (6,16) node (callerframe1) [draw=black,pos=.4,xshift=0.8cm] {};
      \draw node[fill=gray!50,right=0cm of callerframe1] (rp1l) {new return capability data};
    \end{onlyenv}
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { new stack capability };
    \end{onlyenv}
    
    % call using capabilities
    \begin{onlyenv}<+->
      \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
      \draw[fill=white] (0,6.5) rectangle (6,9.5) node[pos=.5] {\footnotesize callee stack frame};
    \end{onlyenv}
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Attack on naive stack and return capabilities }
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart

    % attacker...
    \begin{onlyenv}<+-+(2)>
      \draw[fill=gray!50] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,6.5)}{(6,9.5)}{callee stack frame}
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,6.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
    \end{onlyenv}

    % stores stack pointer in heap
    \begin{onlyenv}<+->
      \begin{scope}
        \fill[gray!20] (18,6) rectangle (22,13);
        \draw (18,6) -- (18,13);
        \draw (22,6) -- (22,13);
      \end{scope}
      \draw (20,14) node {heap memory};
      \draw[fill=gray!50] (18,8) rectangle node[color=red] {\tiny copy of old sp} (22,8.5);
    \end{onlyenv}
    \draw<.> (18,8.25) edge[->,red,thick,bend left] (sp1);
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (13.5,6.5) -- (13.5,16) node[draw=black] (spold) [black,midway,xshift=0.8cm] {};
      \draw (18,8.25) edge[->,red,thick,bend left] (spold);
    \end{onlyenv}

    % attacker returns
    \begin{onlyenv}<+>
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,2.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      \draw[fill=white] (0,2.5) rectangle (6,6.5) node[pos=.5] {\footnotesize current stack frame};
    \end{onlyenv}

    % attacker gets called again + uses old stack pointer.
    \begin{onlyenv}<+>
      \draw[fill=gray!50] (0,2.5) rectangle (6,10.5) node[pos=.5] {\footnotesize caller stack frame};
      \actadv{(0,10.5)}{(6,13.5)}{callee stack frame}
      \draw (18,8.25) edge[->,color=red,very thick,out=235,in=0] node[sloped, below] {read/write} (6,8);
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
        (6.5,10.5) -- (6.5,16) node[draw=black] (sp1) [black,midway,xshift=0.8cm] {};
      \draw node[right=0cm of sp1] { stack pointer };
      % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      % (6,2.5) -- (6,16) node (callerframe1) [draw=black,midway,xshift=0.8cm] {};
      % \draw node[fill=gray!50,right=0cm of callerframe1] (rp1l) {return pointer data};
    \end{onlyenv}
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{\stktokens{} prevent the attack}
  \centering
  \begin{tikzpicture}[scale=.45, every node={scale=.5}]
    % recurrent parts
    \stdstackstart
    \draw (17.5,5.5) node {register file};
    \begin{scope}
      \clip (16.9,1.1) rectangle (18.1,5.1);
      \foreach \x in {1,2,...,4}
      {
        \draw[fill=white] (17,\x) rectangle (18,\x+1) node[pos=.5,color=teal] {};
      };
    \end{scope}
    \node (r1) at (17.75,4.5) {};
    \node (r2) at (17.75,3.6) {};

    % Caller 
    \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
    \begin{onlyenv}<+>
      \capbrace[sp1]{(6.5,2.5)}{(6.5,16)}
      \draw node[right=0cm of sp1] { stack pointer };
      \draw (r1) edge[->,red,thick,bend left,dashed] (sp1);
    \end{onlyenv}


    % Split the stack pointer
    \begin{onlyenv}<+>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw (r2) edge[->,red,thick,bend left, dashed] (sp2);
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw (r1) edge[->,red,thick,bend left,dashed] (usp);
      \draw node[right=0cm of usp] { stack pointer };
      \draw node[right=0cm of sp2] { private stack pointer };
    \end{onlyenv}


    % Callee called
    \begin{onlyenv}<+>
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (6.5,5) -- (6.5,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw (r1) edge[->,red,bend left,dashed] (usp);
      \draw node[right=0cm of usp] { stack pointer };

      \draw node[fill=gray,opacity=0.5, right=0cm of sp2] { \phantom{return data pointer} };
      \draw node[right=0cm of sp2] { return data pointer };
      \inactsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \actadv{(0,5)}{(6,8)}{callee stack frame}
    \end{onlyenv}
    \draw<.-> (r2) edge[->,red,bend left,dashed] (sp2);


    \begin{onlyenv}<.->
      \begin{scope}
        \fill[gray!20] (14,9) rectangle (18,14);
        \draw (14,9) -- (14,14);
        \draw (18,9) -- (18,14);
      \end{scope}
    \end{onlyenv}
    \draw<.>[fill=white] (14,10) rectangle node[color=red] {} (18,10.5);

    % Callee stores stack pointer
    \begin{onlyenv}<+->
      \draw [decorate,decoration={brace,aspect=0.2,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
      (8,5) -- (8,16) node[draw=black] (usp) [black,pos=0.2,xshift=0.8cm] {};
      \draw (16,15) node {heap memory};
    \end{onlyenv}

    \begin{onlyenv}<.>
      \draw (14,10.25) edge[->,red,thick,bend right,dashed] (usp);
      \draw[fill=white] (14,10) rectangle node[color=red] {\scriptsize old sp} (18,10.5);
      \draw node[right=0cm of usp] { stack pointer };
      \inactsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \actadv{(0,5)}{(6,8)}{callee stack frame}
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw node[fill=gray,opacity=0.5, right=0cm of sp2] { \phantom{return data pointer} };
      \draw node[right=0cm of sp2] { return data pointer };
    \end{onlyenv}

    % Return from callee
    \begin{onlyenv}<+->
      \draw (14,10.25) edge[->,red,bend right,dashed] (usp);
      \draw[fill=gray!50] (14,10) rectangle node[color=red] {\scriptsize old sp} (18,10.5);
      \actsf{(0,2.5)}{(6,5)}{caller stack frame} 
      \capbrace[sp2]{(6.5,2.5)}{(6.5,5)}
      \draw node[right=0cm of sp2] { private stack pointer };
      \draw node[right=0cm of usp] { stack pointer };
    \end{onlyenv}

    \draw<+>[teal,very thick] (6.4,4.4) -- (7.4,5.4);
    \draw<.>[teal,very thick] (7.4,4.4) -- (6.4,5.4);
    \draw<.> node[teal,cloud,cloud puffs=10.8,cloud puff arc=110, aspect=3, draw, fill=white, align=center] () at (14,4) { Splice fails,\\ stack pointer is linear!};  
  \end{tikzpicture}  
\end{frame}

% \begin{frame}
%   \frametitle{\stktokens{}}
%  \begin{itemize}
%  \item Use linear capability for stack.
% \item On call, split off local stack frame and encapsulate it.
% \item   On return, require that the local stack frame is returned.
% \item   The encapsulated stack frame works like a token that permits you to return. You must use the token when returning.
% \item   A good number of details to get right - see the paper.
%    \end{itemize}
% \end{frame}

\section{Defining well-bracketed control flow and local state encapsulation by fully-abstract overlay semantics}
\begin{frame}[fragile]
  \frametitle{Well-bracketed control flow and local state encapsulation}
  \begin{columns}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[language=C, escapechar=!]
!\tikz[remember picture] \node[] (a) {};!void a()       !\tikz[remember picture] \node[] (bt) {};! 
 {
   !\tikz[remember picture] \node[] (pc6) {};!...
   !\tikz[remember picture] \node[] (pc7) {};!return;!\tikz[remember picture] \node[] (ret) {};!      
 }              !\tikz[remember picture] \node[] (bb) {};!

 void b()
 {
   !\tikz[remember picture] \node[] (pc1) {};!int x = 5;
   !\tikz[remember picture] \node[] (pc2) {};!a();
   !\tikz[remember picture] \node[] (pc3) {};!...
   !\tikz[remember picture] \node[] (pc4) {};!a();
   !\tikz[remember picture] \node[] (pc5) {};!return;   
 }
\end{lstlisting}
% Mention that our work support high-order
% No good definition. We appeal to you intuitive definition
      \begin{tikzpicture}[remember picture, overlay]
%        \draw<1> node { };
        \draw<2>[decorate,decoration={brace,amplitude=6pt,raise=4pt},yshift=0pt] ($(bt) + (0,0.2)$) -- ($(bb) + (0,-0.2)$) node[xshift=0.2cm] (brace) [midway] {};
        \draw<2> node[right = -0cm of brace, text width = 3cm] {Function \texttt{a} cannot access variable \texttt{x}};

        \draw<3> ($(pc4) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc4);
        \draw<4> ($(a) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (a);
        \draw<5> ($(pc6) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc6);
        \draw<6> ($(pc7) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc7);
        \draw<7-> node[below right = of ret] (w) {\huge ?};
        \draw<7-> (ret) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202},bend left] (w);
        \draw<8> ($(pc5) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc5);
        \draw<9> ($(pc3) + (-0.5,0)$) edge[-stealth,thick,draw={rgb:red,180;green,52;blue,202}] node {} (pc3);
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
      \only<2>{Local-state encapsulation (LSE)}
      \only<3->{Well-bracketed control flow (WBCF)}
    \end{column}
    % What is LSE and WBCF
    % Quick example?
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fully-abstract overlay Semantics}
\onslide<8->{\hdashrule[0.1ex]{12cm}{1pt}{5pt}}
\begin{tabular}{p{3.2cm} p{3.2cm}}
\begin{lstlisting}[basicstyle=\tiny\ttfamily,escapechar=!]
   !\tikz[remember picture] \node[] (srccodetl) {};!move  rtmp1 42
   !\tikz[remember picture] \node[] (calltl) {};!store rstk rtmp1
    cca   rstk -1
    geta  rtmp1 rstk
    cca   rretc 5      !\tikz[remember picture] \node[] (callbr) {};!
    move  rtmp1 pc
    cca   rtmp1 -20
\end{lstlisting}& \tikz[remember picture] \node[] (srcm) {};
\begin{lstlisting}[basicstyle=\tiny\ttfamily,escapechar=!]
    load  rtmp1 rtmp1
    cca   rtmp1 -21
    cseal rretd rtmp1
    move  rretc pc
   !\tikz[remember picture] \node[] (retl) {};!xjmp  r1 r2 !\tikz[remember picture] \node[] (retr) {};!
    cseal rretc rtmp1
    move  rtmp1 0    !\tikz[remember picture] \node[] (srccodebr) {};!
\end{lstlisting}
\end{tabular}\tikz[remember picture] \node[] (srcr) {};\\
\onslide<2->{\hdashrule[0.1ex]{12cm}{1pt}{5pt}}
\\\begin{tabular}{p{3.2cm} p{3.2cm}}
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    move  rtmp1 42
    store rstk rtmp1
    cca   rstk -1
    geta  rtmp1 rstk
    cca   rretc 5
    move  rtmp1 pc
    cca   rtmp1 -20
\end{lstlisting}& \tikz[remember picture] \node[] (trgm) {};
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    load  rtmp1 rtmp1
    cca   rtmp1 -21
    cseal rretd rtmp1 
    move  rretc pc
    xjmp  r1 r2
    cseal rretc rtmp1
    move  rtmp1 0
\end{lstlisting}
\end{tabular}\tikz[remember picture] \node[] (trgr) {};
    \begin{tikzpicture}[remember picture, overlay]
      %White overlay
      \draw<1> node[rectangle,fit=(srccodetl) (srccodebr), fill=white] (whiteoverlay) {};

      % Call red overlay
      \draw<4-> node[rectangle, fit=(calltl) (callbr),fill={rgb:red,192;green,58;blue,45},fill opacity=0.6, rounded corners] (call) {};
      \draw<4-> node[rectangle, fit=(calltl) (callbr)] (calltext) [yshift=-0.1cm] {\textbf{\texttt{call}}};

      % LCM text
      \draw node[right = 3.3cm of trgr, text width = 3cm] {Linear Capability Machine};

      % Call stack
      \begin{scope}
        \clip<3-> ($(srcr) + (0.1,-1.2)$) rectangle ($(srcr) + (2.1,-.75)$);
        \draw<3-> ($(srcr) + (0.2,-1.5)$) rectangle ($(srcr) + (2,-.75)$) node[pos=.5,align=center] {\scriptsize{...}};
      \end{scope}
      \draw<3-> ($(srcr) + (0.2,-0.75)$) rectangle ($(srcr) + (2,-0.25)$) node[pos=.5,align=center] {\scriptsize{frame 1}};
      \draw<3-> ($(srcr) + (0.2,-0.25)$) rectangle ($(srcr) + (2,0.25)$) node[pos=.5,align=center] {\scriptsize{frame 2}};
      \draw<3-> ($(srcr) + (0.2,.25)$) rectangle ($(srcr) + (2,.75)$) node[pos=.5,align=center] {\scriptsize{frame 3}};

      \draw<3-> ($(srcr) + (1.1,1.25)$) node[align=center] {\footnotesize{Builtin call stack}};
      \draw<3-> ($(srcr) + (0.2,-.75)$) -- ($(srcr) + (0.2,-1)$);
      \draw<3-> ($(srcr) + (2,-.75)$) -- ($(srcr) + (2,-1)$);
      
      % Return red overlay
      \draw<4-> node[rectangle, fit=(retl) (retr),fill={rgb:red,192;green,58;blue,45},fill opacity=0.6, rounded corners] (ret) {};
      \draw<4-> node[rectangle, fit=(retl) (retr)] (rettext) [yshift=-0.1cm] {\textbf{\texttt{return}}};

      %oLCM text
      \draw<2-> node[right = 3.3cm of srcr, text width = 3cm] {Overlay Semantics};
      % \draw[dashed] (mid) -- ($(mid) + (7,0)$);

      % Compilation, no id
      \draw<5> ($(srcm) + (-0.3,-1)$) edge[bend left, -stealth, very thick] ($(trgm) + (-0.3,-1)$);

      % Compilation with id
      \draw<6-> ($(srcm) + (-0.3,-1)$) edge[bend left, -stealth, very thick] node[right] {$id$} ($(trgm) + (-0.3,-1)$); 

      % Call stack
      \begin{scope}
        \clip<7-> ($(trgr) + (0.1,-1.2)$) rectangle ($(trgr) + (2.1,-.75)$);
        \draw<7-> ($(trgr) + (0.2,-1.5)$) rectangle ($(trgr) + (2,-.75)$) node[pos=.5,align=center] {\scriptsize{...}};
      \end{scope}
      \draw<7-> ($(trgr) + (0.2,-0.75)$) rectangle ($(trgr) + (2,-0.25)$) node[pos=.5,align=center] {\scriptsize{frame 1}};
      \draw<7-> ($(trgr) + (0.2,-0.25)$) rectangle ($(trgr) + (2,0.25)$) node[pos=.5,align=center] {\scriptsize{frame 2}};
      \draw<7-> ($(trgr) + (0.2,.25)$) rectangle ($(trgr) + (2,.75)$) node[pos=.5,align=center] {\scriptsize{frame 3}};

      \draw<7-> ($(trgr) + (1.1,1.25)$) node[align=center] {\footnotesize{Builtin call stack}};
      \draw<7-> ($(trgr) + (0.2,-.75)$) -- ($(trgr) + (0.2,-1)$);
      \draw<7-> ($(trgr) + (2,-.75)$) -- ($(trgr) + (2,-1)$);
      \fill<7->[white,opacity=0.75] ($(trgr) + (-.1,1.5)$) rectangle($(trgr) + (2.5,-1.25)$);

      % Higher compilations
      \draw<8> ($(srcm) + (0.2,0.65)$) edge[-stealth,out=-90,in=45,very thick,align=center] ($(srcm) + (-0.3,-0.9)$);
    \end{tikzpicture}
\end{frame}

% \begin{frame}
%   \frametitle{Fully-abstract overlay semantics}
%   \begin{columns}
% \begin{column}{0.5\textwidth}
%   \begin{itemize}[<+->]
%   \item Compile from oLCM to LCM
%   \item Compilation is the identity
%   \item Builtin call stack abstraction in oLCM preserved after compilation
%   \end{itemize}
% \end{column}
% \begin{column}{0.5\textwidth}
%   \begin{tikzpicture}
%     \draw (0,0) node[draw=black, rounded corners] (olcm) {oLCM};
%     \draw node[draw=black, rounded corners,below=2.5cm of olcm] (lcm) {LCM};
%     \draw (olcm) edge[bend left, ->,thick] (lcm);
%     \draw node[left = 3cm of olcm] (ll1) {};
%     \draw node[right = 3cm of olcm] (rl1) {};
%     \draw node[below = 1.25cm of ll1] (ll) {};
%     \draw node[below = 1.25cm of rl1] (rl) {};
%     \draw[dashed] (ll) -- (rl); 

%     \draw<1> (olcm) edge[bend left, ->,thick] node[right, near start] { } (lcm);
%     \draw<2-> (olcm) edge[bend left, ->,thick] node[right, near start] {$id$} (lcm);
%   \end{tikzpicture}
% \end{column}
% \end{columns}
% \end{frame}

% \begin{frame}
%   \frametitle{Evaluating the definition}
%   \begin{enumerate}
%   \item {\itshape Intuitive}\\
%     \onslide<2->{Yes, call stack corresponds exactly to our intuition.}
% \item {\itshape Useful for reasoning}\\% we should be able to use WBCF and LSE
%                                 % when reasoning about correctness and security
%                                 % of programs using \stktokens{}.
%   \onslide<3->{Yes, ...}
% \item {\itshape Reusable in secure compiler chains}\\% for compilers using \stktokens{}, one should be able to rely on WBCF and LSE when proving correctness and security of other compiler passes and then compose such results with ours to obtain results about the full compiler.
%   \onslide<4->{Yes, fully-abstract compilations compose vertically, so oLCM can
%     be used as a target for other compilation phases.}
% \item {\itshape Arguably "complete"}\\% the formalization should arguably capture the entire meaning of WBCF and LSE and should arguably be applicable to any reasonable program. 
%   \onslide<5->{Yes, ...}
% %\item {\itshape potentially scalable}% although dynamic code generation and multi-threading are currently out of scope, the formalization should, at least potentially, extend to such settings.
% \end{enumerate}
% \end{frame}

% \begin{frame}
%   \frametitle{The \stktokens{} calling convention}
%   \begin{onslide}<2->
%     ... is explained in the paper.
%   \end{onslide}
% \end{frame}

\begin{frame}
  \frametitle{Paper overview}
\begin{itemize}
\item LCM: A formalization of a simple CHERI-like capability machine with linear capabilities
\item \stktokens{}, a new calling convention that provably guarantees LSE and WBCF on LCM
\item A new way to formalize these guarantees based on a novel technique called \textit{fully-abstract overlay semantics}
\item Proof of LSE and WBCF which includes
  \begin{itemize}
  \item oLCM: an overlay semantics for LCM with built-in LSE and WBCF
  \item proving full-abstraction for the embedding of oLCM into LCM by
  \item defining and using a cross-language, step-indexed, Kripke logical relation with recursive worlds
  \end{itemize}
\end{itemize}
  % \begin{description}
  % \item[Formalization of CHERI-like capability machine with linear capabilities]
  % \item[\stktokens{}] a calling convention that provably guarantees LSE and well-bracketed control-flow WBCF
  % \item[Fully-abstract overlay semantics] a novel way to prove LSE and WBCF claims
  %   \begin{itemize}
  %   \item Proven with cross-language logical relations
  %   \end{itemize}
  %   % TODO Mention the proof and logical relation, move to end?
  % \end{description}
\end{frame}

\begin{frame}
  \centering
  Thank you!
\end{frame}

% \begin{lstlisting}[basicstyle=\tiny\ttfamily]
%     move rtmp1 42
%     store rstk rtmp1
%     cca rstk -1
%     geta rtmp1 rstk
%     split rstk rretd rstk rtmp1
%     move rtmp1 pc
%     cca rtmp1 -20
%     load rtmp1 rtmp1
%     cca rtmp1 -21
%     cseal rretd rtmp1
%     move rretc pc
%     cca rretc 5
%     cseal rretc rtmp1
%     move rtmp1 0
%     xjmp r1 r2
%     getb rtmp1 rstk
%     minus 1 rtmp1 432
%     move 2 pc
%     cca rtmp2 5
%     jnz rtmp2 rtmp1
%     cca rtmp2 1
%     jmp rtmp2
%     fail
%     splice rstk rdata
%     cca rstk 1
%     move rtmp2 0
% \end{lstlisting}

\appendix
\begin{frame}
  \frametitle{Full-abstraction proof sketch}
  \centering
    \begin{tikzpicture}[scale=0.8,every node/.style={scale=.9}]
    % \draw[help lines,yellow] (0,0) grid (10,7);
    \node at (5,4.7) { ${\src{\comp_1}\mathrel{\sconeq} \src{\comp_2}}$ };

    \node at (3.4,4) { ${\plug{\trg{\context}}{\src{\comp_1}} \sterm[]{\gc}{}}$ };
    \node at (5,4) { $\mathrel{\Rightarrow}$ };
    \node at (6.6,4) { ${\plug{\trg{\context}}{\src{\comp_2}} \sterm[]{\gc}{}}$ };

    \node at (4.35,2.8) {  };
    \node at (5,3.6) {  };
    \node at (5.65,2.8) {  };

    \draw[out=100,in=260,double,-implies,double equal sign distance] (4,2.6) to (4,3.4);

    \draw[out=280,in=80,double,-implies,double equal sign distance] (6,3.4) to (6,2.6);

    \node[align=center] at (8.2,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_2}} \cong {\src{\comp_2}}$};
    \node[align=center] at (1.8,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_1}} \cong {\src{\comp_1}}$};
    % \node at (9,2.7) { $e  {\src{C_1}} \cong \src{C_1}} : tau$ };
    % \node at (8.7,3.3) { $ {\trg{\context}} \cong \trg{\context} :{\emptyset},tau \ra e,{\cdots}$ };
    % \node at (.8,3) { $e  {\src{C_1}} \cong {\src{C_1}} : tau$ };

    \node at (3.4,2) { ${\plug{\trg{\context}}{\src{\comp_1}} \term[]{}}$ };
    \node at (5,2.1) { $\overset{?}{\Rightarrow}$ };
    \node at (6.6,2) { ${\plug{\trg{\context}}{\src{\comp_2}} \term[]{}}$ };

    \node at (5,1.3) { ${\src{\comp_1}}\mathrel{\overset{?}{\tconeq}}{\src{\comp_2}}$ };

    \draw[out=-90,in=90,double,-implies,double equal sign distance] (0,5) to node[sloped, yshift =.7em, below=0.5cm]{\small Contextual equivalence preservation} (0,1);
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Desired properties of LSE and WBCF definition}
  \begin{enumerate}
\item {\itshape intuitive} \label{def-prop:intuitive}
\item {\itshape useful for reasoning:} we should be able to use WBCF and LSE when reasoning about correctness and security of programs using \stktokens{}. \label{def-prop:useful}
\item {\itshape reusable in secure compiler chains:} for compilers using \stktokens{}, one should be able to rely on WBCF and LSE when proving correctness and security of other compiler passes and then compose such results with ours to obtain results about the full compiler.\label{def-prop:reusable}
\item {\itshape arguably "complete"}: the formalization should arguably capture the entire meaning of WBCF and LSE and should arguably be applicable to any reasonable program. \label{def-prop:complete}
\item {\itshape potentially scalable}: although dynamic code generation and multi-threading are currently out of scope, the formalization should, at least potentially, extend to such settings.\label{def-prop:scalable}
\end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{FAQ}
  \begin{itemize}
  \item \textit{Do you support tail calls?}
    \begin{itemize}
    \item Yes.
    \end{itemize}
  \item \textit{Do you support higher-order functions?}
    \begin{itemize}
    \item Yes.
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}