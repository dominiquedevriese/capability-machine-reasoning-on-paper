We thank the reviewers for the thorough and insightful reviews. We will take all comments and remarks into consideration when we produce the final version of the paper and the technical appendix.  Below we address of few specific comments:

* Reviewer A asks "While setting up the logical relation so that the fundamental property implies capability safety is nice, it would be even nicer to prove this as a separate theorem that doesn't have the whole logical relation in its TCB. Would this be possible?"  We believe that capability safety is essentially a deep semantic theorem that should be directly usable for reasoning, and provides guarantees about the behavior of arbitrary terms of a programming language. Formulating deep semantic theorems like this is precisely the purpose of a logical relation and because the theorem proves results about arbitrary terms, it naturally becomes a fundamental theorem. The same approach is used in state of the art work on reasoning about high-level object capability languages, by ourselves and others (see [11,30]).  There exist simpler formulations of capability safety in the literature that do not use logical relations, but those are more syntactic and more superficial and strictly less powerful.

* Reviewer A asks "I wonder if full abstraction is the right notion of secure compilation for this though, given that all your examples were concerned with safety in an adversarial context, not with observational equivalence. Another hint full abstraction might not be a good fit here is that CFI is also a safety property, and full abstraction is not directly related to safety. Another hint full abstraction might not be a good fit here is that CFI is also a safety property, and full abstraction is not directly related to safety." While full abstraction is indeed a relational, binary property, there is ongoing work (being presented at PriSC 2018) on a unary alternative known as robust safety preservation which we believe can be seen as a unary version of full abstraction (although we are not sure the authors of that work see it that way).

* Reviewer C mentions that the technical appendix does not contain formal specifications for macros other than malloc. The implementation of all the macros are, however, present in the technical appendix, and we have used these implementations directly in our reasoning in the remainder of the paper. Further for the two largest macros scall and crtcls, we have lemmas that semantically state what the two macros do. These lemmas are used to aid the reasoning when proving program examples, but they can also be seen as a formal semantic description of the two instructions. The lemmas in question are lemma 58 and 60.
