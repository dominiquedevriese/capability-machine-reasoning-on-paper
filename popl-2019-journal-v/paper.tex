%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%\documentclass[acmsmall]{acmart}\settopmatter{}
%% For editing double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,screen]{acmart}\settopmatter{}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002978.10002986.10002989</concept_id>
<concept_desc>Security and privacy~Formal security models</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10002978.10003006</concept_id>
<concept_desc>Security and privacy~Systems security</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010138</concept_id>
<concept_desc>Theory of computation~Program reasoning</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[300]{Security and privacy~Formal security models}
\ccsdesc[300]{Security and privacy~Systems security}
\ccsdesc[300]{Theory of computation~Program reasoning}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
% \acmJournal{PACMPL}
% \acmVolume{1}
% \acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
% \acmArticle{1}
% \acmYear{2018}
% \acmMonth{1}
% \acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
% \startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
% \setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear
\usepackage[utf8]{inputenc}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


% %% Some recommended packages.
% \usepackage{booktabs}   %% For formal tables:
%                         %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{wrapfig}

\usepackage{placeins}

\usepackage{todonotes}

\input{preamble-illu}
\usetikzlibrary{fit}
\makeatletter
\tikzset{
  fitting node/.style={
    inner sep=0pt,
    fill=none,
    draw=none,
    reset transform,
    fit={(\pgf@pathminx,\pgf@pathminy) (\pgf@pathmaxx,\pgf@pathmaxy)}
  },
  reset transform/.code={\pgftransformreset}
}
\makeatother

\input{../fully-abstract-comp/preamble}
% Paper specific redefinitions of commands
\renewcommand{\MemSeg}{\shareddom{MemSeg}}
\renewcommand{\Reg}{\shareddom{RegFile}}
\renewcommand{\RegName}{\shareddom{RegName}}
\renewcommand{\decInstr}[1]{\plainfun{decode}{#1}}
\renewcommand{\encInstr}[1]{\plainfun{encode}{#1}}
\renewcommand{\updPcAddr}[1]{\plainfun{updPc}{#1}}
\renewcommand{\linCons}[1]{\plainfun{linClear}{#1}}
\renewcommand{\nonExec}[1]{\plainfun{nonExec}{#1}}
\renewcommand{\perm}{\var{p}}
\renewcommand{\SealableCaps}{\shareddom{Sealables}}
\renewcommand{\Cap}{\shareddom{NatTok}}
\renewcommand{\rretc}{\mathrm{r}_{\mathrm{rcode}}}
\renewcommand{\rretd}{\mathrm{r}_{\mathrm{rdata}}}
\renewcommand{\comp}{\var{comp}}
\renewcommand{\Worlds}{\World_{\mathrm{call\_stack}}}
\renewcommand{\Worldfs}{\World_{\mathrm{free\_stack}}}

\renewcommand{\pwpriv}[1][W]{#1.\mathrm{call\_stk}}
\renewcommand{\pwfree}[1][W]{#1.\mathrm{free\_stk}}
\renewcommand{\lrr}{\lrrg{ }}

\renewcommand{\stdreg}[2]{\iota^{\mathrm{std},#2}_{#1}}
\renewcommand{\stareg}[2][\stpair{\ms}{\ms}]{\iota^{\mathrm{sta},#2}_{#1}}
\renewcommand{\codereg}[2][\mathrm{code}]{\iota^{#1}_{#2}}
\renewcommand{\staureg}[2][\stpair{\ms}{\ms}]{\iota^{\mathrm{sta,\lrv},#2}_{#1}}

\renewcommand{\spatialo}{\mathrm{spatial}}
\renewcommand{\spatial}{\mathrm{shadow}}
\renewcommand{\pure}{\mathrm{shared}}

\renewcommand{\purePart}[1]{\plainfun{sharedPart}{#1}}

\newcommand{\xjmpres}[1]{\plainfun{xjmpRes}{#1}}
\newcommand{\srcxjmpres}[1]{\plainfun{\srcalt{xjmpRes}}{#1}}
\newcommand{\wdjud}[2][ ]{#1 \vdash #2}

\newcommand{\erasen}[2]{\lfloor #1 \rfloor_{#2}}

\renewcommand{\tand}{\wedge}
\renewcommand{\tor}{\vee}

\newcommand{\trgcm}{\textsc{LCM}}
\newcommand{\srccm}{\textsc{oLCM}}
\newcommand{\extend}[1]{}
\newcommand{\Rel}[1]{\mathrm{Rel}(#1)}
\newcommand{\fers}[1][n]{\left(\nequal[#1]\right)_{#1=0}^{\infty}}
\newcommand{\cofe}[2][n]{\left(#2,\fers[#1] \right)}
\newcommand{\seq}[2][n]{\left(#2_{#1}\right)_{#1=0}^{\infty}}
\setlength{\belowcaptionskip}{-5pt}

\renewcommand{\sectionname}{Section}

\definecolor{Blue}{RGB}{92,26,143}
\definecolor{OliveGreen}{RGB}{60,128,49}
\newenvironment{jversion}%{}{}
    {\color{OliveGreen}}{}
\newenvironment{jversionsug}
    {\begin{comment}}{\end{comment}}
\newenvironment{thesisonly}{}{}



\newcommand{\ijversion}[1]%{#1}
    {{\color{OliveGreen} #1}}
\newcommand{\ijversionsug}[1]%{}
    {{\color{Blue} #1}}


%%% If you see 'ACMUNKNOWN' in the 'setcopyright' statement below,
%%% please first submit your publishing-rights agreement with ACM (follow link on submission page).
%%% Then please update our instructions page and copy-and-paste the NEW commands into your article.
%%% Please contact us in case of questions; allow up to 10 min for the system to propagate the information.
%%%
%%% The following is specific to POPL '19 and the paper
%%% 'StkTokens: Enforcing Well-Bracketed Control Flow and Stack Encapsulation using Linear Capabilities'
%%% by Lau Skorstengaard, Dominique Devriese, and Lars Birkedal.
%%%
\setcopyright{rightsretained}
\copyrightyear{2019}
\acmJournal{PACMPL}
\acmYear{2019}
\acmVolume{3}
\acmNumber{POPL}
\acmArticle{19}
\acmMonth{1}
\acmPrice{}
\acmDOI{10.1145/3290332}


\begin{document}

%% Title information
\title[\stktokens{}: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using \ldots]{\stktokens{}: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities}
% \titlenote{with title note}
% \subtitle{Fully abstract overlay semantics}
% \subtitlenote{with subtitle note}

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

\author{Lau Skorstengaard}
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \institution{Aarhus~University}
  \country{Denmark}                    %% \country is recommended
}
\email{lask@cs.au.dk}

%% Author with two affiliations and emails.
\author{Dominique Devriese}
\orcid{0000-0002-3862-6856}             %% \orcid is optional
\affiliation{
  \institution{Vrije~Universiteit~Brussel}           %% \institution is required
  \country{Belgium}                   %% \country is recommended
}
\email{dominique.devriese@vub.be}         %% \email is recommended

\author{Lars Birkedal}
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \institution{Aarhus~University}
  \country{Denmark}                    %% \country is recommended
}
\email{birkedal@cs.au.dk}

\begin{abstract}
  We propose and study \stktokens{}: a new calling convention that provably enforces well-bracketed control flow and local state encapsulation on a capability machine.
  The calling convention is based on linear capabilities: a type of capabilities that are prevented from being duplicated by the hardware.
  In addition to designing and formalizing this new calling convention, we also contribute a new way to formalize and prove that it effectively enforces well-bracketed control flow and local state encapsulation using what we call a fully abstract overlay semantics.
\end{abstract}


% %% 2012 ACM Computing Classification System (CSS) concepts
% %% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


\keywords{fully abstract compilation, secure compilation, capability machines, linear capabilities, well-bracketed control flow, stack frame encapsulation, fully abstract overlay semantics}


\maketitle


\renewcommand\lau[1]{{\color{purple} \sf \footnotesize {LS: #1}}\\}
\renewcommand\dominique[1]{{\color{purple} \sf \footnotesize {DD: #1}}\\}
\renewcommand\lars[1]{{\color{purple} \sf \footnotesize {LB: #1}}\\}

\section{Introduction}
\label{sec:introduction}
\todo[inline]{TODOS ENABLED!!!}
Secure compilation is an active topic of research (e.g.~\citep{devriese_modular_2017,patrignani_hyper_2017,Abate:2018:GCG:3243734.3243745,new_universal_embedding_2016,juglaret_beyond_2016, patrignani_2019}), but a real secure compiler is yet to be built.
Secure compilers preserve source-language (security-relevant) properties even when the compiled code interacts with arbitrary target-language components.
Generally, properties that hold in the source language but not in the target language need to be somehow enforced by the compiler.
Two properties that hold in many high-level source languages are well-bracketed control flow and encapsulation of local state, but they are not enforced after compilation to assembly.

Well-bracketed control flow (WBCF) expresses that invoked functions must either return to their callers, invoke other functions themselves or diverge, and generally holds in programming languages that do not offer a primitive form of continuations. 
At the assembly level, this property does not hold immediately. 
Invoked functions get direct access to return pointers that they are supposed to jump to a single time at the end of their execution.
There is, however, no guarantee that untrusted assembly code respects this intended usage.
In particular, a function may invoke return pointers from other stack frames than its own: either frames higher in the call stack or ones that no longer exist as they have already returned. 

Local state encapsulation (LSE) is the guarantee that when a function invokes another function, its local variables (saved on its stack frame) will not be read or modified until the invoked function returns.
At the assembly level, this property also does not hold immediately.
The calling function's local variables are stored on the stack during the invocation, and functions are not supposed to touch stack frames other than their own.
However, untrusted assembly code is free to ignore this requirement and read or overwrite the local state of other stack frames.

To enforce these properties, target language security primitives are needed that can be used to prevent untrusted code from misbehaving without imposing too much overhead on well-behaved code.
The virtual-memory based security primitives on commodity processors do not seem sufficiently fine-grained to efficiently support this.
More suitable security primitives are offered by a type of CPUs known as capability machines \citep{levy_capability-based_1984,watson_cheri_2015}.
These processors use tagged memory to enforce a strict separation between integers and {\itshape capabilities}: pointers that carry authority.
Capabilities come in different flavours.
Memory capabilities allow reading from and writing to a block of memory.
Additionally, capability machines offer some form of {\itshape object capabilities} that represent low-level encapsulated closures, i.e. a piece of code coupled with private state that it gains access to upon invocation.
The concrete mechanics of object capabilities vary between different capability machines.
% KJAA: This 'sealed' and 'common seal' business is unclear to me.
For example, on a recent capability machine called CHERI they take the form of pairs of capabilities that represent the code and data parts of the closure.
Each of the two capabilities are sealed with a common seal which make them opaque.
The hardware transparently unseals the pair upon invocation~\citep{watson_capability_2015,watson_fast_2016}.

To enforce WBCF and LSE on a capability machine, there are essentially two approaches.
The first is to use separate stacks for mutually distrusting components, and a central, trusted stack manager that mediates cross-component invocations.
This idea has been applied in CheriBSD (an operating system built on CHERI)~\citep{watson_capability_2015}, but it is not without downsides.
First, it requires reserving separate stack space for all components, which scales poorly to large amounts of components.
Also, in the presence of higher-order values (e.g., function pointers, objects), the stack manager needs to be able to decide which component a higher-order value belongs to in order to provide it the right stack pointer upon invocation.
It is not clear how it can do this efficiently in the presence of large amounts of components.
Finally, this approach does not allow passing stack references between components.

A more scalable approach retains a single stack shared between components.
Enforcing WBCF and LSE in this approach requires a way to temporarily provide stack and return capabilities to an untrusted component and to revoke them after it returns.
While capability revocation is expensive in general, some capability machines offer restricted forms of revocation that can be implemented efficiently.
For example, CHERI offers a form of {\itshape local} capabilities that can only be stored in registers or on the stack but not in other parts of memory.
\citet{skorstengaard_reasoning_2017} have demonstrated that by making the stack and return pointer local, and by introducing a number of security checks and measures, the two properties can be guaranteed.
In fact, a similar system was envisioned in earlier work on CHERI~\citep{watson2012cheri}. 
% KJAA: 'Boundary crossing' is new here.
However, a problem with this approach is that revoking the local stack and return capabilities on every security boundary crossing requires clearingt the entire unused part of the stack, an operation that may be prohibitively expensive.

In this work, we propose and study \stktokens{}: an alternative calling convention that enforces WBCF and LSE with a single shared stack.
Instead of CHERI's local capabilities, it builds on {\itshape linear} capabilities; a new form of capabilities that has not previously been described in the published literature, although related ideas have been described by~\citet[``scarce objects'']{szabo_formalizing_1997,szabo_scarce_objects} and in technical documents.
Concurrently with our work, Watson et al. have developed a (more realistic) design for linear capabilities in CHERI that is detailed in the latest CHERI ISA reference~\citep{watson2018ISA}.
% KJAA: Perhaps make it clear by who and when/where?
The hardware prevents these capabilities from being duplicated.
We propose to make stack and return pointers linear and require components to hand them out in cross-component invocations and to give them back on return.
The non-duplicability of linear capabilities together with some security checks allow us to guarantee WBCF and LSE without large overhead on boundary crossings and in particular without the need for clearing large blocks of memory.

A second contribution of this work is the way in which we formulate these two properties.
Although the terms ``well-bracketed control flow'' and ``local state encapsulation'' sound precise, it is actually far from clear what they mean, and how best to formalize them.
Existing formulations are either partial and not suitable for reasoning~\cite{abadi_control-flow_2005} or lack evidence of generality~\cite{skorstengaard_reasoning_2017}.
We propose a new formulation using a technique we call {\itshape fully abstract overlay semantics}.
It starts from the premise that security results for a calling convention should be reusable as part of a larger proof of a secure compiler.
To this end, we define a second operational semantics for our target language with a native well-bracketed call stack and primitive ways to do calls and returns.
This well-behaved semantics guarantees WBCF and LSE natively for components using our calling convention.
As such, these components can be sure that they will only ever interact with other well-behaved components that respect our desired properties.
To express security of our calling convention, we then show that considering the same components in the original semantics does not give adversaries additional ways to interact with them. 
More formally, we show that mapping a component in the well-behaved semantics to the same component in the original semantics is fully abstract~\cite{abadi_protection_1999}, i.e.\ components are indistinguishable to arbitrary adversaries in the well-behaved language iff they are indistinguishable to arbitrary adversaries in the original language.

Compared to~\citet{skorstengaard_reasoning_2017} that prove LSE and WBCF for a handful of examples,
this approach expresses what it means to enforce the desirable properties in a general way and makes it clear that we can support a very general class of programs.
Additionally, formulating security of a calling convention in this way makes it potentially reusable in a larger security proof of a full compiler.
The idea is that such a compiler could be proven fully abstract with respect to the well-behaved semantics of the target language, so that the proof could rely on native well-bracketedness and local stack frame encapsulation.
Such an independent result could then be composed with ours to obtain security of the compiler targeting the real target language, by transitivity of full abstraction.

%The main contributions of this paper are (1) \stktokens{} a calling convention that uses linear capabilities to provably secure LSE and WBCF, and (2) a novel proof technique that we call fully-abstract overlay semantics which we apply to prove the properties of \stktokens{}.
In this paper, we make the following contributions:
% Presents the first formal model of a capability machine with linear capabilities (Section 2)
% Presents a calling convention called \stktokens{} that provably guarantee local state encapsulation and well-bracketed control flow (Section 3)
% Presents a novel proof technique that we call fully-abstract overlay semantics. (Section 4-5)
\begin{itemize}
\item We present \trgcm{}: A formalization of a simple CHERI-like capability machine with linear capabilities (Section~\ref{sec:cap-mach-w-seal-and-lin}).
\item We present a new calling convention \stktokens{} that provably guarantees LSE and WBCF on \trgcm{} (Section~\ref{sec:stktokens-explained}).
\item We present a new way to formalize these guarantees based on a novel
  technique called \textit{fully-abstract overlay semantics} and we prove LSE
  and WBCF claims. This includes:
  \begin{itemize}
  \item \srccm{}: an overlay semantics for \trgcm{} with built-in LSE and WBCF (Section~\ref{sec:form-secur-with})
  \item proving full-abstraction for the embedding of \srccm{} into \trgcm{} (Section~\ref{sec:fa-proof}) by
  \item using and defining a cross-language, step-indexed, Kripke logical relation with recursive worlds (Section~\ref{sec:fa-proof}).
  \end{itemize}
\end{itemize}

\begin{jversion}
  This text is an extended version of a paper that was presented at POPL 2019~\citep{skorstengaard_stktokens_2019}.
  Compared to the earlier text, this version adds and explains many of the details that were left out in the conference version due to space restrictions.
  The added details include a better motivation of sealing (\sectionname~\ref{sec:purpose-sealing}), well-formedness components (\sectionname~\ref{sec:well-form-reas}), and reasonable components (\sectionname~\ref{sec:reasonable-components}).
  The section on proving full-abstraction (\sectionname~\ref{sec:fa-proof}) has been rewritten with details and explanations about the formal method used for the full-abstraction proof.
  This includes a detailed description and motivation of the world (\sectionname~\ref{subsec:worlds}) and logical relation (\sectionname~\ref{subsec:logical-relation}).
  This paper is accompanied by a technical report~\citep{technical_report_popl} with the elided details and proof.
\end{jversion}
% Notes on new contributions (based on the journal version environment):
% More details about the definition of the cap. machine (decoding/encoding functions)
% Well-formedness definitions
% Reasonability definition
% Expanded discussion section
% More detailed description of worlds and
%   the logical relation used


%\paragraph{Outline} Blabla

\section{A Capability Machine with Sealing and Linear Capabilities}
\label{sec:cap-mach-w-seal-and-lin}
% Brief intro to section and this cap machine:
% Cap machine inspired by CHERI, but with linear capabilities
In this section, we introduce a simple but representative capability machine with linear capabilities, that we call \trgcm{} (Linear Capability Machine).
\trgcm{} is mainly inspired by CHERI~\citep{watson_cheri_2015} with linear capabilities as the main addition.
For simplicity, \trgcm{} assumes an infinite address space and unbounded integers.
% \lau{Do we have a good reason to assume an infinite address space for this work?
%   We do not model malloc, so we do not need to worry about what happens when malloc runs out of memory.}

%%% Capabilities
The concept of a capability is the cornerstone of any capability machine.
In its simplest form, a capability is a permission and a range of authority.
The permission dictates the operations the capability can be used for, and the range of authority specifies the range of memory it can act upon.
% Permissions and Range of authority
The capabilities on \trgcm{} are of the form $((\var{perm},\var{lin}),\var{base},\var{end},\var{addr})$ (defined in Figure~\ref{fig:target-syntax} with the rest of the syntax of \trgcm{}). Here $\var{perm}$ is the permission, and $[\var{base},\var{end}]$ is the range of authority.
The available permissions are read-write-execute ($\rwx$), read-write ($\rw$), read-execute ($\rx$), read-only ($\ro$), and null-permission ($\noperm$) ordered by $\le$ as illustrated in Figure~\ref{fig:perm-hier}.
% Pointer and linearity
In addition to the permission and range, capabilities also have a current address $\var{addr}$ and a linearity $\var{lin}$.
The linearity is either $\normal$ for traditional capabilities or $\linear$ for linear ones.
% What is linear capabilities, split/splice
A linear capability is a capability that cannot be duplicated.
This is enforced dynamically on the capability machine, so when a linear capability is moved between registers or memory, the source is cleared.
The non-duplicability of linear capabilities means that a linear capability cannot become aliased if it wasn't to begin with.

\begin{wrapfigure}{r}{0.30\linewidth}
  \centering
  \begin{tikzpicture}[main node/.style={}]
    \node[main node] (rwx) {$\rwx$};
    \node[main node] (rx) [below right of=rwx] {$\rx$};

    \node[main node] (rw) [below left of=rwx,] {$\rw$};
    \node[main node] (r) [below right of=rw] {$\readonly$};
    \node[main node] (0) [below of=r] {$\noperm$};

    \path[every node/.style={font=\sffamily\small}]

    (rw) edge (r)
    (r) edge (0)

    (rwx) edge (rx)

    (rw) edge (rwx)
    (r) edge (rx);
  \end{tikzpicture}

  \caption{Permission hierarchy}
  \label{fig:perm-hier}
\end{wrapfigure}%
%
%%% Seals

Any reasonable capability machine needs a way to set up boundaries between security domains with different authorities.
It also must have a way to cross these boundaries such that (1) the security domain we move from can encapsulate and later regain its authority and (2) the security domain we move to regains all of its authority. 
%The M-Machine~\citep{Dally1997Memo59} inspired capability machine in \citet{skorstengaard_reasoning_2017} uses enter-capabilities to achieve this.
On \trgcm{} we have CHERI-like sealed capabilities to achieve this~\cite{watson_cheri_2015,watson_fast_2016}.
% seals
A sealed capability $\sealed{\sigma,\vsc}$ is a pair of a seal $\sigma$ and a capability $\vsc$.
A sealed capability makes an underlying capability opaque which means that the underlying capability cannot be changed or used for the operations it normally gives permission to.
In other words, the authority the underlying capability represents is encapsulated under the seal.
In order to seal a sealable with a seal $\sigma$, it is necessary to have the authority to do so.
The permission to make sealed capabilities is represented by a sets of seals $\seal{\sigma_\var{base},\sigma_\var{end},\sigma_{\var{current}}}$.
A set of seals is a capability that represents the authority to seal sealables with seals in the range $[\sigma_\var{base},\sigma_\var{end}]$.
In spirit of memory capabilities, a set of seals has a current seal $\sigma_{\var{current}}$ that is selected for use in the next seal operation.
% On \trgcm{}, we represent seals in sets rather than single seals to have a more compact representation of multiple seals and make it possible to have seal allocation (not described here).
As we will see later, sealed capabilities can be unsealed with an \texttt{xjmp}, an operation that operates on a pair of capabilities sealed with the same seal.
The instruction will be explained in more detail below, but essentially, it unseals the pair of capabilities, transfers control to one of them (the code part of the pair) and makes the other one (the data part of the pair) available to the invoked code.
The combination of sealed capabilities and \texttt{xjmp} gives (1) and (2).
\begin{figure}[tb]
  \centering
  \[
  \arraycolsep=1.4pt
  \begin{array}{rrcl l rrcl}
   \addrbnf,\basebnf \in & \Addr & \defeq & \nats & \phantom{mak} & \sealbasebnf, \sigma \in & \Seal & \defeq & \nats\\
    \aendbnf \in & & & \Addr \cup \{\infty \} & & \sealendbnf \in & & & \Seal \cup \{\infty \}\\
    \permbnf \in& \Perm & \defbnf & \rwx \mid \rx \mid \rw \mid \ro \mid \noperm & & &\linbnf & \defbnf & \linear \mid \normal\\
    \vsc \in &\SealableCaps&\defbnf & \multicolumn{6}{l}{((\permbnf,\linbnf),\basebnf,\aendbnf,\addrbnf) \mid \seal{\sealbasebnf,\sealendbnf,\sigma}}\\
    c \in&\Caps& \defbnf &  \SealableCaps \mid \sealed{\sigma,\scbnf} & & w \in &\Word & \defeq & \ints \uplus \Caps\\ 
    r \in& \RegName & \defbnf & \multicolumn{6}{l}{\pcreg \mid \rretd \mid \rretc \mid \rstk \mid \rdata \mid \rtmp{1} \mid \rtmp{2} \mid \dots} \\
    \reg \in &\Reg & \defeq & \RegName \fun \Word & & \mem \in&\Mem & \defeq & \Addr \fun \Word\\
\ms \in  &\MemSeg & \defeq & \Addr \parfun \Word & & \Phi \in & \ExecConf & \defeq & \Mem \times \Reg\\
    &\Conf & \defeq & \multicolumn{6}{l}{\ExecConf \cup \{\failed\} \cup \{\halted\} }
  \end{array}
\]
\[
  \arraycolsep=1.4pt
\begin{array}{rcl}
\multicolumn{3}{l}{    \arraycolsep=0pt
      \com{r} \in  \tRegName \hspace{2.5cm}   \com{\rn} \defbnf \com{r} \mid \nats
}\\
  \Instr &\defbnf & \tjmp{\com{r}} \mid \tjnz{\com{r}}{\com{\rn}} \mid \tmove{\com{r}}{\com{\rn}} \mid \tload{\com{r}}{\com{r}} \mid \tstore{\com{r}}{\com{r}} \mid \tplus{\com{r}}{\com{\rn}}{\com{\rn}} \mid \tminus{\com{r}}{\com{\rn}}{\com{\rn}} \mid\\
         & & \tlt{\com{r}}{\com{\rn}}{\com{\rn}} \mid \tisptr{\com{r}}{\com{r}} \mid\tgetp{\com{r}}{\com{r}} \mid \tgetlin{\com{r}}{\com{r}} \mid \tgetb{\com{r}}{\com{r}} \mid \tgete{\com{r}}{\com{r}} \mid \tgeta{\com{r}}{\com{r}}  \mid \\
  & & \tcca{\com{r}}{\com{n\rn}} \mid \tsetatob{\com{r}} \mid \trestrict{\com{r}}{\com{\rn}} \mid \tcseal{\com{r}}{\com{r}} \mid \txjmp{\com{r}}{\com{r}} \mid  \tsplit{\com{r}}{\com{r}}{\com{r}}{\com{\rn}} \mid\\ 
      & & \tsplice{\com{r}}{\com{r}}{\com{r}} \mid \tfail \mid \thalt 
\end{array}
\]
  \caption{The syntax of our capability machine with seals and linear capabilities.}
  \label{fig:target-syntax}
\end{figure}

%%% Domains
Words on \trgcm{} are capabilities and data (represented by integers $\ints$).
We assume a finite set of register names $\RegName$ containing at least the registers $\pcreg$, $\rretd$, $\rretc$, $\rstk$, $\rdata$, $\rtmp{1}$, and $\rtmp{2}$.
We define register files as functions from register names to words.
Complete memories map all addresses to words and memory segments map some addresses to words (i.e.\ partial functions).
$\trgcm{}$ has two terminated configurations $\halted$ and $\failed$ that respectively signify a successful execution and an execution where something went wrong, e.g.,\ an out-of-bounds memory access.
An executable configuration is a register file and memory pair.

\begin{figure}[p]
  \centering
  \begin{mathpar}
    \inference{\Phi(\pcreg) = ((\perm,\_),\baddr,\eaddr,\aaddr) \\
        \baddr \le \aaddr \le \eaddr \and \perm \in \{\rwx,\rx\}
 }{ \Phi \step \sem{\decInstr{\Phi.\mem(\aaddr)}}(\Phi) }
              \and
              \inference{ \forall \Phi' \neq \failed \ldotp \Phi \nrightarrow \Phi'}
                        {\Phi \step \failed }
  \end{mathpar}
  \[
    \begin{array}{l}
  %   \Phi \step
  % \begin{cases}
  %   \sem{\decInstr{\Phi.\mem(\aaddr)}}(\Phi) &
  %   \arraycolsep=0pt
  %     \begin{array}[t]{l}
  %       \text{if }\Phi(\pcreg) = ((\perm,\_),\baddr,\eaddr,\aaddr) \wedge
  %       \baddr \le \aaddr \le \eaddr \wedge \perm \in \{\rwx,\rx\}
  %     \end{array} \\
  %     \failed & \totherwise
  % \end{cases}\\
  \updPcAddr{\Phi} =
  \begin{cases}
    \Phi\updReg{\pcreg}{w} & \Phi(\pcreg) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \wedge w = ((\perm,\lin),\baddr,\eaddr,\aaddr+1)\\
    \Phi  & \totherwise
  \end{cases}\\
  \linCons{w} =
  \begin{cases}
    0 & \isLinear{w} \\
    w & \totherwise
  \end{cases}\\
  \xjmpres{c_1,c_2,\Phi} =
  \begin{cases}
    \Phi\updReg{\pcreg}{c_1}\updReg{\rdata}{c_2} & \nonExec{c_2} \\
    \failed & \totherwise
  \end{cases}
  \end{array}
\]
  \begin{tabular}{|>{$}c<{$}|>{$}p{3.7cm}<{$}|>{\raggedright\arraybackslash}p{6.7cm}|}
    \hline
    i \in \Instr                                 & \sem{i}(\Phi) & Conditions\\
    \hline
    \halt                                        & \halted & \\
    \hline
    \fail                                        & \failed & \\
    % \hline
    % \move{r}{\rn}                                & \updPcAddr{\Phi\updReg{r}{\rn}} & $\rn \in \ints$\\
    \hline
    \move{r}{\rn}                                & \updPcAddr{}\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{\rn}{w_2}\\ & \updReg{r}{w_1})\endarray & $\rn \in \RegName$ and $w_1 = \Phi(\rn)$ and $w_2 = \linCons{\Phi(\rn)}$ \\
    \hline
    \load{r_1}{r_2}                              & \updPcAddr{}\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{r_1}{w_1}\\ &\update{\mem.\aaddr}{w_\aaddr})\endarray & $\Phi(r_2) = ((\perm,\_),\baddr,\eaddr,\aaddr)$ and $\baddr \le \aaddr \le \eaddr$ and $\perm \in \{\rwx,\rw,\rx,\ro\}$ and $w_1 = \Phi.\mem(\aaddr)$ and $\isLinear{w_1} \Rightarrow \perm \in \{\rwx,\rw\}$ and $w_a = \linCons{w_1}$\\
    \hline
    \store{r_1}{r_2}                             & \updPcAddr{}\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{r_2}{w_2}\\ & \update{\mem.\aaddr}{\Phi(r_2)})\endarray & $\Phi(r_1) = ((\perm,\_),\baddr,\eaddr,\aaddr)$ and $\perm \in \{\rwx,\rw\}$ and $\baddr \le \aaddr \le \eaddr$ and $w_2 = \linCons{\Phi(r_2)}$\\
    \hline
    \geta{r_1}{r_2}                              & \updPcAddr{\Phi\updReg{r_1}{w}} & If $\Phi(r_2) = ((\_,\_),\_,\_,\aaddr)$ or $\Phi(r_2) = \seal{\_,\_,\aaddr}$, then $w = \aaddr$ and otherwise $w = -1$\\
    \hline
    \cca{r}{\rn}                                 &\updPcAddr{\Phi\updReg{r}{w}} & $\Phi(\rn) = n \in \ints$ and either $\Phi(r) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ or $\Phi(r) = (\sigma_\baddr,\sigma_\eaddr,\sigma)$ and $w = ((\perm,\lin),\baddr,\eaddr,\aaddr + n)$ or $w = (\sigma_\baddr,\sigma_\eaddr,\sigma+n)$, respectively \\
    \hline
    \jmp{r}    &\Phi\arraycolsep=0pt\array[t]{l}\updReg{r}{w}\\\updReg{\pcreg}{\Phi(r)}\endarray & $w = \linCons{\Phi(r)}$\\
    \hline
    \xjmp{r_1}{r_2}                              & \Phi' & $\Phi(r_1) = \sealed{\sigma,c_1}$ and $\Phi(r_2) = \sealed{\sigma,c_2}$ and $w_1 = \linCons{c_1}$ and $w_2 = \linCons{c_2}$ and $\Phi' = \xjmpres{c_1,c_2,\Phi\updReg{r_1,r_2}{w_1,w_2}}$  \\
    \hline
    \tsplit{r_1}{r_2}{r_3}{\rn}                  & \updPcAddr{}\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{r_3}{w}\\ &\updReg{r_1}{c_1}\\ &\updReg{r_2}{c_2})\endarray & $\Phi(r_3) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi(\rn) = n \in \nats$ and $\baddr \le n < \eaddr$ and $c_1 = ((\perm,\lin),\baddr,n,\aaddr)$ and $c_2 = ((\perm,\lin),n+1,\eaddr,\aaddr)$ and $w = \linCons{\Phi(r_3)}$\\
    \hline
    \splice{r_1}{r_2}{r_3}                       & \updPcAddr{}\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{r_2}{w_2}\\ &\updReg{r_3}{w_3}\\ &\updReg{r_1}{c})\endarray& $\Phi(r_2) = ((\perm,\lin),\baddr,n,\_)$ and $\Phi(r_3) = ((\perm,\lin),n+1,\eaddr,\aaddr)$ and $\baddr \le n < \eaddr$ and $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $w_2,w_3 = \linCons{\Phi(r_2),\Phi(r_3)}$\\
    \hline
    \cseal{r_1}{r_2}                             & \updPcAddr{\Phi\updReg{r_1}{\vsc}} & $\Phi(r_1) \in \SealableCaps$ and $\Phi(r_2) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$ and $\sigma_\baddr \le \sigma \le \sigma_\eaddr$ and $\vsc = \sealed{\sigma,\Phi(r_1)}$ \\
    \hline
    \multicolumn{3}{|c|}{\dots} \\
    \hline
    \_                                           & \failed & \totherwise \\
    \hline
  \end{tabular}
\caption{An excerpt of the operational semantics of \trgcm{}}
  \label{fig:target-op-sem}
\end{figure}
% syntax (instructions)
\trgcm{}'s instruction set is somewhat basic with the instructions one expects on most low-level machines as well as capability-related instructions.
The standard instructions are: unconditional and conditional jump (\texttt{jmp} and \texttt{jnz}), copy between registers (\texttt{move}), instructions that load from memory and store to memory (\texttt{load} and \texttt{store}), and arithmetic operations (\texttt{plus}, \texttt{minus}, and \texttt{lt}).
The simplest of the capability instructions inspect the properties of capabilities: type (\texttt{gettype}), linearity (\texttt{getl}), range (\texttt{getb} and \texttt{gete}), current address or seal (\texttt{geta}) or permission (\texttt{getp}).
The current address (or seal) of a capability (or set of seals) can be shifted by an offset (\texttt{cca}) or set to the base address (\texttt{seta2b}).
The \texttt{restrict} instruction reduces the permission of a capability according to the permission order $\le$.
Generally speaking, a capability machine needs an instruction for reducing the range of authority of a capability.
Because \trgcm{} has linear capabilities, the instruction for this splits the capability in two rather than reducing the range of authority (\texttt{split}).
The reverse is possible using \texttt{splice}.
Sealables can be sealed using \texttt{cseal} and pairs of sealed capabilities can be unsealed by crossing security boundaries (\texttt{xjmp}, see below).
Finally, \trgcm{} has instructions to signal whether an execution was successful or not (\texttt{halt} and \texttt{fail}).

% opsem
The operational semantics of \trgcm{} is displayed in Figure~\ref{fig:target-op-sem}.
The operational semantics is defined in terms of a step relation that executes the next instruction in an executable configuration $\Phi$ which results in a new executable configuration or one of the two terminated configurations.
The executed instruction is determined by the capability in the $\pcreg$ register, i.e.\ $\Phi(\pcreg)$ (we write $\Phi(r)$ to mean $\Phi.\reg(r)$).
In order for the machine to take a step, the capability in the $\pcreg$ must have a permission that allows execution, and the current address of the capability must be within the capability's range of authority.
If both conditions are satisfied, then the word pointed to by the capability is decoded to an instruction which is interpreted relative to $\Phi$.
The interpretations of some of the instructions are displayed in Figure~\ref{fig:target-op-sem}.
In order to step through a program in memory, most of the interpretations use the function $\updPcAddr{}$ which simply updates the capability in the $\pcreg$ to point to the next memory address.
The instructions that stop execution or change the flow of execution do not use $\updPcAddr{}$.
For instance, the \texttt{halt} and \texttt{fail} instructions are simply interpreted as the $\halted$ and $\failed$ configurations, respectively, and they do not use $\updPcAddr{}$.

% move w/ lin
The \texttt{move} instruction simply moves a word from one register to another.
It is, however, complicated slightly by the presence of the non-duplicable linear capabilities.
When a linear capability is moved, the source register must be cleared to prevent duplication of the capability.
This is done uniformly in the semantics using the function $\linCons{}$ that returns $0$ for linear capabilities and is the identity for all other words.
When a word $w$ is transferred on the machine, then the source of $w$ is overwritten with $\linCons{w}$ which clears the source if $w$ was linear and leaves it unchanged otherwise.
In the case of \texttt{move}, the source register $\rn$ is overwritten with $\linCons{\Phi(\rn)}$.

% load w/ lin (and store)
The \texttt{store} and \texttt{load} instructions are fairly standard.
They require a capability with permission to either write or read depending on the operation, they check that the capability points within the range of authority.
Linear capabilities introduce one extra complication for \texttt{load} as it needs to clear the loaded memory address when it contains a linear capability in order to not duplicate the capability.
In this case, we require that the memory capability used for loading also has write-permission.

% geta, cca
The instruction \texttt{geta} projects the current address (or seal) from a capability (or set of seals), and returns $-1$ for data and sealed capabilities.
\texttt{cca} (change current address) changes the current address or seal of a capability or set of seals, respectively, by a given offset.
Note that this instruction does not need to use $\linCons{}$ like the previous ones, because it modifies the capability in-place, i.e.\ the source register is also the target register.
The \texttt{jmp} instruction is a simple jump that just sets register $\pcreg$.

%% Sealing
The operational side of the sealing in \trgcm{} consists of two instructions: \texttt{cseal} for sealing a capability and \texttt{xjmp} for unsealing a pair of capabilities.
% cseal
Given a sealable $\vsc$ and a set of seals where the current seal $\sigma$ is within the range of available seals, the \texttt{cseal} instruction seals $\vsc$ with $\sigma$.
% xjmp
Apart from dealing with linearity, \texttt{xjmp} takes a pair of sealed capabilities, unseals them, and puts one in the $\pcreg$ register and the other in the $\rdata$ register, but only if they are sealed with the same seal and the data capability (the one placed in $\rdata$) is non-executable.
A pair of sealed capabilities can be seen as a closure where the code capability (the capability placed in $\pcreg$) is the program and the data capability is the local environment.
Because of the opacity of sealed capability, the creator of the closure can be sure that execution will start where the code capability points and only in an environment with the related data, i.e.\ sealed with the same seal.
This makes \texttt{xjmp} the mechanism on \trgcm{} that transfers control between security domains.
Opaque sealed capabilities encapsulate a security domain's local state and authority, and they only become accessible again when control is transferred to the security domain.
Some care should be taken for sealing because reusing the same seal for multiple closures makes it possible to jump to the code of one closure with the environment of another.
% xjmp to unseal
\trgcm{} does not have an instruction for unsealing capabilities directly, but it can be (partially) simulated using \texttt{xjmp}.

% split/splice
Instructions for reducing the authority of capabilities are commonplace on capability machines as they allow us to limit what a capability can do before it is passed away.
For normal capabilities, reduction of authority can be done without actually giving up any authority by duplicating the capability first.
With linear capabilities authority cannot be preserved in this fashion as they are non-duplicable.
In order to make a lossless reduction of the range of authority, \trgcm{} provides special hardware support in the form of \texttt{split} and \texttt{splice}.
The \texttt{split} instruction takes a capability with range of authority $[\var{base},\var{end}]$ and an address $n$ and creates two new capabilities, with $[\var{base},n]$ and $[n+1,\var{end}]$ as ranges of authority.
Everything else, i.e.\ permission, linearity and current address, is copied without change to the new capabilities.
With \texttt{split}, we can reduce the range of authority of a linear capability without losing any authority as we retain it in the second capability.
The \texttt{splice} instruction essentially does the inverse of \texttt{split}.
Given two capabilities with adjacent ranges of authority and the same permissions and linearity, \texttt{splice} splices them together into one capability.
The two instructions work in the same way for seal sets.
We do not provide special support for lossless reduction of capability permissions, but this could probably be achieved with more fine-grained permissions.
This would also allow linear capabilities to have aliases, but only by linear capabilities with disjoint permissions.

\begin{jversion}
% The remaining instructions
  The interpretation of the remainder of the instructions are displayed in Appendix~\ref{app:instr-interpretation}.
  The instructions $\tgetb{}{}$, $\tgete{}{}$, $\tgetlin{}{}$, and $\tgetp{}{}$ all project information about capabilities.
  The $\tgetb{}{}$ and $\tgete{}{}$ instructions, respectively, project the base and end address of the range of authority.
  The linearity of a permission is projected with $\tgetlin{}{}$, and finally the permission is projected with $\tgetp{}{}$.
  The instructions $\tgetb{}{}$ and $\tgete{}{}$ also work on sets of seals.
  The instruction $\tisptr{}{}$ returns an integer representation of the type of a word which allows programs to be defensive in the sense that they can check whether a word is a capability before they use it.
  \trgcm{} also has arithmetic instructions $\tplus{}{}{}$, $\tminus{}{}{}$, and $\tlt{}{}{}$.
  The latter instruction compares two numbers and writes 1 or 0 to a target register depending on whether one number is less than the other.
  The instruction $\tsetatob{}$ sets the current address (or seal) of a capability (or set of seals) to the base address of the range of authority (or range of seals).
  This instruction makes it easy to work relatively to the base address of a capability.
  This instruction is not strictly necessary as it can be emulated with other instructions.
  Finally, we have the $\trestrict{}{}$ instruction which restricts the permission of a capability according to the $\le$ relation.
\end{jversion}

\begin{jversion}
  \subsection{The purpose of sealing}
  \label{sec:purpose-sealing}
  % Sealing example:
  To motivate the necessity of an encapsulation mechanism like sealing, consider the following example.
  We, a trusted piece of code, want to transfer control to code that we distrust, and we want to give them the means to return to us.
  That is, we need to give them a return capability.
  If we did not have an encapsulation mechanism, our only option would be to give them an executable capability for the address we want them to return to.
  The untrusted code could use the return capability as intended, but it could also manipulate and make it point to a different address of our code.
  Jumping to such a capability would cause an the program to execute in a way we did not intend for it.
  Further in order to be able to retrieve our capabilities from before transferring control, we would have to store the capabilities somewhere accessible from the return capability.
  However, the untrusted code would have access to all this through the return capability because it gives the same authority to us as the untrusted code.
  This is why, any reasonable capability machine must have an encapsulation mechanism to allow programs to make boundaries between security domains.
  
  In the example, we could seal the return capability to establish a boundary.
  Specifically, it would prevent the untrusted code from changing the target of the return capability forcing them to return to the point we specified.
  It would also prevent the untrusted code from reading our capabilities.
  All in all, this means that we can transfer control to untrusted code without giving up our capabilities or handing them over.

  \trgcm{} does not have a direct unsealing instruction, but it is still possible to emulate a limited unsealing mechanism.
  Say you have a sealed non-executable word $\sealed{\sigma,w}$ as well as a set of seals $\seal{\sigma_\baddr,\sigma_\eaddr, \sigma}$ that contains $\sigma$, i.e.\ $\sigma \in [\sigma_\baddr,\sigma_\eaddr]$.
  Now assume part of the code would like to have access to $w$ in $\rdata$.
  Take a capability for this code, possibly by adjusting the pc, and seal it with $\sigma$.
  Now you have the data part and the code part of a sealed capability pair, so you can $\txjmp{}{}$ to it which unseals the data capability and puts it in $\rdata$ for your code to use.
  Sealed executable capabilities cannot be unsealed in the same way because $\txjmp{}{}$ fails if the data capability is executable.
  However, given a sealed executable capability $\sealed{\sigma,c}$ and a set of seals that contains $\sigma$, we can still construct the data part of the sealed capability pair.
  This means that we can execute the code the capability points to together with data that it was not intended to be used with.

  Sealing is meant for encapsulation, but it relies on seals being kept private as illustrated by the unsealing emulation.
  For this reason, it is important that the system is initialised such that each component has access to unique seals.
  We return to this in \sectionname~\ref{sec:well-form-reas}.
\end{jversion}

\begin{jversion}
\subsection{Decoding and encoding functions}
The operational semantics of the capability machine uses the function $\decInstr{}$ to decode instructions.
We also assume a function $\encInstr{}$ to make it easy to specify programs in terms of instructions.
Rather than specifying a decode function and an encode function, we assume that they are given with certain properties.
The $\decInstr{} : \Word \fun \Instr$ should be surjective and injective for all non-$\fail$ instructions.
Further, it should decode all capabilities as the $\fail$ instruction, i.e.\
\[
\forall c \in \Caps \ldotp \decInstr{c} = \fail
\]
The $\encInstr{} : \Instr \fun \ints$ function should be injective, and it should be defined so $\decInstr{}$ is its left inverse, i.e.
\[
\forall i \in \Instr \ldotp \decInstr{}(\encInstr{i}) = i
\]

These assumptions are sufficient to construct program examples and run them on the machine.
The $\encInstr{}$ function allows us to specify the program ``abstractly'' in terms of instructions rather than machine words.
As the $\decInstr{}$ function is the left inverse of $\encInstr{}$, we can even execute the program in the operational semantics without ever worrying about what the actual encoding is.
%This is not to say that encoding is an easy problem. There are many things to get.

The machine also assumes decode and encode functions for permissions $\decPerm{} : \Perm \fun \ints$ and $\encPerm{} : \ints \fun \Perm$.
We assume the $\decPerm{}$ function to be the left inverse of $\encPerm{}$ and surjective. For $\encPerm{}$, we assume it is surjective and that it does not encode anything to the $\tgetp{}{}$ error value -1, i.e.
\[
  \forall \perm \in \Perm \ldotp \encPerm{\perm} \neq -1
\]
For linearity we assume similar functions.

Finally in the interpretation of $\tisptr{}{}$, the machine uses an encode function for word types $\encType{}$.
This function encodes each kind of word as an integer.
This is very much like the previous functions.
It encodes each kind of word differently and all words of the same kind to the same integer.
\end{jversion}

\subsection{Components, linking, programs, and contexts }
\label{subsec:components-linking}
The executable configuration describes the machine state, but it does not make it clear what components run on the machine and how they interact with each other.
To clarify this, we introduce notions of components and programs from which we construct executable configurations.
A component (defined in Figure~\ref{fig:target-component-and-linking}) is basically a program with entry points in the form of imports that need to be linked.
It has exports that can satisfy the imports of other components.
% Structure
A base component $\comp_0$ consists of a code memory segment, a data memory segment, a list of imported symbols, a list of exported symbols, two lists specifying the available seals\footnote{We will return to the seals in Section~\ref{sec:form-secur-with}.}, and a set of all the linear addresses (addresses governed by a linear capability).
The import list specifies where in memory imports should be placed, and imports are matched to exports via their symbols.
The exports are words each associated with a symbol.
%base = library
A component is either a library component (without a main entry point) or an incomplete program with a main in the form of a pair of sealed capabilities.
The latter can be seen as a program that still needs to be linked with libraries.
% Linking .
Components are combined into new components by linking them together, as long as only one is an incomplete program with a main.
Two components can be linked when their memories, seals, and linear addresses are disjoint.
They are combined by taking the union of each of their constituents.
For every import that is satisfied by an export of the other component, the data memory is updated to have the exported word on the imported address.
The satisfied imports are removed from the import list in the resulting linked component and the exports are updated to be the exports of the two components.

% Programs
We can now define the notion of a program as well as a context.
\begin{definition}[Programs and Contexts]
  \label{def:program-and-context}
  A \emph{program} is a component $(\comp_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})$ with an empty import list.
  A \emph{context} for a component $\comp$ is a component $\comp'$ such that $\comp \bowtie \comp'$ is a program.
\end{definition}
% Getting an executable from a component - postpone this to later, but mention:
% write xor exec
How a program is initialised to create an executable configuration, is discussed in Section~\ref{sec:form-secur-with}.
% We will, however, at this point mention that all programs will be instrumented as Write-XOR-Execute,{Do we have a reference for this?} i.e.\ there will only be read-execute capabilities for the code and read-write capabilities for the data.
%Further, we will only consider a specific class of well-formed components, but we will get back to this.
Some simplifications have been made in this presentation of \trgcm{}. See \citet{technical_report_popl} for details.
\begin{figure}[tb]
  \centering
  \[
    \begin{array}{rl c rl c rl}
    s &\in \Symbol & \phantom{make} &
    \mathrm{import} &\mathrel{::=} a \mapsfrom s & \phantom{make} &
    \mathrm{export} &\mathrel{::=} s \mapsto w\\
    \comp_0 & \multicolumn{7}{l}{\mathrel{::=} (\mscode,\msdata,\overline{\mathrm{import}},\overline{\mathrm{export}},\sigrets,\sigcloss,A_\linear)}\\
    \comp & \multicolumn{7}{l}{\mathrel{::=} \comp_0 \mid  (\comp_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})}
  \end{array}
\]
\vspace{0.5cm}
\begin{mathpar}
  \inference{
    \comp_0 = (\mscode[1], \msdata[1], \overline{\var{import}_1}, \overline{\var{export}_1}, \sigrets[1], \sigcloss[1],A_{\linear,1})\\
    \comp_0' = (\mscode[2], \msdata[2], \overline{\var{import}_2}, \overline{\var{export}_2}, \sigrets[2], \sigcloss[2],A_{\linear,2})\\
    \comp_0'' = (\mscode[3], \msdata[3], \overline{\var{import}_3}, \overline{\var{export}_3}, \sigrets[3], \sigcloss[3],A_{\linear,3})\\
    \mscode[3] = \mscode[1] \uplus \mscode[2] \\
    \msdata[3] = (\msdata[1] \uplus \msdata[2])[a \mapsto w \mid (a \mapsfrom s) \in (\overline{\var{import}_1} \cup \overline{\var{import}_2}), (s \mapsto w) \in \overline{\var{export}}_3] \\
    \overline{\var{export}_3} = \overline{\var{export}_1} \cup \overline{\var{export}_2}&
    \overline{\var{import}_3} = \{ a \mapsfrom s \in (\overline{\var{import}_1} \cup \overline{\var{import}_2}) \mid s \mapsto \_ \not\in \overline{\var{export}_3} \}\\
    \sigrets[3] = \sigrets[1] \uplus \sigrets[2] &
    \sigcloss[3] = \sigcloss[1] \uplus \sigcloss[2] &
    A_{\linear,3} = A_{\linear,1} \uplus A_{\linear,2}\\
    \dom(\mscode[3]) \mathrel{\#} \dom(\msdata[3]) & \sigrets[3] \mathrel{\#} \sigcloss[3]
  } {
    \comp_0'' = \comp_0 \bowtie \comp_0'
  }
  \and
  \inference{
    \comp_0'' = \comp_0 \bowtie \comp_0'
  }{
    (\comp_0'',c_{\mathrm{main},c}, c_{\mathrm{main},d}) = \comp_0 \bowtie (\comp_0',c_{\mathrm{main},c}, c_{\mathrm{main},d}) = (\comp_0,c_{\mathrm{main},c}, c_{\mathrm{main},d}) \bowtie \comp_0'
  }
  \end{mathpar}
% \begin{definition}[Plugging a program into a context]
%   When $\var{comp'}$ is a context for component $\comp$ and $\comp' \bowtie \comp \rightsquigarrow \Phi$, 
%   then we write $\plug{\comp'}{\comp}$ for the execution configuration $\Phi$.
% \end{definition}
  \caption{Components and linking of components.}
  \label{fig:target-component-and-linking}
\end{figure}

%\FloatBarrier
% \begin{itemize}
% \item present our \emph{target language} and its operational semantics (excerpts)
% \item mention roughly what components look like
% \end{itemize}
\section{Linear Stack and Return Capabilities}
\label{sec:stktokens-explained}
In this section, we introduce our calling convention \stktokens{} that ensures LSE and WBCF.
We will gradually explain each of the security measures \stktokens{} takes and motivate them with the attacks they prevent.

\begin{figure}
  \centering
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      % Stack pointer 1
      \begin{scope}
        \clip (4.6,4) rectangle (9,13);
        \capbracebot{(4.6,4)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 1}
      \end{scope}
      Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \capbrace{(5.2,9)}{(5.2,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

      \draw[red,thick,->] (4.5,10) to[out=0,in=50] node[midway,right] {} (7.5,7.3);
      \draw[red,thick,->] (7,7.3) to[out=115,in=0] node[midway,right] {} (4.5,8);
    \end{tikzpicture}
    \caption{An adversary uses a previous stack frame's stack pointer.}
    \label{fig:stack-ptr-abuse}
  \end{subfigure}
  \begin{subfigure}{0.18\linewidth}
    \phantom{testtestes}
  \end{subfigure}
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}
      \fill[red,draw=red,opacity=.4] (-.1,3.9) rectangle (4.6,9.1);
      \draw[red,thick,->] (4.5,10.5) to[out=0,in=0] node[midway,right,align=center] {return\\ to wrong\\ return ptr} (4.5,3);
    \end{tikzpicture}
    \caption{An adversary jumps to a previous stack frame's stack pointer.}
    \label{fig:ret-ptr-abuse}
  \end{subfigure}
  
  \caption{Possible ways to abuse stack and return capabilities.}
  \label{fig:stack-ret-ptr-abuse}
\end{figure}

\stktokens{} is based on a traditional single stack, shared between all components.
To explain the technique, let us first consider how we might already add extra protection to stack and return pointers on a capability machine.
First, we replace stack pointers with stack capabilities.
When a new stack frame is created, the caller provisions it with a stack capability, restricted to the appropriate range, i.e.\ it does not cover the caller's stack frame.
Return pointers, on the other hand, are replaced by a pair of sealed return capabilities, as we already explained in Section~\ref{sec:purpose-sealing}.
% KJAA: Again with the sealed pair. Again, this idea is unclear.
They form an opaque closure that the callee can only jump to, and the caller's data becomes available to the caller's return code. 

%informally explain how an adversary may try to abuse stack and return caps
While the above adds extra protection, it is not sufficient to enforce WBCF and LSE.
Untrusted callees receive a stack capability and a return pair that they are supposed to use for the call.
However, a malicious callee (which we will refer to as an adversary\footnote{See Section~\ref{sec:well-form-reas} for more details on our attacker model.}) can store the provided capabilities on the heap in order to use them later.
Figure~\ref{fig:stack-ret-ptr-abuse} illustrates two examples of this.
In both examples our component and an adversarial component have been taking turns calling each other, so the stack now contains four stack frames alternating between ours and theirs.
The figure on the left (Figure~\ref{fig:stack-ptr-abuse}) illustrates how we try to ensure LSE by restricting the stack capability to the unused part before every call to the adversary.
However, restricting the stack capability does not help when we, in the first call, give access to the part of the stack where our second stack frame will reside as nothing prevents the adversary from duplicating and storing the stack pointer.
Generally speaking, we have no reason to ever trust a stack capability received from an untrusted component as that stack capability may have been duplicated and stored for later use.
In the figure on the right (Figure~\ref{fig:ret-ptr-abuse}), we have given the adversary two pairs of sealed return capabilities, one in each of the two calls to the adversarial component.
The adversary stores the pair of sealed return capabilities from the first call in order to use it in the second call where they are not allowed.
The figure illustrates how the adversarial code uses the return pair from the first call to return from the second call and thus break WBCF.

% Informally explain how we prevent this using linear capabilities
As the examples illustrate, this naive use of standard memory and object capabilities does not provide sufficient guarantees to enforce LSE and WBCF.
The problem is essentially that the stack and return pointers that a callee receives from a caller remain in effect after their intended lifetime: either when the callee has already returned or when they have themselves invoked other code. 
Linear capabilities offer a form of revocation\footnote{Revocation in the sense that if we hand out a linear capability and later get it back, then the receiver no longer has it or a copy of it as it is non-duplicable.} that can be used to prevent this from happening.

% Stack capability linear
The linear capabilities are put to use by requiring the stack capability to be linear.
On call, the caller splits the stack capability in two: one capability for their local stack frame and another one for the unused part of the stack.
The local stack frame capability is sealed and used as the data part of the sealed return pair.
The capability for the remainder of the stack is given to the callee.
% Prevention of left attack non-aliasing of linear capabilities - token like (ensuring LSE)
Because the stack capability is linear, the caller knows that the capability for their local stack frame cannot have an alias.
This means that an adversary would need the stack capability produced by the caller in order to access their local data.
The caller gives this capability to the adversary only in a sealed form, rendering it opaque and unusable.
This is illustrated in Figure~\ref{fig:stack-ptr-abuse-prev} and prevents the issue illustrated in Figure~\ref{fig:stack-ptr-abuse}.

% Prevention of attack 2
In a traditional calling convention with a single stack, the stack serves as a call stack keeping track of the order calls were made in and thus in which order they should be returned to.
A caller pushes a stack frame to the stack on call and a callee pops a stack frame from the stack upon return.
However without any enforcement, there is nothing to prevent a callee from returning from an arbitrary call on the call stack.
This is exactly what the adversary does in Figure~\ref{fig:ret-ptr-abuse} when they skip two stack frames.
In the presence of adversarial code, we need some mechanism to enforce that the order of the call stack is kept.
One way to enforce this would be to hand out a token on call that can only be used when the caller's stack frame is on top of the call stack.
The callee would have to provide this token on return to prove that it is allowed to return to the caller, and on return the token would be taken back by the caller to prevent it from being spent multiple times.
As it turns out, the stack capability for the unused part of the stack can be used as such a token in the following way:
On return the callee has to give back the stack capability they were given on invocation.
When the caller receives a stack capability back on return, they need to check that this token is actually spendable, i.e.\ check whether their stack frame is on top of the call stack or not.
They do this by attempting to restore the stack capability from before the call by splicing the return token with the stack capability for the local stack frame which at this point has been unsealed again.
If the splice is successful, then the caller knows that the two capabilities are adjacent. On the other hand, if the splice fails, then they are alerted to the fact that their stack frame may not be the topmost.
\stktokens{} uses this approach; and as illustrated in Figure~\ref{fig:ret-ptr-abuse-prev}, it prevents the issue in Figure~\ref{fig:ret-ptr-abuse} as the adversary does not return a spendable token when they return.
\begin{figure}
  \centering
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      \sealsymb{(4.9,3)}
      \lincapbrace{(4.6,2)}{(4.6,4)}{data return\\\footnotesize cap. 1}

      % Stack pointer 1
      \sealsymb{(4.9,5.5)}
      \lincapbrace{(4.6,4)}{(4.6,7)}{adv. stack\\\footnotesize cap. 1}
      % return cap
      \sealsymb{(4.9,8)}
      \lincapbrace{(4.6,7)}{(4.6,9)}{data return\\\footnotesize cap. 2}
     %  Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \lincapbrace{(4.6,9)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

    \end{tikzpicture}
    \caption{The non-duplicable linear stack capability for the trusted code's
      stack frame and the opacity of sealed capabilities ensures LSE.}
    \label{fig:stack-ptr-abuse-prev}
  \end{subfigure}
  \begin{subfigure}{0.18\linewidth}
    \phantom{testtestes}
  \end{subfigure}
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      \lincapbrace{(4.6,2)}{(4.6,4)}{data return\\\footnotesize cap. 1}

     %  Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \lincapbrace{(4.6,9)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

      \redcross{(5,4)}
    \end{tikzpicture}
    \caption{The trusted caller fails to splice the stack capability returned by
    the adversary with the capability for the trusted caller's local stack frame.}
    \label{fig:ret-ptr-abuse-prev}
  \end{subfigure}
  \caption{Abuse of stack and return capabilities prevention.}
\end{figure}

% Non-empty trusted stack frames.
In order for a call to have a presence on the call stack, its stack frame must be non-empty.
We cannot allow empty stack frames on the call stack, because then it would be impossible to tell whether the topmost non-empty stack frame has an empty stack frame on top of it.
Non-empty stack frames come naturally in traditional C-like calling convention as they keep track of old stack pointers and old program counters on the stack, but in \stktokens{} these things are part of the return pair which means that a caller with no local data may only need an empty stack frame.
This means that a caller using \stktokens{} needs to take care that their stack frame is non-empty in order to reserve their spot in the return order.
There is also a more practical reason for a \stktokens{} caller to make sure their stack frame is non-empty: They need a bit of the stack capability in order to perform the splice that verifies the validity of the return token.

% known stack base
% + more
At this point, the caller checks that the return token is adjacent to the stack capability for the caller's local stack frame and they have the means to do so.
However, this still does not ensure that the caller's stack frame is on top of the call stack.
The issue is that stack frames may not be tightly packed leaving space between stack frames in memory.
An adversarial callee may even intentionally leave a bit of space in memory above the caller's stack frame, so that they can later return out of order by returning the bit of the return token for the bit of memory left above the caller's stack frame.
This is illustrated in Figure~\ref{fig:stk-base-abuse}: In Figure~\ref{fig:stack-base-abuse-a}, a trusted caller has called an adversarial callee.
The adversary calls the trusted code back, but first they split the return token in two and store on the heap the part for the memory adjacent to the trusted caller's call frame (Figure~\ref{fig:stack-base-abuse-b}).
The trusted caller calls the adversary back using the precautions we have described so far (Figure~\ref{fig:stack-base-abuse-c}).
At this point (Figure~\ref{fig:stack-base-abuse-b}), the adversary has access to a partial return token adjacent to the trusted caller's first stack frame which allows the adversary to return from this call breaking WBCF.

For the caller to be sure that there are no hidden stack frames above its own, they need to make sure that the return token is exactly the same as the one they passed to the callee.
In \stktokens{}, the base address of the stack capability is fixed as a compile-time constant (Note: the stack grows downwards, so the base address of the stack capability is the top-most address of the stack). 
The caller verifies the validity of the return token by checking whether the base address of a returned token corresponds to this fixed base address, which was the base address for the return token they gave to the callee.
In the scenario we just sketched, the caller would be alerted to the attempt to break WBCF when the base address check of the return token fails in Figure~\ref{fig:stack-base-abuse-d}.

% Where do we get the stack pointer from, how can we know it is linear
% The other attack.
% At this point, the caller is able to verify whether a return token is spendable which allows them to decide whether they have the topmost stack frame on a call stack.
% However, in order to have WBCF there should only be one call stack, so the caller should also be able to verify that they have the top stack frame on the call stack used by all well-behaved components.
% In case a trusted component did not start the execution on the machine, i.e.\ they were called by another component, then the trusted component has no way to be sure whether the stack capability passed to them corresponds to the one and only call stack.
% To illustrate how an adversarial component can break WBCF by using multiple different stack capabilities consider this example: An adversary calls a trusted component with a callback and some linear capability that they claim is the stack capability.
% The trusted component executes using the stack capability given to them and at some point they invoke the callback, creating return tokens and so on.
% The adversary stores the return pair and return token and calls another trusted component but with a new callback and a new linear capability that they claim is the stack capability.
% Again, this trusted component also executes using the stack capability given to them and at some point they too invoke the callback, taking all the precautions we have described so far.
% At this point, the adversary has everything they need to return from either of the two callbacks.
% Specifically, they could return from the first callback invocation before they have returned from the second, breaking WBCF.
% From a high-level perspective, the problem is that both trusted components will be able to verify that they have the top stack frame on the call stack.
% They are both correct as the adversarial component has created two call stacks, one for each of the components.
% In order to solve this problem, the well-behaved code needs to somehow agree on the call stack.
% We do this by statically deciding on a global base address for the stack which is used for the entirety of the execution.
% A caller makes sure that they are using the correct stack by checking that the base address of the stack capability they receive corresponds to the global stack base address.
% This also means that on every return, the caller will check whether the return token's base address is equal to the global stack address.

In \stktokens{}, the stack memory is only referenced by a single linear stack capability at the start of execution.
Because of this, the return token can be verified simply by checking its base address and splicing it with the caller's stack frame.
There is no need to check linearity because only linear capabilities to this memory exist.

% Return pointers/return seals
The return pointer in the \stktokens{} scheme is a pair of sealed capabilities where the code part of the pair is the old program counter, and the data part is the stack capability for the local stack frame of the caller.
Both of the capabilities in the pair are sealed with the same seal.
% One seal per return point
All call points need to be associated with a unique seal (a return seal) that is only used for the return capabilities for that particular call point.
The return seal is what associates the stack frame on the call stack with a specific call point in a program, so if we allowed return seals to be reused, it would be possible to return to a different call point than the one that gave rise to the stack frame, breaking WBCF.
For similar reasons, we cannot allow return seals to be used to seal closures.
% Don't be stupid
Return seals should never be leaked to adversarial code as this would allow them to unseal the local stack frame of a caller breaking LSE.
This goes for direct leaks (leaving a seal in a register or writing it to adversarial memory), as well as indirect leaks (leaking a capability for reading, either directly or indirectly, a return seal from memory).

% Note about them vs us, we do nothing that they couldn't do
We have sometimes phrased the description of the \stktokens{} calling scheme in terms of ``them vs us''.
This may have created the impression of an asymmetric calling convention that places a special status on trusted components allowing them to protect themselves against adversaries.
However, \stktokens{} is a modular calling scheme: no restriction is put on adversarial components that we do not expect trusted components to meet.
Specifically, we are going to assume that both trusted and adversarial components are initially syntactically well-formed (described in more detail in Section~\ref{sec:well-form-reas}) which basically just restrict adversarial components to not break machine guarantees initially (e.g.\ no aliases for linear capabilities or access to seals of other components).
This means that any component can ensure WBCF and LSE by employing \stktokens{}.

% KJAA: ^-- Assuming that there is a global stack address capability, no?
% Can I "suddenly" begin to impose \stktokens{}?

% Summary of CC
To summarise, \stktokens{} consists of the following measures:
\begin{enumerate}
\item \label{item:check-stkb} Check the base address of the stack capability before and after calls.
\item \label{item:non-empty-sf} Make sure that local stack frames are non-empty.
\item \label{item:return-data} Create token and data return capability on call: split the stack capability in two to get a stack capability for your local stack frame and a stack capability for the unused part of the stack. The former is sealed and used for the data part of the return pair.
\item \label{item:return-code} Create code return capability on call: Seal the old program counter capability.
\item Reasonable use of seals: Return seals are only used to seal old program counter capabilities, every return seal is only used for one call site, and they are not leaked.
\end{enumerate}
Item~\ref{item:check-stkb}-\ref{item:return-code} are captured by the code in Figure~\ref{fig:call-code} , except for checking stack base before calls.
We do not include this check because it only needs to happen once between two calls, so that the check after a call suffices if the stack base is not changed subsequently.

\begin{figure}
  \centering
  \begin{subfigure}{0.23\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \actadv{(0,4)}{(4.5,7)}{}

      \sealsymb{(4.9,3)}
      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
      \lincapbracebot{(4.6,4)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-a}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)}{\footnotesize Kept by adv.}
      \node[opacity=0.5,rotate=-45] at (2.25,10) {\footnotesize Sent to trusted};

      \sealsymb{(4.9,3)}
      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \lincapbrace{(4.6,4)}{(4.6,7)}{}
      
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
      \lincapbracebot{(4.6,7)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-b}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \actadv{(0,4)}{(4.5,7)}{\footnotesize Kept by adv.}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted\\ \footnotesize stack frame 2}
      \node[opacity=0.5,rotate=-45] at (2.25,11) {\footnotesize Returned to adv.};
      \sealsymb{(4.9,3)}
      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \lincapbrace{(4.6,4)}{(4.6,7)}{}

      \sealsymb{(4.9,8)}
      \lincapbrace{(4.6,7)}{(4.6,9)}{}
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
        \lincapbracebot{(4.6,9)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-c}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \actsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}

      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted\\ \footnotesize stack frame 2}
      \begin{scope}
        \clip (-.1,-.1) rectangle (4.6,13.1);
        \draw[fill=gray!50] (0,9) rectangle (4.5,13.5);
      \end{scope}

      \lincapbrace{(4.6,2)}{(4.6,7)}{}

      \sealsymb{(4.9,8)}
      \lincapbrace{(4.6,7)}{(4.6,9)}{}

      \fill[red,draw=red,opacity=.4] (-.1,6.9) rectangle (4.6,9.1);
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
        \lincapbracebot{(4.6,9)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-d}
  \end{subfigure}
  \caption{Partial return token used to return out of order.}
  \label{fig:stk-base-abuse}
\end{figure}

\begin{figure}[htb]
  \centering
{\small
\[
  \begin{array}{r >{$}p{5.1cm}<{$} r l}
\multicolumn{2}{l}{\text{// Ensure non-empty stack.}}            & \multicolumn{2}{l}{\text{// Clear tmp registers and jump.}}\\
1 :& \tmove{\rtmp{1}}{42}                                        &14: & \tmove{\rtmp{1}}{0}\\
2 :& \tstore{\rstk}{\rtmp{1}}                                    &15: & \txjmp{r_1}{r_2}\\
3 :& \tcca{\rstk}{(-1)}                                          &\multicolumn{2}{l}{\text{// The following is the return code.}}\\
\multicolumn{2}{l}{\text{// Split stack in local stack frame and unused.}}      &\multicolumn{2}{l}{\text{// Check that returned stack pointer has base $\stkb$.}}\\
4 :& \tgeta{\rtmp{1}}{\rstk}                                     &16: & \tgetb{\rtmp{1}}{\rstk}\\
5 :& \tsplit{\rstk}{\rretd}{\rstk}{\rtmp{1}}                     &17: & \tminus{\rtmp{1}}{\rtmp{1}}{\stkb}\\
\multicolumn{2}{l}{\text{// Load the call seal.}}                &18: & \tmove{\rtmp{2}}{\pcreg}\\
6 :& \tmove{\rtmp{1}}{\pcreg}                                    &19: & \tcca{\rtmp{2}}{5}\\
7 :& \tcca{\rtmp{1}}{(\offpc - 5)}                               &20: & \tjnz{\rtmp{2}}{\rtmp{1}}\\
8 :& \tload{\rtmp{1}}{\rtmp{1}}                                  &21: & \rtmp{2}{1}\\
9 :& \tcca{\rtmp{1}}{\offsigma}                                  &22: & \tjmp{\rtmp{2}}\\
\multicolumn{2}{l}{\text{// Seal the local stack frame.}}        &23: & \tfail \\
10:& \tcseal{\rretd}{\rtmp{1}}                                   &\multicolumn{2}{l}{\text{// Splice with capability for local stack frame.}}\\
\multicolumn{2}{l}{\text{// Construct code return pointer.}}     &24: & \tsplice{\rstk}{\rstk}{\rdata} \\
11:& \tmove{\rretc}{\pcreg}                                      &\multicolumn{2}{l}{\text{// Pop 42 from the stack}}\\  
12:& \tcca{\rretc}{5}                                            &25: & \tcca{\rstk}{1}\\
13:& \tcseal{\rretc}{\rtmp{1}}                                   &\multicolumn{2}{l}{\text{// Clear tmp register}}\\
      &    &26: & \tmove{\rtmp{2}}{0}\\
  \end{array}
\]
}
\caption{
  % The instructions that constitutes a call. Register $r_1$ and $r_2$ are the registers where the sealed capability pair to the callee resides.
  % Variable $\offpc$ is the offset from the first instruction of the call to the set of seals, and $\offsigma$ is the offset to the seal within the set.
  % Instructions 1-3: ensure that the stack is non-empty.
  % Instructions 4-5: split stack pointer in two (stack pointer for callee done).
  % Instructions 6-9: Load the seal designated for this call.
  % Instruction 10: Seal capability for private stack to create data return pointer.
  % Instructions 11-13: Seal capability for return point to create code return pointer.
  % Instructions 14-15: Clean up temporary register and jump.
  % Instructions 16-26: The return code.
  % Instructions 16-23: check the stack base.
  % Instruction 24: join the stack pointer.
  % Instructions 25-26: pop 42 from the stack.
  The instructions for a $\scall{\offpc,\offsigma}{r_1}{r_2}$ with $\offpc$  the offset from line 1 of the call to the set of seals it uses and $\offsigma$ the offset in the set of seals to the call seal.
  $\stkb$ is the globally agreed on stack base.
  There are some magic numbers in the code: line 1: $42$, garbage data to ensure a non-empty stack.
  Line 7: $-5$, offset from line 6 (where $\pcreg$ was copied into $\rtmp{1}$) to line 1.
  Line 12: $5$, offset to the return address.
  Line 19: $5$, offset to fail.
  Line 21: offset to address after fail.
}
  \label{fig:call-code}
\end{figure}


% \begin{itemize}
% \item informally explain how an adversary may try to abuse stack and return caps
% \item informally explain how we prevent this using linear capabilities
% \item use the tikz pictures from the PriSC presentation to explain all of this
% \end{itemize}

\section{Formulating Security with a Fully Abstract Overlay Semantics}
\label{sec:form-secur-with}
As mentioned, the \stktokens{} calling convention guarantees well-bracketed control flow (WBCF) and local state encapsulation (LSE).
However, before we can prove these properties, we need to know how to even formulate them.
Although the properties are intuitively clear and sound precise, formalizing them is actually far from obvious.

Ideally, we would like to define the properties in a way that is
\begin{enumerate}
\item {\itshape intuitive} \label{def-prop:intuitive}
\item {\itshape useful for reasoning:} we should be able to use WBCF and LSE when reasoning about correctness and security of programs using \stktokens{}. \label{def-prop:useful}
\item {\itshape reusable in secure compiler chains:} for compilers using \stktokens{}, one should be able to rely on WBCF and LSE when proving correctness and security of other compiler passes and then compose such results with ours to obtain results about the full compiler.\label{def-prop:reusable}
\item {\itshape arguably "complete"}: the formalization should arguably capture the entire meaning of WBCF and LSE and should arguably be applicable to any reasonable program. \label{def-prop:complete}
\item {\itshape potentially scalable}: although dynamic code generation and multi-threading are currently out of scope, the formalization should, at least potentially, extend to such settings.\label{def-prop:scalable}
\end{enumerate}

Previous formalisations in the literature are formulated in terms of a static control flow graph~\cite[e.g., ][]{Abadi2005Theory}.
While these are intuitively appealing (\ref{def-prop:intuitive}), it is not clear how they can be used to reason about programs (\ref{def-prop:useful}) or other compiler passes (\ref{def-prop:reusable}), they lack temporal safety guarantees (\ref{def-prop:complete}) and do not scale (\ref{def-prop:scalable}) to settings with dynamic code generation (where a static control flow graph cannot be defined).
\citet{skorstengaard_reasoning_2017} provide a logical relation that
can be used to reason about programs using their calling convention
(\ref{def-prop:useful},\ref{def-prop:reusable}), but it is not intuitive (\ref{def-prop:intuitive}), there is no argument for completeness (\ref{def-prop:complete}), and it is unclear whether it will scale to more complex features (\ref{def-prop:scalable}).

We contribute a new way to formalise the properties using a novel approach we call fully abstract overlay semantics.
The idea is to define a second operational semantics for programs in our target language.
This second semantics uses a different abstract machine and different run-time values, but it executes in lock-step with the original semantics and there is a very close correspondence between the state of both machines.

The main difference between the two semantics, is that the new one satisfies LSE and WBCF by construction: the abstract machine comes with a built-in stack, inactive stack frames are unaddressable and well-bracketed control flow is built-in to the abstract machine.
Important run-time values like return capabilities and stack pointers are represented by special syntactic tokens that interact with the abstract machine's stack, but during execution, there remains a close, structural correspondence to the actual regular capabilities that they represent.
For example, stack capabilities in the overlay semantics correspond directly to linear capabilities in the underlying semantics, and they have authority over the part of memory that the overlay views as the stack.
\begin{jversion}
The new run-time values in the overlay semantics affect the definition of the encoding function $\encType{}$.
All the new values correspond to concrete capabilities on the \trgcm{} machine which the encoding function must respect.
For instance, the encoding of a stack pointer in the overlay semantics should be the same as the encoding of a linear capability on the \trgcm{} machine.
\end{jversion}

The fact that \stktokens{} enforces LSE and WBCF is then formulated as a theorem about the function that maps components in the well-behaved overlay semantics to the underlying components in the regular semantics.
The theorem states that this function constitutes a fully abstract compiler, a well-known property from the field of secure compilation~\cite{abadi_protection_1999}.
Intuitively, the theorem states that if a trusted component interacts with (potentially malicious) components in the regular semantics, then these components have no more expressive power than components which the trusted component interacts with in the well-behaved overlay semantics.
In other words, they cannot do anything that doesn't correspond to something that a well-behaved component, respecting LSE and WBCF, can also do.
More formally, our full-abstraction result states that two trusted components are indistinguishable to arbitrary other components in the regular semantics iff they are indistinguishable to arbitrary other components in the overlay semantics.

Our formal results are complicated by the fact that they only hold on a sane initial configuration of the system and for well-behaved components that respect the basic rules of the calling convention.
For example, the system should be set up such that seals used by components for constructing return pointers are not shared with other components.
We envision distributing seals as a job for the linker, so this means our results depend on the linker to do this properly.
As another example, a seal used to construct a return pointer can be reused but only to construct return pointers for the same return point.
Different seals must be used for different return points.
Such seals should also never be passed to other components.
These requirements are easy to satisfy: components should request sufficient seals from the linker, use a different one for every place in the code where they make a call to another component, and make sure to clear them from registers before every call.
The general pattern is that $\stktokens{}$ only protects components that do not shoot themselves in the foot by violating a few basic rules.
In this section, we define a well-formedness judgement for the syntactic requirements on components as well as a reasonability condition that semantically disallows components to do certain unsafe things.
Well-formedness is a requirement for all components (trusted and untrusted), but the reasonability requirement only applies to trusted components, i.e.\ those components for which we provide LSE and WBCF guarantees.

\begin{figure}[b]
  \centering
  \[
    \arraycolsep=1.4pt
    \begin{array}{rcl}
      \src{\SealableCaps} & \defbnf& \SealableCaps \mid \src{\stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}} \mid\\
                          & &   \src{\retptrd(\basebnf,\aendbnf)} \mid \src{\retptrc(\basebnf,\aendbnf,\addrbnf)}\\
      \multicolumn{3}{c}{
      \begin{array}{lcrclcr}
        \src{\StkFrame} & \defeq & \src{\Addr \times \MemSeg} & \phantom{skipskipsip} & \src{\Stack} & \defeq & \src{ \StkFrame^*}
      \end{array}
                                                                                                                }\\
      \src{\ExecConf} & \defeq & \Mem \times \Reg \; \src{\times \; \Stack \times \MemSeg} \\
    \end{array}
  \] 
\[
  \begin{array}{rclcrcl}
    \src{\Instr} & \defbnf &  \Instr \mid \scall{\offpc,\offsigma}{r}{r}&\phantom{skipskipskip}&
    \offpc,\offsigma & \in & \nats
  \end{array}
\]
\caption{The syntax of \srccm{}.
  \srccm{} extends \trgcm{} by adding stack pointers, return pointers, and a built-in stack.
  Everything specific to the overlay semantics is written in blue.
}
  \label{fig:source-syntax}
\end{figure}

% Update: see e-mail discussion: we do not see a good way to implement this.
% Dominique: I think it would be less confusing and more in line with the overlay semantics story to not add an extra instruction in Figure~\ref{fig:source-syntax} but rather present it as just a special case of the overlay semantics for the same underlying instructions.

\subsection{Overlay Semantics}
\label{subsec:overlay-semantics}
% Describe the things added to the syntax
The overlay semantics \srccm{} for \trgcm{} views part of the memory as a built-in stack (Figure~\ref{fig:source-syntax}).
% Built-in stack
To this end, it adds a call stack and a free stack memory to the executable configurations of \trgcm{}.
The call stack is a list with all the stack frames that are currently inaccessible because they belong to previous calls.
Every stack frame contains encapsulated stack memory as well as the program point that execution is supposed to return to.
The free stack memory is the active part of the stack that has not been claimed by a call and thus can be used at this point of time.
% Stack pointer
In order to distinguish capabilities for the stack from the capabilities for the rest of the memory, \srccm{} adds stack pointers.
A stack pointer has a permission, range of authority, and current address, just like capabilities on \trgcm{}, but they are always linear.
% Return pointers
The final syntactic constructs added by \srccm{} are the code and data return pointers.
The data return pointer corresponds to some stack pointer (which in turn corresponds to a linear capability), and the code return pointer corresponds to some capability with read-execute permission.
Syntactically, the return capabilities contain just enough information to reconstruct what they correspond to on the underlying machine.
On \srccm{}, return pointers are generated by calls from the capabilities they correspond to on \trgcm{}, and they are turned back to the capabilities they correspond to upon return.
% Even though the return pointers both correspond to capabilities with read permission, neither can be used for reading. 
% Say, we allowed reads through a data return pointer, then that would correspond to reading from some stack memory that is encapsulated in a stack frame which would break LSE.

The opaque nature of the return pointers is reflected in the interpretation of the instructions common to both \trgcm{} and \srccm{} as \srccm{} does not add special interpretation for them in non-\texttt{xjmp} instructions.
Stack pointers, on the other hand, need to behave just like capabilities, so \srccm{} adds new cases for them in the semantics, e.g.\ \texttt{cca} can now also change the current address of a stack pointer as displayed in Figure~\ref{fig:source-op-sem}.
Similarly, \texttt{load} and \texttt{store} work on the free part of the stack when provided with a stack pointer.
A store attempted with a stack capability that points to an address outside the free stack results in the $\failed$ configuration because that action is inconsistent with the view the overlay semantics has on the underlying machine.
In other words, there should only be stack pointers for the stack memory.

% Back to high-level view
As discussed earlier, our formal results only provide guarantees for components that respect the calling convention.
Untrusted components are not assumed to do so.
To formalize this distinction, \srccm{} has a set of trusted addresses $\ta$.
Only instructions at these addresses can be interpreted as the \srccm{} native call and push frames to the call stack which guarantees LSE and WBCF.
The constant $\ta$ is a parameter of the \srccm{} step relation.
Similarly, \stktokens{} assumes a fixed base address of the stack memory, that is also passed around as such a parameter, for use in the native semantics of calls.

Apart from the step relation of \trgcm{}, \srccm{} has one overlay step that takes precedence over the others.
This step is shown in Figure~\ref{fig:source-op-sem}, and it is different from the others in the sense that it interprets a sequence of instructions rather than one.
The sequence of instructions have to correspond to a call, i.e.\ the
instructions in Figure~\ref{fig:call-code} ({\footnotesize  $\scall[i]{\offpc,\offsigma}{r_1}{r_2}$} corresponds to the $i$'th instruction in the figure and $\calllen$ is always $26$, i.e.\ the number of instructions).
Calls are only executed when the well-behaved component executes, so the addresses where the call resides must be in $\ta$, and the executing capability must have the authority to execute the call.

% Call/return
The interpretation of $\scall{\offpc,\offsigma}{r_1}{r_2}$ is also shown in Figure~\ref{fig:source-op-sem} and essentially does the following:
The registers $r_1$ and $r_2$ are expected to contain a code-data pair sealed with the same seal and the unsealed values are invoked by placing them in the $\pcreg$ and $\rdata$ registers, respectively.
The current active stack and the stack capability are split into the local stack frame of the caller and the rest.
$\scall{}{}{}$ also constructs a return capability $c_{\var{opc}}$ and its address $\var{opc}$, pointing after the call instructions.
The local stack frame and return address are pushed onto the stack, and the local stack capability and return capability are converted into a pair of sealed return capabilities.
The return capabilities are sealed with the seal designated for the call.

The return capabilities, $\retptrc$ and $\retptrd$ are sealed and can only be used using the \texttt{xjmp} instruction, to perform a return.
When this happens, the topmost call stack frame $(\opc,\ms_\var{local})$ is popped from the call stack.
In order for the return to succeed, the return address in the code return pointer must match $\opc$, and the range of addresses in the data return pointer must match the domain of the local stack.
If the return succeeds, the stack pointer is reconstructed, and the local stack becomes part of the active stack again.

\srccm{} supports tail calls.
A tail call is a call from a caller that is done executing, and thus doesn't need to be returned to or preserve local state.
This means that a tail call should not reserve a slot in the return order by pushing a stack frame on the call stack, i.e.\ it should not use the built-in call.
To perform a tail call, the caller simply transfers control to the callee using \texttt{xjmp}.
The tail-callee should return to the caller's caller, so the caller leaves the return pair they received for the callee to use.

It is important to observe that the operational semantics of \srccm{} natively guarantee WBCF (well-bracketed control flow) and (local stack encapsulation) for calls made by trusted components.
By inspecting the operational semantics of \srccm{}, we can see that it never allow reads or writes to inactive stack frames on the call stack.
The built-in call for trusted code pushes the local stack frame to the inactive part of the stack, together with the return address. 
Such frames can be reactivated by \texttt{xjmp}ing to a return capability pair, but only for the topmost stack frame and if the return address corresponds to the one stored in the call stack.
In other words, WBCF and LSE are natively enforced in this semantics.

\begin{figure}[htb]
  \centering
  \begin{mathpar}
    \inferrule{\src{\Phi(\pcreg) = ((\perm,\_),\baddr,\eaddr,\aaddr)} \\
               \src{\lbrack \aaddr ,\aaddr + \calllen - 1\rbrack \subseteq \ta}  \\
               \src{\lbrack\aaddr,\aaddr + \calllen-1\rbrack \subseteq [\baddr,\eaddr]} \\
               \src{\perm \in \{\rwx,\rx\}} \\
               \src{\Phi.\mem(\aaddr,\dots,\addr + \calllen-1) = \scall[0]{\offpc,\offsigma}{r_1}{r_2} \cdots \scall[\calllen-1]{\offpc,\offsigma}{r_1}{r_2}}
 }
              { \src{\Phi}  \; \src{\step[\src{\ta,\stkb}] \sem{\scall{\offpc,\offsigma}{r_1}{r_2}}(\Phi)} }
  \end{mathpar}
  \begin{tabular}{|>{$}c<{$}|p{3.7cm}|>{\raggedright\arraybackslash}p{6.6cm}|}
    \hline
    i \in \src{\Instr}                                 & $\sem{i}(\Phi)$ & Conditions\\
    \hline
    \halt                                        & $\halted$ & \\
    \hline
    \multicolumn{3}{|c|}{\dots\text{ (the operational semantics of \trgcm)}} \\
    \hline
    \store{r_1}{r_2}                             & $\srcalt{\var{updPc}} \sourcecolor\arraycolsep=0pt\array[t]{rl}(\Phi&\updReg{r_2}{w_2}\\ &\update{\ms_\stk.\aaddr}{\Phi(r_2)})\endarray$  & \srcalt{$\Phi(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $\perm \in \{\rwx,\rw\}$ and $\baddr \le \aaddr \le \eaddr$ and $w_2 = \linCons{\Phi(r_2)}$ and $\aaddr \in \dom(\ms_\stk)$}\\
    \hline
    \cca{r}{\rn}                                 &$\srcalt{\updPcAddr{\Phi\updReg{r}{w}}}$ &  \srcalt{$\Phi(\rn) = n \in \ints$ and $\Phi(r) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $w = \stkptr{\perm,\baddr,\eaddr,\aaddr+n}$} \\
    \hline
    \arraycolsep=0pt\array{c}
    \scall{\srcalt{\offpc,\offsigma}}{\src{r_1}}{\src{r_2}}
    \endarray &
        $\srcalt{\var{xjmpRes}(c_1,c_2,}$
        $\srcalt{\hspace{.25cm}\left(\arraycolsep=0pt\array[c]{rl}\Phi&\updReg{r_1,r_2}{w_1,w_2}\\
            &\updReg{\rretc}{s_c}\\
            &\updReg{\rretd}{s_d}\\
            &\updReg{\rstk}{c_\stk}\\
            &\update{\ms_\stk}{\ms_{\stk,\var{rest}}}\\
            &\update{\stk}{\stk'}\\
            \endarray\right))}$
       &
      \srcalt{
         $\begin{multlined}
           \ms_{\stk,\var{local}},c_\var{local},\ms_{\stk,\var{rest}},c_\stk =\\ \var{splitStack}(\Phi.\reg(\rstk), \Phi.\ms_\stk) \text{ and }
         \end{multlined}$
    $\opc, c_\opc =\var{setupOpc(\Phi.\reg(\pcreg))}$ and
    $\stk' = (\opc,\ms_{\stk,\var{local}}) :: \Phi.\stk$ and 
    $\sigma =\begin{multlined}[t]
      \var{getCallSeal}(\\
      \Phi.\reg(\pcreg), \Phi.\mem,\offpc,\offsigma)  \text{ and }
    \end{multlined}$
    $s_c,s_d = \var{sealReturnPair}(\sigma,c_\opc,c_\var{local})$ and
    $w_1,w_2 = \linCons{\Phi.\reg(r_1,r_2)}$ and
                        $\Phi.\reg(r_1,r_2) = \sealed{\sigma', c_1}, \sealed{\sigma', c_2}$
                        }\\
    \hline 
    \multicolumn{3}{|c|}{\dots} \\
    \hline
    \_                                           & $\failed$ & \totherwise \\
    \hline
  \end{tabular}
\begin{multline*}
  \srcxjmpres{c_1,c_2,\Phi} = \\
  \left\{ 
    \arraycolsep=1.4pt
    \begin{array}{l c >{\raggedright\arraybackslash}p{9.5cm}}
      \arraycolsep=0pt
    \begin{array}{rl}
      \Phi & \updReg{\pcreg}{c_1}\\
           & \updReg{\rdata}{c_2}
    \end{array}
    &\phantom{mak} & $\nonExec{c_2}$ \srcalt{and $c_1 \neq \retptrc(\_)$ and $c_2 \neq \retptrd(\_)$}\\
      \arraycolsep=0pt
      \array[c]{rl}
      \Phi&\updReg{\pcreg}{c_\opc}\\
          &\updReg{\rstk}{c_\stk}\\
          &\updReg{\rdata}{0}\\
          &\update{\stk}{\stk'}\\
          &\update{\ms_\stk}{\ms_\stk \uplus \ms_\var{local}}
      \endarray
           & &
               $\arraycolsep=0pt\array{l}
        \src{(\opc, \ms_\var{local}) :: \stk'= \Phi.\stk \tand} \\
      \src{c_1 = \retptrc(\baddr,\eaddr,\opc)}\\
      \src{c_2 = \retptrd(\aaddr_\stk,\eaddr_\stk) \wedge \dom(\ms_\var{local}) = [\aaddr_\stk,\eaddr_\stk]}\\
      \src{c_\stk = \var{reconstructStackPointer}(\Phi.\reg(\rstk),c_2) \tand}\\
      \src{c_\opc =  ((\rx,\normal),\baddr,\eaddr,\opc)} 
      \endarray$\\
      \failed &  & \totherwise
    \end{array} 
\right.
\end{multline*}
  \caption{An excerpt of the operational semantics of \srccm{} (some details omitted). Auxiliary definitions are found in Figure~\ref{fig:source-op-sem-aux}. }
  \label{fig:source-op-sem}
\end{figure}


\begin{figure}
    \begin{multline*}
      \src{\var{splitStack}(\stkptr{\rw,\baddr_\stk,\eaddr_\stk,\aaddr_\stk}, \ms_\stk) = \ms_{\stk,\var{local}},c_\var{local\_data},\ms_{\stk,\var{unused}},c_\stk} \mathit{\ iff\ } \\
      \left\{ 
      \begin{array}{l}
      \src{\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk }\\
      \src{\ms_{\stk,\var{local}} = \ms_\stk |_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42} }\\
      \src{\ms_{\stk,\var{unused}} = \ms_\stk|_{[\baddr_\stk,\aaddr_\stk-1]} }\\
      \src{c_\stk = \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1} }\\
      \src{c_\var{local\_data} = \retptrd(\aaddr_\stk,\eaddr_\stk) }\\
      \end{array}
      \right.
    \end{multline*}
    \begin{align*}
      \src{ \var{setupOpc(((\_,\_),\baddr,\eaddr,\aaddr))}} &\ \src{= \opc, c_\opc} \mathit{\ iff\ }
      \left\{ 
      \begin{array}{l}
      \src{\opc = \aaddr + \calllen \wedge{}}\\
      \src{c_\opc = \retptrc(\baddr,\eaddr,\opc) \wedge{}}
      \end{array}
       \right.\\
      \src{\var{getCallSeal}(c_\pcreg,\mem,\offpc,\offsigma)} &\ \src{= \sigma} \mathit{\ iff\ }
      \left\{
      \begin{array}{l} 
      \src{c_\pcreg = ((\_,\_),\baddr,\eaddr,\aaddr) \wedge \baddr \leq  \aaddr+\offpc \leq \eaddr \wedge{}} \\
      \src{\mem(\aaddr+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma_\aaddr} \wedge{} \sigma_\baddr \leq \sigma \leq \sigma_\eaddr \wedge{}}\\
      \src{\sigma = \sigma_\aaddr + \offsigma }
      \end{array}
      \right.\\
     \src{\var{sealReturnPair}(\sigma,c_\opc,c_\var{local})} &\ \src{= \sealed{\sigma,c_\opc},\sealed{\sigma,c_\var{local}}}
    \end{align*}%
  % \begin{multline*}
  %   \src{\var{callConditions}(r_1,r_2,\offpc,\offsigma,(\mem,\reg,\stk,\ms_\stk)) = (\mem,\reg',\stk',\ms_{\stk,\var{rest}})}\mathit{\ iff}\\
  %     \quad\quad\left\{ 
  %       \begin{array}{l}
  %         \src{\var{sealedPairArgument}(\reg,r_1,r_2,c_1,c_2)}\\
  %     \src{\ms_{\stk,\var{local}},\ms_{\stk,\var{rest}},c_\stk,c_\var{local\_data} = \var{splitStack}(\reg, \ms_\stk) \wedge{}}\\
  %     \src{\opc, c_\opc =\var{setupOpc(\reg)} \wedge{}}\\
  %     \src{\stk' = (\opc,\ms_{\stk,\var{local}}) :: \stk \wedge{}}\\
  %     \src{\sigma = \var{getCallSeal}(\reg,\mem,\offpc,\offsigma) \wedge{}}\\
  %     \src{s_c,s_d = \var{sealReturnPair}(\sigma,c_\var{local\_data},c_\opc) \wedge{}}\\
  %     \src{w_1,w_2 = \linCons{\reg(r_1),\reg(r_2)} \wedge{}}\\ 
  %     \src{\reg' =\reg\updReg{r_1,r_2}{w_1,w_2}\updReg{\rretc,\rretd}{s_c,s_d}\updReg{\rstk,\rtmp{1}}{c_\stk,0}}
  %     \end{array}\right.
  % \end{multline*}
  \begin{multline*}
    \src{\var{reconstructStackPointer}(\stkptr{\rw, \stkb, \aaddr_\stk-1,\_},\retptrd(\aaddr_\stk,\eaddr_\stk)) =}\\ \src{\stkptr{\rw,\stkb,\eaddr_\stk,\aaddr_\stk}} \mathit{\ iff\ }
        \src{\stkb \leq \addr_\stk }
   \end{multline*}

  \caption{Auxiliary definitions used in the operational semantics of \srccm{}.}
  \label{fig:source-op-sem-aux}
\end{figure}
% \begin{figure}
% % \[
% %     \src{\stkptr{\rw,\stkb,\eaddr_\stk,\aaddr_\stk} = \var{tokenToStkPtr}(\retptrd(\aaddr_\stk,\eaddr_\stk)}
% % \]
% % \[
% %     \src{\stk', \ms_\var{local\_stk} = \var{popCallStackFrame} (\stk,c_1,c_2)}
% %     \mathit{\ iff\ }
% %       \left\{ \array{l}
% %         \src{\stk = (\opc, \ms_\var{local\_stk}) :: \stk' \wedge{}} \\
% %         \src{c_1 = \retptrc(\_,\_,\opc) \wedge{}} \\
% %         \src{c_2 = \retptrd(\aaddr_\stk,\eaddr_\stk)\wedge{}} \\
% %         \src{\dom(\ms_\var{local\_stk}) \subseteq [\aaddr_\stk,\eaddr_\stk]}
% %         \endarray
% %      \right.
% % \]
% % \[
% %   \src{\var{retPtrForMatchLocalStack(\retptrd(\aaddr_\stk,\eaddr_\stk),\ms_\var{local})}} \mathit{\ iff\ } \src{\dom(\ms_\var{local} \subseteq [\aaddr_\stk,\eaddr_\stk])}
% % \]

% % \begin{multline*}
% %     \src{(\mem,\reg',\stk',\ms_\stk') = \var{returnCondition}(c_1,c_2,(\mem,\reg,\stk,\ms_\stk))}\mathit{\ iff\ }\\
% %       \quad\quad\left\{ 
% %       \begin{array}{l}
% %       \src{\stk', \ms_\var{local\_stk} = \var{popCallStackFrame}(\stk,c_1,c_2)}\\
% %       \src{c_\stk = \var{reconstructStackPointer}(\reg,c_2)}\\
% %       \src{c_\opc =  \var{tokenToPc}(c_1)} \\
% %       \src{\ms_\stk' = \ms_\stk \uplus \ms_\var{local\_stk}} \\
% %       \src{\reg' =\reg\updReg{\pcreg,\rstk}{c_\opc,c_\stk}\updReg{\rdata,\rtmp{1},\rtmp{2}}{0,0,0}}
% %       \end{array}\right.
% %   \end{multline*}

%   \caption{The return condition in the operational semantics of \srccm{}.}
%   \label{fig:source-op-sem-return}
% \end{figure}
\subsection{Well-Formed Components}
\label{sec:well-form-reas}
% Well-formed components
% \begin{figure}[htb]
%   \centering
%   \begin{mathpar}
%   \inference{
%     \dom(\mscode) = [\baddr,\eaddr]&
%     [\baddr-1,\eaddr+1] \mathrel{\#} \dom(\msdata)\\
%     \mspad = [\baddr-1\mapsto 0] \uplus [\eaddr+1 \mapsto 0]\\
%     \sigrets,\sigcloss \vdash_{\mathrm{comp-code}} \mscode \\
%     \exists A_\mathrm{own} : \dom(\msdata) \rightarrow \powerset{\dom(\msdata)} & \dom(\msdata) = A_{\mathrm{non-linear}} \uplus A_\linear \\
%     A_\linear = \biguplus_{a \in \dom(\msdata)} A_{\mathrm{own}}(a) \\
%     \forall a \in \dom(\msdata)\ldotp \dom(\mscode),A_{\mathrm{own}}(a),A_{\mathrm{non-linear}},\sigrets,\sigcloss \vdash_{\mathrm{comp-value}} \msdata(a)\\
%     \overline{\var{export}} = \overline{s_{\mathrm{export}} \mapsto w_{\mathrm{export}}} & \overline{\var{import}} = \overline{a_{\mathrm{import}} \mapsfrom s_{\mathrm{import}}}& \{\overline{a_{\mathrm{import}}}\} \subseteq \dom(\msdata)\\
%     \overline{\dom(\mscode), A_{\mathrm{non-linear}}, \sigrets,\sigcloss \vdash_{\mathrm{comp-export}} w_{\mathrm{export}}}\\
%     \overline{s_{\mathrm{import}}} \mathrel{\#} \overline{s_{\mathrm{export}}} & (\dom(\mscode) \subseteq \ta) \vee (\dom(\mscode) \mathrel{\#} \ta \wedge \sigrets = \emptyset)&
%     \dom(\msdata) \mathrel{\#} \ta
%   }{
%     \vdash (\mscode\uplus \mspad,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)
%   }
%   \and
%   \inference{
%     \comp_0 = (\mscode,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)\\
%     \vdash \comp_0 & (\_ \mapsto c_{\mathrm{main},c}), (\_ \mapsto c_{\mathrm{main},d}) \in \overline{\var{export}}
%   }{
%     \vdash (\comp_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})
%   }
% \end{mathpar}
%   \caption{Exceprt of well-formedness judgement}
%   \label{fig:well-formedness}
% \end{figure}
% Well-formedness highlights:
% Main exported
% Code memory:
% - Only instructions and seals
% - calls associated with return seals unique return seal
% - only uses seals specified for components
% - (No linear access)
% Data memory:
% - Data
% - Capabilities fora data memory (linearity respected)
% - Sealed caps sealed with clos seal
% Exports
% - Any Word valid in data memory or
% - Sealed capability for code (sealed with clos seal)
% Imports
% - Address must be in data memory
\begin{jversion}
  The components introduced in Section~\ref{subsec:components-linking} are pretty much unconstrained.
  For instance, a component can have multiple linear capabilities for the same piece of memory, and there are no restrictions on seals.
  In a real system, the operating system and linker  % ???
  would make sure everything is setup correctly.
  For instance, they would not allocate multiple linear capabilities for the same memory, and they would ensure sane seal allocation.

  The component notion is used for both trusted and adversarial components.
  We expect the linker to link the two programs together making sure that all the system invariants are respected.
  We expect trusted components to be the product of a known compiler that uses \stktokens{} which means that the code must have a certain shape.
  The proper linker behaviour and the syntactic expectations we have of trusted component are captured in a syntactic well-formedness judgement which we explain in this section.

  The well-formedness judgement imposes a quite rigid structure on well-formed components: a component's code memory may contain only data and sets of seals.
  The data memory may contain only data, memory capabilities to the component's data memory (respecting linearity) or sealed memory capabilities (to the component's data memory, sealed with closure seals).
  This makes a clear separation between code and data memory as neither can contain capabilities for the other.
  The separation of the two kinds of memory means that data structures in data memory can be shared without risking unintentionally leaking a return seals that were indirectly accessible through the data structure.
  Informally, a well-formed component respects Write-XOR-Execute which means that all capabilities for code memory at most has read-execute permission and all capabilities for data memory at most has read-write permission.
  A component's exports should be sealed code or data capabilities, sealed with a closure seal.

  As discussed before, we only provide guarantees (LSE and WBCF) for components respecting certain semantic rules (reasonable use of seals).
  Components that do not satisfy these requirements are still allowed in \srccm{}, but (as we will see below) function calls in such components will not behave according to the special \srccm{} semantics that guarantees LSE and WBCF.
  To distinguish trusted components (which satisfy reasonability requirements) from adversarial components (which don't), we make use of a set of trusted addresses $\ta$.
  Any component's code memory must fall entirely within or outside of $\ta$, so every component is either trusted or adversarial.
  Some well-formedness requirements are specific for adversarial and trusted components.
  Well-formed adversarial components cannot have return seals.
  On the other hand, well-formed trusted components can have return seals, but must make return seals available to all its calls in a way that is consistent with \stktokens{}.
  This means that each return seal is only used for one call.
\end{jversion}

% We first highlight the main points of the $\wdjud[\ta]{\comp}$ judgement.
% For components with a main pair, the main pair must come from the exports and the remainder of the component must be well-formed.
% As a reminder, a base component looks like this: $(\mscode,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)$.
% The return seals $\sigrets$ are the seals supposed to be usedto seal return pointers and the closure seals $\sigcloss$ all the other seals in a component.
% If a component is adversarial, i.e.\ the domain of the code memory $\mscode$ is disjoint from the set of trusted addresses $\ta$, then there should be no return seals.
% The code memory may contain sets of seals but only for the seals in $\sigrets$ and $\sigcloss$.
% Other than that, code memory only contains instructions in the form of integers.
% When a sequence of instructions in the code memory corresponds to a call (Figure~\ref{fig:call-code}), the call must have access to the return seal it specifies.
% The return seal also needs to be unique to that call; that is, no other call can specify the same seal as its return seal.
% The data memory $\msdata$ may contain data, capabilities, and sealed capabilities.
% The capabilities in the data memory can only have authority over the data memory itself.
% This allows components to have initial data structures.
% In order to respect Write-XOR-Execute, the capabilities in data memory cannot have execute permission.
% The capabilities also need to respect linearity which means that linear capabilities cannot be aliased by any other capability, and they must be for a range of the predetermined linear addresses $A_\linear$.
% The sealed capabilities must be sealed with a closure seal, and the sealable can be anything that is allowed to reside in data memory.
% The exports $\overline{\var{export}}$ can be anything non-linear allowed to reside in data memory or a sealed capability for the code memory sealed with one of the closure seals.

\begin{figure}
\begin{mathpar}
  \inferrule*[Right=Base]{
    \dom(\mscode) = [\baddr,\eaddr]\\
    [\baddr-1,\eaddr+1] \mathrel{\#} \dom(\msdata)\\
    \mspad = [\baddr-1\mapsto 0] \uplus [\eaddr+1 \mapsto 0]\\
    \exists A_\mathrm{own} : \dom(\msdata) \rightarrow \powerset{\dom(\msdata)}\\
    \dom(\msdata) = A_{\mathrm{non-linear}} \uplus A_\linear \\
    A_\linear = \biguplus_{a \in \dom(\msdata)} A_{\mathrm{own}}(a) \\
    \overline{\var{export}} = \overline{s_{\mathrm{export}} \mapsto w_{\mathrm{export}}} \\
    \overline{\var{import}} = \overline{a_{\mathrm{import}} \mapsfrom s_{\mathrm{import}}} \\
    \{\overline{a_{\mathrm{import}}}\} \subseteq \dom(\msdata)\\
    \overline{s_{\mathrm{import}}} \mathrel{\#} \overline{s_{\mathrm{export}}} \\
    (\emptyset \neq \dom(\mscode) \subseteq \ta) \vee (\dom(\mscode) \mathrel{\#} \ta \wedge \sigrets = \emptyset) \\
    \dom(\msdata) \mathrel{\#} \ta \\
    \sigrets,\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode \\
    \forall a \in \dom(\msdata)\ldotp \dom(\mscode),A_{\mathrm{own}}(a),A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} \msdata(a)\\
    \overline{\dom(\mscode), A_{\mathrm{non-linear}}, \sigrets,\sigcloss \vdash_{\mathrm{comp-export}} w_{\mathrm{export}}}
  }{
    \ta \vdash (\mscode\uplus \mspad,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)
  }
  \and
  \inferrule*[Right=Main]{
    \var{comp}_0 = (\mscode,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)\\
    \ta \vdash \var{comp}_0 \\
    (\_ \mapsto c_{\mathrm{main},c}), (\_ \mapsto c_{\mathrm{main},d}) \in \overline{\var{export}}
  }{
    \ta \vdash (\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})
  }
\end{mathpar}
\caption{Well-formedness judgement.}
\label{fig:well-formed}
\end{figure}

\begin{jversion}
These requirements are formally expressed by the judgement $\wdjud[\ta]{\comp}$ specifies, i.e.\ it defines when components satisfy the initial syntactic requirements necessary to be able to rely on unique linear capabilities, component unique seals, etc.
The judgement is defined in \figurename~\ref{fig:well-formed} with auxiliary judgements in \figurename~\ref{fig:well-formed-aux}.

The $\wdjud[\ta]{\comp}$ judgement has two rules: \textsc{Main} and \textsc{Base}.
The \textsc{Main} rule requires the component to have an entry point in terms of a main pair from the exports.
Further, the base component should satisfy the well-formedness judgement.
The \textsc{Base} judgement ensures sure that the component has a bit of structure.
Roughly speaking, the \textsc{Base} rule requires the following:
\begin{itemize}
\item \textit{Code and data memory are disjoint.}
\item \textit{Code memory is padded with zeros ($\mspad$).}
  This prevents code memories from being spliced together.
  If the capabilities for two code memories can be spliced together, then the execution of one code memory can continue into the other creating an unintended control-flow.
  Further, the possible control-flows of a component suddenly depends on the memory locations of all the components\footnote{Alternatively to this syntactic condition on components, we could require trusted components to never splice executable capabilities of unknown origin.}.
\item \textit{All memory can either be addressed by any number of non-linear capabilities or at most one linear capability.}
  The data address space is split into $A_\var{non-linear}$ and $A_\var{linear}$ that can be addressed by non-linear capabilities and linear capabilities, respectively.
  The judgement ensure uniqueness of linear capabilities by letting each address of the data memory take sole ownership of addresses in $A_\var{linear}$.
\item \textit{All import addresses are part of the data memory.} 
\item \textit{Import and export symbols are disjoint.}
\item \textit{One of the following two are true}
  \begin{itemize}
  \item \textit{The code address space is disjoint from the trusted address space $\ta$ and there are no return seals.} In this case, the component contains untrusted code. We are interested in WBCF and LSE from the perspective of the trusted code, so we do not let untrusted memory have return seals\footnote{Untrusted code still has access to seals that could be used to protect calls.}.
  \item \textit{The code address space is part of the trusted address space $\ta$.} In this case, the component contains trusted code. We do not impose requirements on the return seals here (the auxiliary judgements will impose restrictions on them), so the trusted component can have the return seals necessary for its calls.
  \end{itemize}
\item \emph{The data address space is disjoint from the trusted address space $\ta$.} Data memory is not executable, so the trusted addresses never include the data memory addresses.
\item \textit{The code memory satisfies the component-code judgement (\figurename~\ref{fig:well-formed-code}).}
\item \textit{Each word in the data memory satisfies the component-word judgement (\figurename~\ref{fig:well-formed-word}).} This must be with respect to the linear addresses assigned to this address.
\item \textit{All the exports satisfy the components-export judgement (\figurename~\ref{fig:well-formed-export}).}
\end{itemize}

\begin{figure}
  \begin{subfigure}[h]{1.0\linewidth}
    \begin{mathpar}
  \inferrule*[Right=C-Seals]{
    \mscode(a) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma_\baddr} \\ [\sigma_\baddr,\sigma_\eaddr] = (\sigrets \cup \sigcloss)
  }{
    \sigrets,\sigrets[\mathrm{owned}],\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode,a
  }
  \and
  \inferrule*[Right=C-Instr]{
    \mscode(a) \in \ints\\
{    \begin{multlined}
      ([a \cdots a + \calllen-1] \subseteq \ta \wedge \mscode([a \cdots a + \calllen-1]) = \scall[0..\calllen-1]{\offpc,\offsigma}{r_1}{r_2})
      \Rightarrow\\ (\mscode(a+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma_\baddr} \wedge \sigma_\baddr+\offsigma \in \sigrets[\mathrm{owned}])
    \end{multlined}
}  }{
    \sigrets,\sigrets[\mathrm{owned}],\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode,a
  }
  \and
  \inferrule*[Right=C-Mem]{
    \text{$\mscode$ has no hidden calls}\\
    \sigrets \mathrel{\#} \sigcloss \\
    \exists d_\sigma : \dom(\mscode) \rightarrow \powerset{\Seal} \ldotp
    \sigrets = \biguplus_{a \in \dom(\mscode)} d_\sigma(a) \tand\\
    \forall a \in \dom(\mscode) \ldotp 
    \sigrets,d_\sigma(a),\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode,a\\
    \exists a \ldotp \mscode(a) = \seal{\sigma_\baddr,\sigma_\eaddr,\_} \wedge [\sigma_\baddr,\sigma_\eaddr] \neq \emptyset
  }{
    \sigrets,\sigcloss,\ta\vdash_{\mathrm{comp-code}} \mscode
  }
    \end{mathpar}
    \caption{Code well-formedness.}
    \label{fig:well-formed-code}
  \end{subfigure}
  
  \begin{subfigure}[h]{1.0\linewidth}
    \begin{mathpar}
      \inferrule*[Right=W-Data]{
        z \in \ints
  }{
    A_{\mathrm{code}},A_{\mathrm{own}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} z
  }
  \and
  \inferrule*[Right=W-Capability]{
    \permbnf \sqsubseteq \rw\\
    \lin = \linear \Rightarrow \emptyset \subset [\baddr,\eaddr] \subseteq A_{\mathrm{own}} \\\\
    \lin = \normal \Rightarrow [\baddr,\eaddr] \subseteq A_{\mathrm{non-linear}}
  }{
    A_{\mathrm{code}},A_{\mathrm{own}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} ((\perm,\lin),\baddr,\eaddr,\aaddr)
  }
  \and
  \inferrule*[Right=W-Sealed-Capability]{
    A_{\mathrm{code}},A_{\mathrm{own}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} \vsc \\
    \sigma \in \sigcloss
  }{
    A_{\mathrm{code}},A_{\mathrm{own}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} \sealed{\sigma,\vsc}
  }
    \end{mathpar}
    \caption{Word well-formedness.}
    \label{fig:well-formed-word}
  \end{subfigure}
  
  \begin{subfigure}[h]{1.0\linewidth}
    \begin{mathpar}
  \inferrule*[Right=E-Sealed-Code]{
    [\baddr,\eaddr] \subseteq A_{\mathrm{code}} \\
    \sigma \in \sigcloss
  }{
    A_{\mathrm{code}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-export}} s \mapsto \sealed{\sigma,((\rx,\normal),\baddr,\eaddr,\aaddr)}
  }
  \and
  \inferrule*[Right=E-Word]{
    A_{\mathrm{code}},\emptyset,A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-word}} w
  }{
    A_{\mathrm{code}},A_{\mathrm{non-linear}},\sigcloss \vdash_{\mathrm{comp-export}} s \mapsto w
  }
    \end{mathpar}
    \caption{Export well-formedness}
    \label{fig:well-formed-export}
  \end{subfigure}
  \caption{Well-formedness judgement for code, words, and export. $\calllen$ it the length of the call code.}
  \label{fig:well-formed-aux}
\end{figure}
\figurename~\ref{fig:well-formed-word} defines the judgement $\vdash_{\mathrm{comp-word}}$ which specifies the words that are well-formed in a component's data memory.
The judgement is defined by three rules: \textsc{W-Data}, \textsc{W-Capability}, and \textsc{W-Sealed-Capability}.
The \textsc{W-Data} rule says all data, i.e.\ integers, are well-formed words.
The \textsc{W-Capability} rule specifies that all well-formed capabilities in data memory must at most have read and write permission.
Further, if the capability is linear, then the range of authority must be within the linear address space owned by this address.
Finally, if it is non-linear, then it must be in the non-linear address space.
The \textsc{W-Sealed-Capability} specifies that well-formed sealed capabilities in data memory are sealed with a closure seal and whatever is sealed is itself a well-formed word.
Because of the last requirement, the data memory cannot initially contain sealed code capabilities.
However, a component is free to place sealed data capabilities in memory during execution.

\figurename~\ref{fig:well-formed-export} defines the well-formed exports $\vdash_{\mathrm{comp-export}}$.
\textsc{E-Word} says that any well-formed word for data memory is well-formed as an export.
In particular, this means that sealed capabilities for the data memory are acceptable exports which allows components to export the data part of a sealed capability pair.
The \textsc{E-Sealed-Code} rule allows the code part of a sealed capability pair to be exported.
In particular, it allows a capability with read-execute permission and its range of authority within the component's code address space to be exported when it has been sealed with a closure seal.
Together, these two rules allow components to export closures.

\figurename~\ref{fig:well-formed-code} defines the well-formed code memories $\vdash_{\mathrm{comp-code}}$.
The well-formed code memories are defined by two judgements.
One judgement considers the entire memory $\sigrets,\sigcloss,\ta\vdash_{\mathrm{comp-code}} \mscode$ while the other considers the contents of each code memory address $\sigrets,\sigrets[\mathrm{owned}],\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode,a$.
Unlike data memory and exports, we cannot say whether code memory is well-formed by considering each word in isolation.
The well-formedness of code memory depends on whether seals for calls are located in the place we expect them to be located.
The $\sigrets,\sigrets[\mathrm{owned}],\sigcloss,\ta \vdash_{\mathrm{comp-code}} \mscode,a$ judgement has two rules.
The \textsc{C-Seal} judgement requires address $a$ in $\mscode$ to contain a set of seals that is a subset of the closure seals and the return seals.
\textsc{C-Instr} requires address $a$ to contain an integer, which may be interpreted as instruction.
If address $a$ is the first address of a series of instructions that may be interpreted as a call, and all the addresses are within the trusted address space, then there must be a set of seals available at the address the call in question expects it and that set of seals must contain the return seal that corresponds to the return seal of this call.
The return seal in question must be in the $\sigrets[\mathrm{owned}]$ to ensure that no other call uses it.
In order to ensure that return seals are at most used by one call, the $\sigrets,\sigcloss,\ta\vdash_{\mathrm{comp-code}} \mscode$ judgement takes all the available return seals and partitions them over code addresses. 
This means that no other call can use the same seal.
Further, return seals cannot be used to seal non-return capabilities, so the \textsc{C-Mem} judgement requires the set of return seals to be disjoint from the set of closure seals.
To limit the amount of corner cases we have to consider, we require the code memory to have no \textit{hidden calls}.
\lau{Do we actually use the hidden calls in the proofs? I vaguely recall this was added to make sure that splicing would not create a call. However, we also have the padding which, at least in part, takes care of this.}
\begin{definition}[No hidden calls]
  \label{def:no-hidden-calls}
  We say that a memory segment $\mscode$ has no hidden calls iff
  \[
    \begin{array}{l}
      \forall \aaddr \in \dom(\mscode) \ldotp \\
      \quad \forall i \in [0,\calllen - 1] \\
      \qquad \mscode(a + i) = \scall[i]{\offpc,\offsigma}{r_1}{r_2} \Rightarrow \\
      \qquad \quad (\dom(\mscode) \supseteq [\aaddr-i,\aaddr + \calllen - i - 1] \wedge\\
      \qquad \qquad \mscode([\aaddr-i,\aaddr + \calllen - i -1]) =
      \scall[0..\calllen-1]{\offpc,\offsigma}{r_1}{r_2}) \vee\\
      \qquad \quad \exists j \in [\aaddr-i,\aaddr + \calllen - i -1] \cap \dom(\mscode) \ldotp \mscode(j) \neq  \scall[j-\aaddr-i]{\offpc,\offsigma}{r_1}{r_2}
    \end{array}
  \]
\end{definition}
Definition~\ref{def:no-hidden-calls} says that if code memory contains an instruction that may be part of a call, then either it is a part of a call or there is some other instruction that witnesses the fact that it is not part of a call.
Finally, the \textsc{C-Mem} judgement requires that the code at least have one non-empty set of seals available.

\end{jversion}
\subsection{Reasonable Components}
\label{sec:reasonable-components}
% Reasonability
The static guarantees given by $\wdjud[\ta]{\comp}$ makes sure that components initially don't undermine the security measures needed for \stktokens{}, but it does not prevent a component from doing something silly during execution that undermines \stktokens{}.
In order for \stktokens{} to provide guarantees for a component, we expect it to not shoot itself in the foot and perform certain necessary checks not captured by the call code (Figure~\ref{fig:call-code}).
More precisely, we expect four things of a reasonable component:
\begin{enumerate}[label=(\arabic*)]
\item It checks the stack base address before performing a call.
As explained in Section~\ref{sec:stktokens-explained}, we do not include this check in the call code as it often would be redundant.
\item It uses the return seals only for calls and the closure seals in an appropriate way which means that they should only be used to seal executable capabilities for code that behaves reasonably or non-executable things that do not undermine the security mechanisms \stktokens{} relies on.
\item It does not leak return and closure seals or means to retrieve them.
This means that sets of seals with return or closure seals cannot be left in registers when transferring control to another module.
There are also indirect ways to leak seals such as leaking a capability for code memory or leaking a capability for code memory sealed with an unknown seal.
\item It does not store return and closure seals or means to get them.
By disallowing this, we make sure that data memory always can be safely shared as it does not contain seals or means to get them to begin with.
\end{enumerate}
\begin{jversion}
  We capture these properties in 4 definitions.
  Definition~\ref{def:reasonable-word} defines the reasonable words which means that they cannot be used to leak seals directly or indirectly.
  Definition~\ref{def:reasonable-pc} defines the reasonable pc's which means that if it is plugged into a configuration with a register file filled with reasonable words, then  the configuration behaves reasonably.
  Definition~\ref{def:reasonable-conf} defines the reasonable configurations which captures the four informal behavioural properties.
  Finally, definition~\ref{def:reasonable-component} lifts the notion of reasonability to components.

  \subsubsection{Reasonable words}
  To provide any guarantees, \stktokens{} rely on the program to no leak return seals in any way.
  But what does it mean to ``leak'' a return seal?
  It means that sets of seals that contain return seals as well as any means to obtain such sets cannot be leaked.
  The following definition makes this more precise.
\begin{definition}[Reasonable word]
  \label{def:reasonable-word}
  Take a set of trusted addresses $\ta$ and sets of return and closure seals $\gsigrets$ and $\sigcloss$.
We define that a word $w$ is reasonable up to $n$ steps in memory $\ms$ and
free stack $\ms_\stk$ if $n=0$
or the following implications hold.
  \begin{itemize}
  \item If $w = \seal{\sigma_\baddr,\sigma_\eaddr,\_}$, then
    $[\sigma_\baddr,\sigma_\eaddr] \mathrel{\#} (\gsigrets \cup \gsigcloss)$
  \item If $w = ((\perm,\_),\baddr,\eaddr,\_)$, then $[\baddr,\eaddr] \mathrel{\#} \ta$
  \item If $w = \sealed{\sigma,\vsc}$ and $\sigma \not\in (\gsigrets\cup
    \gsigcloss)$ then $\vsc$ is reasonable up to $n - 1$ steps.
  \item If $w = ((\perm,\_),\baddr,\eaddr,\_)$ and $\perm \in \readAllowed{}$
    and $n > 0$, then $\ms(\aaddr)$ is reasonable up to $n - 1$ steps for all
    $\aaddr \in ([\baddr,\eaddr] \setminus \ta)$
  \item If $w = \stkptr{\perm,\baddr,\eaddr,\_}$ and $\perm \in \readAllowed{}$
    and $n > 0$, then $\ms_\stk(\aaddr)$ is reasonable up to $n - 1$ steps for
    all $\aaddr \in [\baddr,\eaddr]$
  \end{itemize}
\end{definition}
According to the definition, sets of seals that contain return or closure seals are not reasonable.
\stktokens{} rely on return seals to be unique in order to work, but it does not rely on closure seals.
However, it defeats the purpose of the closure seals if they are leaked to malicious code as it allows the malicious code to fabricate data capabilities for the code capabilities or code capabilities for the data capabilities which effectually allows malicious code to unseal the data capability.
Further, it makes reasoning about leakage of return seals difficult because the closures have to be well-behaved no matter what data they are executed with.

Whether a capability is reasonable depends on what it gives access to.
This is why the word reasonability is defined relative to the memory and stack.
For instance, if a read capability gives access to a piece of memory that contains a set of seals with a return seal, then it would not be reasonable.
This is why stack pointers and memory capabilities with read permission must only give access to memory with reasonable words.
The definition is cyclic, but the step-index ensures that it is well-founded.

\subsubsection{Reasonable pc and configuration}
In order to define desired behaviour, we need to specify what may happen on a machine during execution.
An execution steps between executable configurations, so we need to define when a configuration is reasonable.
While the step relation is defined over configurations, it is the pc that decides what instruction is executed.
Therefore, it only seems natural to also define when a pc is reasonable.
Definition~\ref{def:reasonable-pc} roughly says that a pc is reasonable when you can plug it into a configuration where all the words in the register file are reasonable and the result is a reasonable configuration.
  \begin{definition}[Reasonable pc]
    \label{def:reasonable-pc}
    We say that an executable capability $c =
    ((\perm,\normal),\baddr,\eaddr,\aaddr)$ behaves reasonably up to $n$ steps
    if for any $\Phi$ such that
    \begin{itemize}
    \item $\Phi.\reg(\pcreg) = c$
    \item $\Phi.\reg(r)$ is reasonable up to $n$ steps in memory $\Phi.\mem$ and
      free stack $\Phi.\ms_\stk$ for all $r \neq \pcreg$
    \item $\Phi.\mem$, $\Phi.\ms_\stk$ and $\Phi.\stk$ are all disjoint
    \end{itemize}
    We have that $\Phi$ is reasonable up to $n$ steps.
  \end{definition}
  With Definition~\ref{def:reasonable-word} and \ref{def:reasonable-pc} in place, we are all set to define when a configuration is reasonable.
  \begin{definition}[Reasonable configuration]
    \label{def:reasonable-conf}
    We say that an execution configuration $\Phi$ is reasonable up to $n$ steps with $(\ta,\stkb,\gsigrets,\gsigcloss)$ 
    iff for $n' \leq n$:
    \begin{enumerate}
    \item \label{item:guarantee-stk-base} \emph{Guarantee stack base address before call...} \\
      If $\Phi$ points to $\src{\scall{\offpc,\offsigma}{r_1}{r_2}}$ in $\ta$
      for some $\src{r_1}$ and $\src{r_2}$,
      then all of the following hold:
      \begin{itemize}
      \item $\src{\Phi}(\src{r_\stk}) =
        \src{\stkptr{\_,\stkb,\_,\_}}$
      \item $r_1 \neq \rtmp{1}$
      \item $n' = 0$ or $\Phi(\pcreg) + \calllen$ behaves reasonably up to $n'-1$ steps (Definition~\ref{def:reasonable-pc})
      \end{itemize}
    \item \label{item:return-seal-usage} \emph{Use return seals only for calls, use closure seals appropriately...} \\
      If $\src{\Phi}$ points to $\src{\tcseal{r_1}{r_2}}$ in $\ta$ and $\Phi(r_2) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$,
      then one of the following holds:
      \begin{itemize}
      \item $\src{\Phi}$ is inside $\src{\scall{\offpc,\offsigma}{r_1'}{r_2'}}$ and $\sigma \in \gsigrets$
      \item $\sigma \in \gsigcloss$ and one of the following holds:
        \begin{itemize}
        \item $\exec{\Phi(r_1)}$ and $n' = 0$ or $\Phi(r_1)$ behaves reasonably up to $n' - 1$ steps (Definition~\ref{def:reasonable-pc}).
        \item $\nonExec{\Phi(r_1)}$ and $n' = 0$ or $\Phi(r_1)$ is reasonable up to $n' - 1$ steps in memory $\Phi.\ms$ and free stack $\Phi.\ms_\stk$ (Definition~\ref{def:reasonable-word}).
        \end{itemize}
      \end{itemize}
    \item \label{item:dont-store-private}\emph{Don't store private stuff...}\\
      If $\src{\Phi}$ points to $\src{\tstore{r_1}{r_2}}$ in $\ta$,
      then $n' = 0$ or $\Phi.\reg(r_2)$ is reasonable in memory $\Phi.\mem$ up to $n' -1$ steps.
    \item \label{item:dont-leak-private}\emph{Don't leak private stuff...}\\
      If $\Phi \step[\ta,\stkb] \Phi'$, then one of the following holds:
      \begin{itemize}
      \item All of the following hold:
        \begin{itemize}
        \item $\Phi'.\reg(\pcreg) =
          ((\perm,\lin),\baddr,\eaddr,\aaddr')$ and $\Phi.\reg(\pcreg) =
          ((\perm,\lin),\baddr,\eaddr,\aaddr)$
        \item $\Phi$ does not point to $\src{\txjmp{r_1}{r_2}}$ for some $\src{r_1}$ and $\src{r_2}$
        \item $\Phi$ does not point to $\src{\scall{\offpc,\offsigma}{r_1}{r_2}}$ for some $\src{r_1}$ and $\src{r_2}$, $\offpc$, $\offsigma$
        \item $n' = 0$ or $\Phi'$ is reasonable up to $n'-1$ steps
        \end{itemize}
        % \dominique{the following seems unnecessary: why would we allow trusted code to use a jump instruction to jump out of a trusted component? it can use call and xjmp for calls/returns/tailcalls}
        % \item $\Phi'.\reg(r)$ is reasonable in memory $\Phi'.\mem$ and free stack $\Phi'.\ms_\stk$ up to $n'-1$ steps for all $r$ (including $\pcreg$)
      \item All of the following hold:
        \begin{itemize}
        \item $\Phi$ points to $\src{\scall{\offpc,\offsigma}{r_1}{r_2}}$ for some $\src{r_1}$ and $\src{r_2}$
        \item $n' = 0$ or $\Phi.\reg(r)$ is reasonable in memory $\Phi.\mem$ and free stack $\Phi.\ms_\stk$ up to $n'-1$ steps for all $r \neq \pcreg$
        \end{itemize}
      \item All of the following hold:
        \begin{itemize}
        \item $\Phi$ points to $\src{\txjmp{r_1}{r_2}}$ for some $\src{r_1}$ and $\src{r_2}$
        \item $n' = 0$ or $\Phi.\reg(r)$ is reasonable in memory $\Phi.\mem$ and free stack $\Phi.\ms_\stk$ up to $n'-1$ steps for all $r \neq \pcreg$
        \end{itemize}
      \end{itemize}
    \end{enumerate}
  \end{definition}
The four items in Definition~\ref{def:reasonable-conf} correspond to the four informal items from the introduction of this section.

Item~\ref{item:dont-store-private} and Item~\ref{item:dont-leak-private} make sure that return seals are not leaked.
Item~\ref{item:dont-store-private} says that only reasonable words can be stored to memory.
This means that sets of return seals or execute capabilities cannot be stored to memory by a reasonable component.
Intuitively, a well-formed and reasonable component has its seals available in the code memory, so it can always retrieve them from the code memory.
In other words, it is not necessary to store them in the data memory.
Further, by making sure that seals are not stored to memory, we can allow capabilities for data memory to be passed away if there is a need for that (for instance to have a shared buffer).
Item~\ref{item:dont-leak-private} makes sure that seals are not leaked when transferring control to another component (i.e. on security boundary crossings).
With the component setup, there are two ways to transfer control: xjmp and call.
In both cases, we require that all of the argument registers contain reasonable words.
An execution configuration may need to do other operations than calling other code, and seals should no be leaked at any point during execution.
For this reason, Item~\ref{item:dont-leak-private} also says that if the next step is not a call and a jump, then the next execution configuration should also be reasonable.

Item~\ref{item:guarantee-stk-base} makes sure that the stack has the correct base before a call.
In order to not have to reason about unreasonably generated code, we also add the requirement $r_1 \neq \rtmp{1}$ before calls.
If we allowed $r_1=\rtmp{1}$, then the call would be sure to fail as the first instruction of a call moves 42 to $\rtmp{1}$.
Finally, this promises that the code after the call will behave reasonably.

A well-formed component makes sure that a return seal is uniquely available to every call.
This is, however, not sufficient as it does not ensure that other parts of a program don't use the return seals.
We do not want to specify what non-call code should look like, so we just require it to not use the call seals.
This is what Item~\ref{item:return-seal-usage} ensures.
It says that if the configuration points to a seal-instruction, then either the instruction is part of a call and uses a return seal or the instruction seals part of a closure and uses a closure seal.
In order to construct a closure, one must seal a code capability and a data capability.
If this is an executable capability, then it should be reasonable as a pc.
On the other hand, if it is not an executable capability, then this must be the data part of the pair, so it should just be a reasonable word.
Definition~\ref{def:reasonable-conf} is cyclic through Definition~\ref{def:reasonable-pc}, so both definitions are step-indexed to break the cycle. If 

  \subsubsection{Reasonable component}
  A reasonable component has the informal behavioural properties from the introduction.
  Reasonability is captured by the previous definitions. These definitions are lifted to components by the following definition.
  \begin{definition}[Reasonable component]
    \label{def:reasonable-component}
    We say that a component
    \[
      (\mscode,\msdata,\overline{\var{import}},\overline{\var{export}},\sigrets,\sigcloss,A_\linear)
    \]
    is reasonable if the following hold: For all $(s \mapsto \sealed{\sigma,\vsc}) \in
    \overline{c_{\mathrm{export}}}$, with $\exec{\vsc}$, we have that $\vsc$
    behaves reasonably up to any number of steps $n$.

    We say that a component
    $(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})$ is reasonable if $\var{comp}_0$ is reasonable.
    % \lau{Is this reasonable as a word? In that case, it should  mention the
    %   memory and free stack.}
    % \dominique{No: this is reasonable as a  pc.}
  \end{definition}
\end{jversion}

In our result, we assume that adversarial components are well-formed, but not necessarily reasonable. The well-formedness assumption ensures
 that the trusted component can rely on basic security guarantees provided by the capability machine. For instance, if we did not require linearity to be respected initially, then adversarial code could start with an alias for the stack capability. The adversary is not assumed to be reasonable as we do not expect them to obey the calling convention in any way. Can adversarial code call into trusted components? The answer to that question is yes but not with LSE and WBCF guarantees. Formally, adversarial code can contain the instructions that constitute a call. However, for untrusted code, \srccm{} will not execute those instructions as a "native call" but execute the individual instructions separately. The callee then executes in the same stack frame as the caller, so WBCF and LSE do not follow (for that call).

We will assume trusted components, for which WBCF and LSE are guaranteed, to be both well-formed and reasonable. 

\subsection{Full Abstraction}
All that is left before we state the full-abstraction theorem is to define how components are combined with contexts and executed, so that we can define contextual equivalence.

\begin{figure}
  \centering
  \begin{equation*}
    \inference{
      c_{\mathrm{main},c},c_{\mathrm{main},d}  = \sealed{\sigma, c_{\mathrm{main},c}', c_{\mathrm{main},d}'} &
      \nonExec{c_{\mathrm{main},d}'}&
      \reg(\pcreg,\rdata) = c_{\mathrm{main},c}', c_{\mathrm{main},d}' \\
      \src{\reg(\rstk) = \stkptr{\rw,\baddr_\stk,\eaddr_\stk,\eaddr_\stk}} & 
      \trg{\reg(\rstk) = ((\rw,\linear),\baddr_\stk,\eaddr_\stk,\eaddr_\stk)} \\
      \reg(\RegName \setminus \{\pcreg,\rdata,\rstk\}) = 0&
      \range{\ms_\stk} = \{0\}&
      \mem = \mscode \uplus \msdata \trg{\;\uplus\; \ms_\stk} \\
      [\baddr_\stk,\eaddr_\stk] = \dom(\ms_\stk ) \mathrel{\#} (\dom(\mscode) \cup \dom(\msdata)) &
      \overline{\var{import}} = \emptyset
    }{
      ((\mscode, \msdata, \overline{\var{import}}, \overline{\var{export}}, \sigrets, \sigcloss,A_\linear),  c_{\mathrm{main},c}, c_{\mathrm{main},d}) \rightsquigarrow (\mem, \reg\src{, \emptyset, \ms_\stk})
    }
  \end{equation*}
  \caption{The judgement $\var{prog} \rightsquigarrow \Phi$, which defines the initial execution configuration $\Phi$ for executing a program $\var{prog}$.}
  \label{fig:init-ec}
\end{figure}

% How a program is lifted to an executable configuration
Given a program $\var{comp}$, the judgement $\var{comp} \rightsquigarrow \Phi$ in Figure~\ref{fig:init-ec} defines an initial execution configuration that can be executed.
It works almost the same on \trgcm{} (conditions in \trg{red}) and \srccm{} (conditions in \src{blue}).
On both machines a stack containing all zeroes is added, as part of the regular memory on \trgcm{} and as the free stack on \srccm{}.
On \srccm{}, the initial stack is empty as no calls have been made.
The component needs access to the stack, so a stack pointer is added to the register file in $\rstk$.
On \trgcm{} this is just a linear read-write capability, but on \srccm{} it is the representation of a stack pointer.
The entry point of the program is specified by main, so the two capabilities are unsealed (they must have the same seal) and placed in the $\pcreg$ and $\rdata$ registers.
Other registers are set to zero.

Contextual equivalence roughly says that two components behave the same no matter what context we plug them into.
%The remaining defintions
\begin{definition}[Plugging a component into a context]
  \label{def:comp-context-plugging}
  When $\var{comp'}$ is a context for component $\var{comp}$ and $\var{comp}' \bowtie \var{comp} \rightsquigarrow \Phi$, 
  then we write $\plug{\var{comp'}}{\var{comp}}$ for the execution configuration $\Phi$.
\end{definition}
\begin{definition}[\trgcm{} and \srccm{} contextual equivalence]
  \label{def:contextual-equivalence}
  ~
  \begin{description}
  \item[On \srccm{}], we define that $\src{\comp_1 \sconeq \comp_2}$ iff
  \begin{equation*}
    \forall \src{\context} \ldotp  \wdjud[\emptyset]{\src{\context}} \Rightarrow \src{\plug{\context}{\comp_1} \sterm{\ta[,1],\stkb_1}} \Leftrightarrow \src{\plug{\context}{\comp_2} \sterm{\ta[,2],\stkb_2}}
  \end{equation*}
  with $\src{\ta[,i]} = \src{\dom(\comp_i.\mscode)}$.
  \item[On \trgcm{}], we define that $\trg{\comp_1 \tconeq \comp_2}$ iff
  \begin{equation*}
    \forall \trg{\context} \ldotp \wdjud[\emptyset]{\trg{\context}} \Rightarrow \trg{\plug{\context}{\comp_1} \term} \Leftrightarrow \trg{\plug{\context}{\comp_2} \term}
  \end{equation*}
\end{description}
where $\Phi\sterm[i]{\src{\ta,\stkb}} \text{ iff } \Phi \nstep[i]{\src{\ta,\stkb}} \halted \quad$ and $\quad \Phi\sterm{\src{\ta,\stkb}} \defeq \exists i \ldotp \sterm[i]{\src{\ta,\stkb}}$
\end{definition}
With the above defined, we are almost ready to state our full-abstraction, and all that remains is the compiler we claim to be fully-abstract.
We only care about the well-formed components, and they sport none of the new syntactic constructs \srccm{} adds to \trgcm{}.
This means that the compilation from \srccm{} components to \trgcm{} components is simply the identity function.
% Full abstraction thm
\begin{theorem}
  \label{thm:full-abstraction}
  For reasonable, well-formed components $\comp_1$ and $\comp_2$, we have
  \begin{gather*}
    \src{\comp_1} \sconeq \src{\comp_2} \quad \Leftrightarrow \quad    \src{\comp_1} \tconeq \src{\comp_2} \qedhere
  \end{gather*}
\end{theorem}
Readers unfamiliar with fully-abstract compilation may wonder why Theorem~\ref{thm:full-abstraction} proves that \stktokens{} guarantees LSE and WBCF.
Generally speaking, behavioral equivalences are preserved and reflected by fully-abstract compilers.
This means that any property the source language has must somehow be there after compilation whether or not it is a property of the target language.
If the source language has a property that the target language doesn't have, then a compiled source program must use the available target language features to emulate the source language property in a way that it behaviorally matches exactly.
In our case, LSE and WBCF was built into the semantics of \srccm{}, but they are not properties of \trgcm{}.
In order to enforce these properties, components on \trgcm{} use \stktokens{}.
Theorem~\ref{thm:full-abstraction} proves that \stktokens{} enforces these properties in a way that behaviorally matches \srccm{} which means that it enforces LSE and WBCF.


% \begin{itemize}
% \item present our source language, its operational semantics (excerpts)
% \item tell more about components, specifically well-formed according to judgement
% \item mention our assumption of reasonability
% \item present the full abstraction theorem.
% \end{itemize}

\section{Proving full abstraction}
\label{sec:fa-proof}
\input{proving-full-abstraction}

\section{Discussion}
\label{sec:discussion}
\input{discussion}

\section{Related Work}
In this section, we discuss related work on securely enforcing control flow correctness and/or local state encapsulation or the linear capabilities we use to do it.
We do not repeat the work we discussed in Section~\ref{sec:introduction}.

Capability machines originate with \citet{dennis_programming_1966} and we refer to \citet{levy_capability-based_1984} and \citet{watson_cheri_2015} for an overview of previous work.
The capability machine formalized in Section~\ref{sec:cap-mach-w-seal-and-lin} is modelled after CHERI~\citep{watson_cheri_2015,woodruff_cheri_2014}.
This is a recent, relatively mature capability machine which combines capabilities with a virtual memory approach in the interest of backwards compatibility and gradual adoption.
For simplicity, we have omitted features of CHERI that were not needed for \stktokens{} (e.g.\ local capabilities, virtual memory).

Plenty of other papers enforce well-bracketed control flow at a low level but most are restricted to preventing particular types of attacks and enforce only partial correctness of control flow.
This includes particularly the line of work on control-flow integrity~\citep{abadi_control-flow_2005}.
This technique prevents certain classes of attacks by sanitizing addresses before direct and indirect jumps based on static control graph information and a protected shadow stack.
Contrary to \stktokens{}, CFI can be implemented on commodity hardware rather than capability machines.
However, its attacker model is different, and its security goals are weaker.
They assume an attacker that is unable to execute code but can overwrite arbitrary data at any time during execution (to model buffer overflows).
In terms of security goals, the technique does not enforce local stack encapsulation.
Also, it only enforces a weak form of control flow correctness saying that jumps stay within the program's static control flow graph~\cite{Abadi2005Theory}.
Such a property ignores temporal properties and seems hard to use for reasoning.
There is also more and more evidence that these partial security properties are not enough to prevent realistic attacks in practice~\citep{Evans:2015:CJW:2810103.2813646,Carlini2015ControlFlowBending}.

More closely related to our work are papers that use separate per-component stacks, a trusted stack manager and some form of memory isolation to enforce control-flow correctness as part of a secure compilation result~\citep{patrignani_modular_2016,juglaret_beyond_2016}.
Our work differs from theirs in that we use a different low-level security primitive (a capability machine with local capabilities rather than a machine with a primitive notion of compartments), and we do not use per-component stacks or a trusted stack manager but a single shared stack and a decentralized calling convention based on linear capabilities.
Both prove a secure compilation result from a high-level language which clearly implies a general form of control-flow correctness, but that result is not separated from the results about other aspects of their compiler.

CheriBSD applies a similar approach with separate per-component stacks and a trusted stack manager on a capability machine~\cite{watson_cheri_2015}.
The authors use local capabilities to prevent components from accidentally leaking their stack pointer to other components, but there is no actual capability revocation in play.
They do not provide many details on this mechanism and it is, for example, not clear if and how they intend to deal with higher-order interfaces (C function pointers) or stack references shared across component boundaries. 

The fact that our full abstraction result only applies to reasonable components (see Section~\ref{sec:form-secur-with}) makes it related to full abstraction results for unsafe languages.
In their study of compartmentalization primitives, \Citet{juglaret_beyond_2016} discuss the property of Secure Compartmentalizing Compilation (SCC): a variant of full abstraction that applies to unsafe source languages.
Essentially, they modify standard full abstraction so that preservation and reflection of contextual equivalence are only guaranteed for components that are {\itshape fully defined}, which means essentially that they do not exhibit undefined behavior in any fully defined context.
In follow-up work, \citet{Abate:2018:GCG:3243734.3243745} extend this approach to scenarios where components only start to exhibit undefined behavior after a number of well-defined steps. 
If we see reasonable behavior as defined behavior, then our full abstraction result can be seen as an application of this same idea.
Our results do not apply to dynamic compromise scenarios because they are intended to be used in the verification of a secure compiler where these scenarios are not relevant.
\dominique{Perhaps worth pointing out that (I suspect that) our step-bounded reasonability and FTLR, actually does apply in dynamic compromise scenario's.
  The idea would be to use the theorem multiple times with different step bounds and a different boundary between trusted and untrusted code.
  More concretely, if a component A starts behaving non-reasonable after 10 steps, then first apply the FTLR with n = 9 and component A trusted.
  Then apply the FTLR again with n > 10 and component A no longer trusted.
  Then you get stronger well-bracketedness guarantees until n=9 and weaker ones after that.
  This is a step-bounded version of the idea explained in \cite{patrignani_modular_2016}.}

Local capabilities can be used to ensure well-bracketed control-flow and local-state encapsulation as demonstrated by \citet{skorstengaard_reasoning_2017}.
Recently, \citet{tsampas_2019} demonstrated that an extension of local capabilities with multiple linearly ordered colours can be used to enforce the life time of stack references.
Specifically, a stack reference should not be able to outlive the stack frame it points to.
If \stktokens{} was extended with stack references, then it would also enforce reference life times.
Specifically in order to return from a call, we must use the return token, i.e.\ the stack.
The stack is linear, so if there are references to it, aside from the stack capability itself, then we cannot have a complete return token.
This means that we have to splice all the stack references together with the stack capability to complete the return token in order to return.
\citet{tsampas_2019} allow (almost) normal references that can be stored in multiple places at the same time.
This means that their approach is more like C than what \stktokens{} has to offer.
As explained in Section~\ref{sec:introduction}, these approaches have the downside that they require stack clearing (including unused parts) on boundary crossings.

In addition to the already-mentioned work on linear capabilities, \citet{van_strydonck_linear_2019} have recently used them in a secure (fully abstract) compiler for a C-like language with separation logic contracts.
A form of linear capabilities was also used in the SAFE machine developed within the CRASH/SAFE project \citep{DBLP:conf/sp/AmorimDGHPST15,DBLP:journals/jcs/AmorimCDDHPPPT16}.
\citet{Abate:2018:GCG:3243734.3243745} used micro-policy enforced linear return capabilities to ensure a cross-component stack discipline.
Their linear capabilities were designed specifically to enforce the stack discipline but behave similarly to ours with the notable difference that their linear return pointers are destroyed in a jump.

There are other notions of secure compilation than full-abstraction~\citep{abadi_protection_1998}.
\citet{abate_2019} present an overview of trace-based secure compilation properties.
Full abstraction is only one, relatively weak, property in their hierarchy.
It would be interesting to investigate if our compiler, i.e.\ the embedding function from \srccm{} into \trgcm{}, also satisfies some of their other properties.
While our current result implies that we can prove contextual equivalences in \trgcm{} components using \stktokens{}, by proving them instead in the more well-behaved \srccm{} semantics, such stronger properties would imply that we can also prove robust preservation of other (hyper-)properties in a similar manner.
We expect that, in addition to full abstraction, our embedding also satisfies Robust Relational Hyperproperty Preservation (RrHP, the strongest property in the hierarchy of \citeauthor{abate_2019}) and that a large part of our current proof (the back-translation and the logical relation) could be reused to establish this.
However, to do this, we would first need to extend our semantics with some form of traces and we have not investigated how best to do this. 


% \begin{acks}                            %% acks environment is optional
%                                         %% contents suppressed with 'anonymous'
%   %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%   %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%   %% acknowledge financial support and will be used by metadata
%   %% extraction tools.
%   This material is based upon work supported by the
%   \grantsponsor{GS100000001}{National Science
%     Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%   No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%   No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%   conclusions or recommendations expressed in this material are those
%   of the author and do not necessarily reflect the views of the
%   National Science Foundation.
% \end{acks}

\begin{acks}
  This research was supported in part by the ModuRes Sapere Aude
  Advanced Grant from The Danish Council for Independent Research for
  the Natural Sciences (FNU) and by Cost Action CA15123 EUTypes.
  Dominique Devriese held a Postdoctoral Fellowship from the Research Foundation - Flanders (FWO) during most of this research.
\end{acks}

\bibliography{references}


%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\clearpage
\appendix
\input{appendix}
\end{document}
 