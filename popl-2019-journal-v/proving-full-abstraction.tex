% \begin{itemize}
% \item Logical relation
% \item FTLR
% \item Sketch high-level structure of the proof
% \end{itemize}
To prove Theorem~\ref{thm:full-abstraction}, we essentially show that trusted components in \srccm{} are related in a certain way to their embeddings in \trgcm{}, and that untrusted \trgcm{} components are similarly related to their embeddings in \srccm{}.
We will then prove that these relations imply that the combined programs have the same observable behavior, i.e.\ one terminates if and only if the other does.
The difficult part is to define when components are related.
In the next section, we give an overview of the relation we define, and then we sketch the full-abstraction proof in Section~\ref{subsec:proof-sketch}.

\begin{jversion}
  The goal of this section is not to provide full technical detail or list tedious proofs.
  However, we believe there are many interesting aspects about our proof that we were forced to omit from the conference version, which would be worthwhile explaining to other researchers.
  This includes, for example, our use of cross-language logical relations, the techniques we use for reasoning about seals and linear capabilities, or for the linking model.
  In the current version, we provide a more detailed explanation of the most important of these aspects, taking care to gradually introduce the different techniques we use and to not bother the reader with tedious details. 
  Of course, this material is targeted at readers with an interest in these proof techniques and may be safely skipped by others.
  % Dominique: I'm worried reviewers will be bothered by the fact that we recommend some readers to read the conference version, so I commented it out.  We can still readd it in next versions if reviewers comment about this.
  % Readers who are looking for a shorter summary with less detail may refer to the conference version of this paper for a presentation~\citep{skorstengaard_stktokens_2019} with emphasis on the intuition and fewer details.
\end{jversion}

\subsection{Kripke worlds}
\label{subsec:worlds}
The relation between \srccm{} and \trgcm{} components is non-trivial: essentially, we will say that components are related if invoking them with related values produces related observable behavior.
However, values are often only related under certain assumptions about the rest of the system.
For example, the linear data part of a return capability should only be related to the corresponding \srccm{} capability if no other value in the system references the same inactive stack frame and it is sealed with a seal only used for return pointers to the same code location.
To accommodate such conditional relatedness, we construct the relation as a step-indexed Kripke logical relation with recursive worlds.

\begin{jversion}
Assumptions about the system that relatedness is predicated on are gathered in (Kripke) worlds.
To a first approximation, a world is a semantic model of the memory.
In its simplest form, it is a collection of invariants that the memory must satisfy.
The invariants of a world can vary in complexity and expressiveness depending on the application.
The possible contents of the memory also influences what the world looks like.
For instance, the uniqueness of the linear capabilities on \trgcm{} and \srccm{} is modelled by the worlds using a form of memory ownership assumptions.
In order to relate \trgcm{} and \srccm{}, we model all the features of \srccm{} in the world which means we have to model:
\begin{itemize}
\item Three kinds of memory: heap, stack of local frames, and free stack
\item Linearity
\item Call stack
\item Seals
\end{itemize}
The three kinds of memory are modelled by having three sub-worlds where each sub-world is its own little world in a traditional sense.
Linearity is modelled by adding ownership to certain parts of the world that capabilities can take ownership of ensuring that they are the sole reference for that part of memory.
Memory satisfaction (the relation that decides whether two memories are related in the world) models the call stack by ensuring that the memory is actually shaped like a stack.
Finally, the seals are modelled by seal invariants that make sure that seals are only used on permitted sealables.
In the following, we present the world and go into details about how each of the four features are modelled.

\subsubsection{Triple world and regions}
\srccm{}s memory is split in three: heap, free stack and encapsulated local stack frames.
In order to model the three kinds of memory, we simply have three sub-worlds.
That is, our world is defined as a product:
\[
  \World = \Worldh \times \Worlds \times \Worldfs
\]
The sub-worlds are partial maps from names $\RegName$ (not to be confused with register names), modelled as natural numbers, to invariants.
In order to define what this actually means, we need to be more precise about what we mean by invariants.

We call the invariants regions because, as we will see in Section~\ref{subsubsec:ft-and-revocation}, they turn out to not be invariant.
A region describes a collection of related memory segments, so it is simply represented as a relation over memory segments (i.e.\ a relation in $\Rel{\MemSeg \times \MemSeg}$).
Intuitively, we want to be able to say that two memory segments are related when their content is related.
That is, for every address in the two memory segments, the words that reside there must be related.
In Section~\ref{subsec:logical-relation}, we define precisely what it means for words to be related, but for now we provide some intuition.
If we have two integers, then they are related when they are equal.
If we instead have two capabilities, then they should also be related if they, in some sense, are equal.
But what does it mean for capabilities to be \textit{equal}?
Intuitively, it should mean that the capabilities give you the same authority, for instance, if you have two executable capabilities, they should observably perform the same computation.
As a capability points to a piece of memory, the authority of the capability depends on the contents of that memory.
In other words to say whether two capabilities are related, we must know the possible contents of the memory.
The world expresses the possible memory contents, so our regions are world indexed, i.e.
\[
  \Worldh = \RegName \parfun (\World \fun \Rel{\MemSeg \times \MemSeg})
\]
At this point, we can see that we have constructed a recursive domain equation.
If we inline $\Worldh$ in $\World$, then we have a circular equation with no solution because the self-reference happens in a negative position.
Luckily, we can solve circular equations if we move to a different domain.
For now, we will ignore the problem and return to the issue in Section~\ref{sec:rec-dom-eq}.

For the sake of readability, we introduce the following notation
\begin{gather*}
  \pwheap = \pi_1(W)\\
  \pwpriv = \pi_2(W)\\
  \pwfree = \pi_3(W)
\end{gather*}
\subsubsection{Linearity}
% Linearity
The linear capabilities of \srccm{} and \trgcm{} guarantee that they have the sole authority over the memory they reference\footnote{Under the assumption that the system was initialised with unique linear capabilties.}.
In order to model this uniqueness, we need to keep track of which parts of memory are uniquely referenced and make sure that only one linear capability references the unique parts.
%% Bookkeeping done by worlds
We use the world to keep track of what parts of memory must be uniquely referenced by having two kinds of regions: shared and spatial.
If a memory segment is governed by a shared region, then normal capabilities may reference it.
On the other hand, if a memory segment is governed by a spatial region, then only a linear capability may reference it.

%%% spatial/spatial_owned
We cannot let multiple linear capabilities reference the same memory.
The spatial region represent ownership of a part of memory which ensures that a linear capability is not aliased.
Even though spatial regions gives the right to reference part of memory, we still need the world to specify the remainder of the memory that may be referenced by linear capabilities.
To this end, we have shadow regions.
A shadow region is a shadow copy of a spatial region in the sense that it specifies part of memory, but it does not give the right to reference that part of memory.
This does not mean that the memory is necessarily not referenced.
A compatible world may claim a shadow region as spatial which allows the other world to reference the memory (we return to the notion of compatible worlds w.r.t. ownership in Section~\ref{subsubsec:joining-worlds}).
Specifically, we add tags $\spatialo$ and $\spatial$ to the spatial regions:
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatialo \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \cup \\ 
    \{\spatial \} \times (\World \fun \Rel{\MemSeg \times \MemSeg})  \\
  \end{array} \right.
\]
For readability, we also add a tag $\pure$ to the shared regions:
\[
  \Regionh = \{\pure \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) 
\]

% What parts of memory are linear
We will extend the regions further in Sections~\ref{subsubsec:seals}~and~\ref{subsubsec:ft-and-revocation}, but for now we continue the definitions of the three sub-worlds.
The sub-world $\Worldh$ specifies the heap memory which can be referenced by both linear and normal capabilities, so it should contain both shared and spatial regions.
For this reason, it is defined as
\[
  \Worldh = \RegName \parfun (\Regionh \cup \Regions)
\]
\srccm{} internalizes the \stktokens{} stack, so it can only be referenced by linear capabilities which means that the two stack regions should only have spatial regions.
For instance the $\Worldfs$ is defined as
\[
  \Worldfs = \RegName \parfun \Regions
\]
$\Worlds$ can also only be referenced by linear capabilities, so it should also only have spatial regions.
$\Worlds$ not only models the memory contents of the local stack frames, it also models the call stack that consists of the stack frames.
Conceptually, this means that each of the stack frames is connected with a return point in some code.
In a traditional C calling convention, the code return point would even be stored in the stack frame.
However, with \stktokens{} a stack frame does not contain any information about the corresponding code return point.
Instead, the stack frame and code return point is connected by the capabilities that reference them as they are sealed with the same seal and together then constitute the sealed return pair.
In order to ensure that each call actually returns to the correct point of the code, we must still include the address of the return point in our model.
To this end, each shared region in $\Worlds$ must be paired with a return address:
\[
\Worlds = \RegName \parfun (\Regions \times \Addr)
\]

% Ensuring linearity
The spatial regions add the necessary bookkeeping to the worlds to model linear capabilities.
The logical relation presented in Section~\ref{subsec:logical-relation} uses this bookkeeping to ensure that linear capabilities \emph{uniquely} references part of memory.

Given a world, we want to be able to express that a capability, that is otherwise valid with respect to the world, is not linear or indirectly depends on a linear capability.
This is expressed by stripping the world of all its ownership which corresponds to replacing all $\spatialo$ regions with $\spatial$ regions and then requiring that the capability is valid w.r.t.\ this new world.
We refer to this as the shared part of the world and define the function $\purePart{}$ which turns all spatial regions into shadow copies.
\begin{definition}[The shared part of a world]
  \label{def:purePart}
  For any world $W$, we define
  \begin{align*}
    \purePart{W} &\defeq (\purePart{\pwheap},\purePart{\pwpriv},\purePart{\pwfree})\\
    \purePart{W_\var{heap}} &\defeq \lambda r\ldotp
                       \begin{cases}
                         (\spatial,\var{H}) & \text{if } W_\var{heap}(r) = (\spatialo,\var{H})\\
                         W_{\var{heap}}(r) & \text{otherwise}
                       \end{cases}\\
    \purePart{W_\var{call\_stk}} &\defeq \lambda r\ldotp
                       \begin{cases}
                         ((\spatial,\var{H}),\opc) & \text{if } W_\var{call\_stk}(r) = ((\spatialo,\var{H}),\opc)\\
                         W_\var{call\_stk}(r) & \text{otherwise}
                       \end{cases}\\
    \purePart{W_\var{free}} &\defeq \lambda r\ldotp
                       \begin{cases}
                         (\spatial,\var{Hs}) & \text{if } W_{\var{free}}(r) = (\spatialo,\var{Hs})\\
                         W_{\var{free}}(r) & \text{otherwise}
                       \end{cases}
  \end{align*}
\end{definition}
\subsubsection{Seals}
\label{subsubsec:seals}
So far, the world represents a collection of assumptions on the memory contents that value correctness may depend on.
However, value correctness may depend on other assumptions.
Specifically, \stktokens{} has certain assumption on the seals used for return capabilities and closures.
For instance, a return seal must only be used to seal the return pointer of one specific return point.
Therefore, in addition to a relation on memory segments, some regions also carry a \emph{seal interpretation function} that relates the sealables that may be sealed with a given seal.
  \[
    \Seal \parfun \World \fun \Rel{\SealableCaps \times \SealableCaps}
  \]
%% Shared region has a seal indexed invariant that specifies what sealables can be sealed with a specific seal
  In \stktokens{}, once a seal has been used for a specific purpose (e.g.\ for sealing return capability pairs for a specific call site), it can never be reused for a different purpose.
  This is because there may still be copies of return capabilities out there, signed with the seal.
  This situation is similar to the situation for non-linear memory capabilities, so we only allow shared regions to carry seal interpretation functions, as we will see that those regions can never be revoked in future worlds.
\begin{multline*}
  \Regionh = 
  \{\pure \} \times (\World \fun \Rel{\MemSeg\times\MemSeg}) \times \\
  (\Seal \parfun \World \fun \Rel{\SealableCaps \times \SealableCaps})
\end{multline*}
We also refer to the seal interpretation function as the seal invariant, and we will refer to the memory relation as the memory invariant or just invariant when it is unambiguous.

\lau{Maybe add a bit more of explanation? Invariant needed for the LR to make sure that designated seals are used for their purpose. }

\subsubsection{Future worlds and revocation}
\label{subsubsec:ft-and-revocation}
% Memory evolves over time, we need to model this.
Very often, relatedness of two capabilities does not change if extra assumptions in the system are added.
For example, two related capabilities remain related when an extra invariant is added on unrelated memory, or when a stack frame that it does not reference is dropped.
In Kripke logical relations, this kind of assumption changes, that do not invalidate the relatedness of values, are modelled by the future world relation $\future$.
The future world relation can also be thought of as the model of allowed changes in memory over time.

Safety of capabilities should be defined, so it is monotone with respect to the future world relation.
This means that the system assumptions that capabilities rely on for safety are defined such that capabilities remain safe during execution.
The same holds for the memory invariants stored in the world: capabilities stored in memory should remain valid under allowed changes in system assumptions.
This means we require the world-indexed memory invariants to be monotone in the world.
In other words, a pair of memory segments that are related now will stay related in future worlds.
This changes the spatial regions as follows:
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial \} \times (\World \monfun \Rel{\MemSeg \times \MemSeg}) \cup \\
    \{\spatialo \} \times (\World \monfun \Rel{\MemSeg \times \MemSeg}) \cup \\
    \{\revoked \}
  \end{array} \right.
\]
We make a similar change to $\Regionh$. The seal invariants are monotone as well.

Kripke future world relations usually allow extending worlds with extra assumptions, or take steps in protocols that the system was designed to support from the start.
However in our setting, we sometimes allow dropping assumptions, namely when linearity tells us that no value in the system depends on this assumption any more.
Specifically, if we have the only linear capability for a piece of memory, then we can be sure that there are no other capabilities for the same memory which makes it safe to repurpose the memory and drop or replace the previous assumption.
We mark dropped regions as revoked in the world following \citet{ahmed_2004} and \citet{thamsborg_2011} which for all intents and purposes corresponds to actually dropping the region. 

We add a $\revoked$ tag to the spatial regions $\Regions$ which results in
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \cup \\
    \{\spatialo \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \cup \\
    \{\revoked \}
  \end{array} \right.
\]
The $\spatialo$-region signifies that a linear capability \emph{may} depend on it which means that it cannot be revoked.
On the other hand, no capability can depend on a $\spatial$-region, so it can be safely revoked.
This may be confusing as a $\spatial$-region does not mean that you ``have'' the capability, but we just explained that having a linear capability means that you can repurpose the memory it points to.
As we will see later, the logical relation splits worlds with respect to their ownership, so each capability can get its own world with unique ownership to depend on.
A repurposed linear capability gets an entirely new world to depend on.
The new world constructed for the repurposed linear capability would have a revoked region in place of the $\spatialo$-region, but the new world would not be a future world of the world the linear capability depended on before.
After all, a future world has to respect old invariants, but a repurposed capability needs to depend on new invariants.
While the repurposed capability gets a new world to depend on, all other capabilities in the system depend on the same invariants, so they must be valid with respect to worlds that respect the old invariants, i.e. future worlds.
Further, the future worlds must be compatible (agree on everything but ownership) with the new world.
This means that all the $\spatial$-regions must be replaced with $\revoked$ regions which is why $\spatial$ regions can be turned into $\revoked$ regions.

We define the future world relation in terms of a future region relation which is displayed in Figure~\ref{fig:ft-reg-rel}.
Apart from being revoked, a region can stay the same, or a $\spatial$ region can become $\spatialo$ which models the affinity of the linear capabilities.
Specifically, the linear capabilities in \trgcm{} and \srccm{} can be dropped by overwriting them in registers or memory which makes the linear capabilities affine.
A linear capability is safe with respect to a world with some $\spatialo$ regions.
However, this world, and thus the $\spatialo$ regions, is no longer needed if the linear capability is dropped, so other worlds are free to claim the $\spatialo$ region in place of their $\spatial$ region.
% describe why "Spatial -> spatialo" ~ affine or at least why we have it?
\begin{figure}[htb]
  \centering
  \begin{mathpar}
  \inferrule{ r \in \Regions \cup \Regionh }{ r \future r}
  \and
  \inferrule{ }{ \revoked \future (\spatial,\_)}
  \and
  \inferrule{ }{ (\spatialo,H) \future (\spatial,H)}
\end{mathpar}
  \caption{Future region relation.}
  \label{fig:ft-reg-rel}
\end{figure}
The above repurposing discussion is exemplified in \figurename~\ref{fig:world-example}.
The Figure displays two capabilities $c_{\var{normal}}$ and $c_{\var{linear}}$ that are normal and linear, respectively.
The linear capability is valid with respect to $W_1$ which has the necessary $\spatialo$ region, and the normal capability is valid with respect to $W_2$ which has a $\pure$ region.
The two worlds are compatible as $W_2$ has a $\spatial$ region that matches the $\spatialo$ region of $W_1$.
When the linear capability is repurposed, it must be reflected by the worlds $W_1'$ and $W_2'$.
In both new worlds, the $r_2$ region is replaced with a $\revoked$ region.
$W_1'$ has a new $\spatialo$ region at $r_3$, and $W_2'$ gets a matching $\spatial$ region.
The new world for the linear capability, $W_1'$, is not a future world of $W_1$ as it replaces a $\spatialo$ region with a $\revoked$ region which is not allowed by the future region relation.
The new world for the normal capability, $W_2'$, is a future world of $W_2$ as the future region relation allows $\spatial$ regions to be revoked.
The normal capability $c_{\var{normal}}$ remains valid in $W_2'$ as the $\pure$ region it depends on is monotone with respect to the future world relation.
\begin{figure}\centering
  
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
    \begin{scope}
  \scope
    \clip (-.1,-.1) rectangle (4.6,11.1);
    \fill[fill=white] (0,0) rectangle (4.5,11);
    \draw (0,0) -- (0,11);
    \draw (4.5,0) -- (4.5,11);
      \foreach \x in {.5,1,...,10}
      {
        \draw[fill=white] (0,\x) rectangle (4.5,\x+.5) node[pos=.5,color=teal] {};
      };
  \endscope
  \draw [decorate,decoration={brace,amplitude=7pt,raise=4pt},yshift=0pt] (-.025,0.5) -- (-.125,5) node (lin) [black,midway,xshift=-0.25cm,align=center] { };
  \draw (-5,3) edge[-latex, bend right, in=180, out=-20, dashed] node[below] {$c_{\var{lin}}$}(lin);
  
  \draw [decorate,decoration={brace,amplitude=7pt,raise=4pt},yshift=0pt] (-.025,6) -- (-.125,10.5) node (norm) [black,midway,xshift=-0.25cm,align=center] { };
  \draw (-5,8.5) edge[-latex, bend right, in=180, out=-20] node[below] {$c_{\var{norm}}$} (norm);

  \draw (-0.25,10.5) edge[very thin, densely dashed, opacity=6] (11,10.5);
  \draw (-0.25,6) edge[very thin, densely dashed, opacity=6] (11,6);
  \draw (-0.25,5) edge[very thin, densely dashed, opacity=0.5] (11,5);
  \draw (-0.25,0.5) edge[very thin, densely dashed, opacity=0.5] (11,0.5);
\end{scope}

  \begin{scope}[shift={(11,0)}]
  \scope
    \clip (-.1,-.1) rectangle (4.6,11.1);
    \fill[fill=white] (0,0) rectangle (4.5,11);
    \draw (0,0) -- (0,11);
    \draw (4.5,0) -- (4.5,11);
      \foreach \x in {.5,1,...,10}
      {
        \draw[fill=white] (0,\x) rectangle (4.5,\x+.5) node[pos=.5,color=teal] {};
      };
  \endscope

  \draw (-4,11.5) node {\huge $W_1$};
  \draw (-4,8) node (w1r1) {$r_1$};
  \draw (-4,5.5) node (w1r2) {$r_2$};

  \draw[red, fill=red, fill opacity=.5] (-.5,10.5) rectangle (1.5,6) node[fitting node] (w1s) { };
  \draw (w1r1) edge[->,in=180, out=10] (w1s.west);

  \draw[blue, fill=blue, fill opacity=.6] (-.5,5) rectangle (1.5,0.5) node[fitting node] (w1l) { };
  \draw (w1r2) edge[->,in=180, out=-30] (w1l.west);


  \draw (8.5,11.5) node {\huge $W_2$};
  \draw (8.5,8) node  (w2r1) {$r_1$};
  \draw (8.5,5.5) node (w2r2) {$r_2$};

  \draw[red, fill=red, fill opacity=.5] (3,10.5) rectangle (5,6) node[fitting node] (w2s) { };
  \draw (w2r1) edge[->,in=0, out=170] (w2s.east);

  \draw[darkgray, fill=darkgray, fill opacity=.4] (3,5) rectangle (5,0.5) node[fitting node] (w2l) { };
  \draw (w2r2) edge[->,in=0, out=210] (w2l.east);

  \end{scope}

  \begin{scope}[shift={(11,-15)}]
  \scope
    \clip (-.1,-.1) rectangle (4.6,11.1);
    \fill[fill=white] (0,0) rectangle (4.5,11);
    \draw (0,0) -- (0,11);
    \draw (4.5,0) -- (4.5,11);
      \foreach \x in {.5,1,...,10}
      {
        \draw[fill=white] (0,\x) rectangle (4.5,\x+.5) node[pos=.5,color=teal] {};
      };
  \endscope

  \draw (-4,11.5) node (w1) {\huge $W_1'$};
  \draw node[above of=w1,rotate=-90] {\huge $\not\sqsubseteq$};
  \draw (-4,8) node (w1r1) {$r_1$};
  \draw (-4,5.5) node (w1r2) {$r_2$};
  \draw (-4,3) node (w1r3) {$r_3$};

  \draw[red, fill=red, fill opacity=.5] (-.5,10.5) rectangle (1.5,6) node[fitting node] (w1s) { };
  \draw (w1r1) edge[->,in=180, out=10] (w1s.west);

  \node[draw,rectangle, black, minimum size=4mm] (w1r) at (-2,5) {  };
  \node[fit=(w1r),black,inner sep=-\pgflinewidth,cross out, draw] (test) { };
  \draw (w1r2) edge[->, out=0] (w1r);

  \draw[green, fill=green, fill opacity=.7] (-.5,5) rectangle (1.5,0.5) node[fitting node] (w1l) { };
  \draw (w1r3) edge[->,in=180, out=-30] (w1l.west);


  \draw (8.5,11.5) node (w2) {\huge $W_2'$};
  \draw node[above of=w2,rotate=-90] {\huge $\sqsubseteq$};
  \draw (8.5,8) node  (w2r1) {$r_1$};
  \draw (8.5,5.5) node (w2r2) {$r_2$};
  \draw (8.5,3) node (w2r3) {$r_3$};

  \draw[red, fill=red, fill opacity=.5] (3,10.5) rectangle (5,6) node[fitting node] (w2s) { };
  \draw (w2r1) edge[->,in=0, out=170] (w2s.east);

  \node[draw,rectangle, black, minimum size=4mm] (w2r) at (6.5,5) {  };
  \node[fit=(w2r),black,inner sep=-\pgflinewidth,cross out, draw] (test) { };
  \draw (w2r2) edge[->, out=180,in=45] (w2r);


  \draw[lightgray, fill=lightgray, fill opacity=.4] (3,5) rectangle (5,0.5) node[fitting node] (w2l) { };
  \draw (w2r3) edge[->,in=0, out=210] (w2l.east);

  \end{scope}

   \matrix [draw,above right, column sep=1.5mm,xshift=.4cm,yshift=.4cm] at (current bounding box.south west) {
    &\node[red, fill=red, fill opacity=.5,minimum size=0.4cm,label=right:{\footnotesize Shared region}] {}; \\
     \node[darkgray, fill=darkgray, fill opacity=.4,minimum size=0.4cm] {};
    &\node[lightgray, fill=lightgray, fill opacity=.4,minimum size=0.4cm,label=right:{\footnotesize Shadow regions}] {}; \\
     \node[green, fill=green, fill opacity=.7,minimum size=0.4cm] {};
    &\node[blue, fill=blue, fill opacity=.6,minimum size=0.4cm,draw,label=right:{\footnotesize Spatial regions}] {}; \\
    &\node[draw,rectangle, black, minimum size=4mm] (rev) {};
     \node[fit=(rev),black,inner sep=-\pgflinewidth,cross out, draw, label=right:{\footnotesize Revoked region}] {};\\
     \node[minimum size=0.4cm] (ln) {}; & \node[minimum size=0.4cm,label=right:{\footnotesize Normal capability}] (rn) {};\\
     \node[minimum size=0.4cm] (ll) {}; & \node[minimum size=0.4cm,label=right:{\footnotesize Linear capability}] (rl) {};\\
};
\draw (ln.west) edge[-latex,out=-20,in=160] (rn.east);
\draw (ll.west) edge[-latex,out=-20,in=160,dashed] (rl.east);

%   \matrix [draw,below right, column sep=1.5mm, anchor=south west] at (current bounding box.south west) {
%     &\node[red, fill=red, fill opacity=.5,minimum size=0.4cm,label=right:{\footnotesize Shared region}] {}; \\
%     &\node[gray, fill=gray, fill opacity=.4,minimum size=0.4cm,label=right:{\footnotesize Shadow region}] {}; \\
%      \node[green, fill=green, fill opacity=.7,minimum size=0.4cm] {};
%     &\node[blue, fill=blue, fill opacity=.6,minimum size=0.4cm,draw,label=right:{\footnotesize Spatial region}] {}; \\
%     &\node[draw,rectangle, black, minimum size=2mm] (rev) {};
%      \node[fit=(rev),black,inner sep=-\pgflinewidth,cross out, draw, label=right:{\footnotesize Revoked region}] {};\\
% };
\end{tikzpicture}

\caption{Example what happens to worlds when a linear capability $c_{\var{lin}}$ is repurposed.
  The linear capability is originally valid with respect to $W_1$.
  In $W_1'$ there is a new spatial region that the linear capability is valid with respect to (the different coloured regions signify different invariants).
  $W_1'$ still has $r_2$, but now it points to a $\revoked$ region.
  This means that $W_1'$ is not a future world of $W_1$.
  The normal capability $c_{\var{norm}}$ is originally valid with respect to $W_2$ and should stay valid with respect to the new world $W_2'$.
The $W_2'$ is a future world of $W_2$ as the $\spatial$ region in $W_2$ is replaced with a $\revoked$ region which is permitted by the future world relation.}
\label{fig:world-example}
\end{figure}

With the future region relation in place, we can define the future world relation as follows: For worlds $W$ and $W'$,
\[
  W' \future W \text{ iff } \left\{
    \array{l}
    \text{for $i \in \{\mathrm{heap},\mathrm{free\_stk},\mathrm{call\_stk} \}$} \\
    \quad\exists m_i : \RegionName \fun \RegionName, \text{ injective}\ldotp\\
    \qquad \dom(W'.i) \supseteq \dom(m_i(W.i)) \wedge \forall r \in \dom(W.i)\ldotp W'.i(m_i(r)) \future W.i(r)
     \endarray
  \right.
\]
The relation says that each of the three worlds must be an extension of the past world and each of the existing regions must have a future region.
% injective function
Note that the future world relation has a mapping function $m_i$ which allows us to change the naming of regions in future worlds.
The definition is a generalization of the standard definition where $m_i$ would be the identity\footnote{In \citet{skorstengaard_reasoning_2017} the future region relation and the reasoning about the awkward example could have been simplified with this future world relation.}.\dominique{I wonder if the renaming function obviates the need for the ``revoked'' trick.}

\subsubsection{Joining worlds}
\label{subsubsec:joining-worlds}
The world serves multiple purposes as it is both a specification of memory contents as well as a specification of authority.
This is best seen in the operators used to join worlds.
First when we see the world as a memory specification, we have a pretty standard join $\uplus$ that simply requires the worlds to have different region names.\begin{definition}[World disjoint union $\uplus$]
  Given worlds $W_1$, $W_2$, $W$
  \[
    W_1 \uplus W_2 = W
    \text{ iff }
    \begin{array}[t]{l}
      \dom(\pwheap) = \dom(\pwheap[W_1]) \uplus \dom(\pwheap[W_2]) \tand \\
      \dom(\pwfree) = \dom(\pwfree[W_1]) \uplus \dom(\pwfree[W_2]) \tand \\
      \dom(\pwpriv) = \dom(\pwpriv[W_1]) \uplus \dom(\pwpriv[W_2]) \\
    \end{array}
  \]
\end{definition}
The $\uplus$ world join does not guarantee that the result is a sensible world with respect to authority or memory specification.
In \sectionname~\ref{subsubsec:mem-sat}, we define memory satisfaction which also acts as a well-formedness judgement.

When we view the world as a specification of authority, then the world join need to respect the region ownership.
That is, when we join the authority of two worlds, then the ownership of the two worlds should not overlap.
This is expressed by the $\oplus$ operator.
\begin{definition}[$\oplus$, disjoint union of ownership]
  \[
    W_1 \oplus W_2 = W
  \text{ iff }
  \begin{array}[t]{l}
    \dom(\pwheap) = \dom(\pwheap[W_1]) = \dom(\pwheap[W_2]) \tand \\
    \dom(\pwfree) = \dom(\pwfree[W_1]) = \dom(\pwfree[W_2]) \tand \\
    \dom(\pwpriv) = \dom(\pwpriv[W_1]) = \dom(\pwpriv[W_2]) \tand \\
    \forall r \in \dom(\pwheap) \ldotp \pwheap(r) = \pwheap[W_1](r) \oplus \pwheap[W_2](r) \tand \\
    \forall r \in \dom(\pwfree) \ldotp \pwfree(r) = \pwfree[W_1](r) \oplus \pwfree[W_2](r) \tand \\
    \forall r \in \dom(\pwpriv) \ldotp \pi_1(\pwpriv(r)) = \pi_1(\pwpriv[W_1](r)) \oplus \pi_1(\pwpriv[W_2](r))
  \end{array}
  \]
  where $\oplus$ for regions is defined as
\begin{align*}
  (\pure,H,H_\sigma) \oplus (\pure,H,H_\sigma) =  & \; (\pure,H,H_\sigma) \\
  (\spatial,H) \oplus (\spatial,H) =  & \; (\spatial,H) \\
  \revoked \oplus \revoked = & \; \revoked \\
  (\spatialo,H) \oplus (\spatial,H) = & \; (\spatial,H) \oplus (\spatialo,H)\\
                                           =  & \; (\spatialo,H)
\end{align*}
\end{definition}
The $\oplus$ operator, like the $\uplus$ operator, does not guarantee that the resulting world is sensible (e.g., the regions are not overlapping).
Only when we know that a certain memory satisfies the world (as a memory specification, see Section~\ref{subsubsec:mem-sat}), will we be sure that the world's specifications are actually non-contradictory.

The $\uplus$ operator is used in the logical relation for components (\sectionname~\ref{subsec:component-rel}) which specifies (among other things) that the world should specify the presence of the component's data memory.
Linking two components then produces a new component with both components' data memory.
The linked component is valid in a world that has the combined memory presence specifications, not the combined authority.

Note also that this picture is further complicated by our usage of non-authority-carrying $\spatial$ regions.
They are really only in a world $W$ as a shadow copy of a $\spatialo$ region in another world $W'$ that $W$ will be combined with.
The shadow copy is used for specifying when a memory satisfies a world: the memory should contain all memory ranges that anyone has authority over, not just the ones whose authority belongs to the memory itself.
For example, if a register contains a linear pointer to a range of memory, then the register file will be valid in a world where the corresponding region is $\spatialo$, while the memory will be valid in a world with the corresponding region only $\spatial$.
However, for the memory to satisfy the world, the block of memory needs to be there, i.e. the memory should contain blocks of memory satisfying every region that is $\spatialo$, $\pure$, but also just $\spatial$ (because it may be $\spatialo$ in, for example, the register file's world).

\subsubsection{Memory satisfaction}
\label{subsubsec:mem-sat}
% Specification
The world can be seen as a specification of the memory contents.
This means that we need to define what it means for a pair of \trgcm{} and \srccm{} memories to satisfy the specification.
% Call stack
The world also keeps track of the structure of the call stack, the allowed uses of designated seals, and linear capability authority, so these things also influence the definition of memory satisfaction.
% Well-formedness
The world definition on its own allows the invariants imposed by regions to be overlapping.
However, to be able to easily determine what invariants a memory segment must respect, we want the invariants of the regions to impose requirements on disjoint parts of the memory.
The memory satisfaction relation makes sure that this is the case, so in a sense the memory satisfaction also acts as a well-formedness judgement for worlds.

\dominique{At this point, the paper is starting to read like a tech report.
  Are we sure it's a good idea to provide this much technical detail?
  I would propose to not include all definitions, but a representative selection and refer to the TR for full detail.
}

Memory satisfaction is split into four definitions.
At the top-level we have $\memSat{\ms_S,\ms_\stk,\stk,\ms_T}{W}$ which relates the source memory triple, $\ms_S$ (heap), $\ms_\stk$ (free stack), and $\stk$ (stack frames), from \srccm{} to the target memory $\ms_T$ from \trgcm{}.
The top-level definition of memory satisfaction splits the target memory in three parts, one for each of the three kinds of source memory.
It also splits the world in three to distribute the authority of the world.
The three $\ms_T$ partitions are related to $\ms_S$, $\ms_\stk$, and $\stk$ by the relations $\lrhname$, $\lrstk[]$, and $\lrfree[]$, respectively. 
The $\lrhname$ relation relates the \srccm{} heap (non-stack memory) to the corresponding heap memory on \trgcm{}.
The $\lrhname$ relation also ensures that the seal invariants associated with each region have invariants on disjoint sets of seals.
The $\lrstk[]$ relation relates the stack of encapsulated stack frames on \srccm{} to the corresponding memory on \trgcm{}.
The layout of the stack determines the call order, so $\lrstk[]$ also makes sure that the placement in memory of the stack frames have the correct order relative to each other and the base address of the stack.
Finally, $\lrfree[]$ relates the free part of the stack of \srccm{} to the corresponding memory segment on \trgcm{}.
$\lrfree[]$ also makes sure that the base address of the stack is actually part of the free stack.
\begin{definition}[Heap relation]
\label{def:heap-rel}
For a set of seals $\overline{\sigma}$, memory segments $ms$ and $\ms_T$, and worlds $W$ and $W'$, we define the heap relation $\lrhname$ as:
\[
  \npair{(\overline{\sigma},\src{ms},\ms_T)} \in \lrheap(\pwheap)(W') = 
  \left\{
    \begin{array}{l}
      \exists R_\ms : \dom(\activeReg{\pwheap}) \fun \MemSeg \times \MemSeg \wedge \\
      \quad \ms_T = \biguplus_{r \in \dom(\activeReg{\pwheap})} \pi_2(R_\ms(r)) \wedge \\
      \quad \src{\ms} = \biguplus_{r \in \dom(\activeReg{\pwheap})} \pi_1(R_\ms(r)) \wedge \\
      \quad \exists R_W : \dom(\activeReg{\pwheap}) \fun \World\ldotp\\
      \qquad W' = \oplus_{r \in \dom(\activeReg{\pwheap})} R_W(r) \wedge\\
      \qquad \forall r \in \dom(\activeReg{\pwheap}), n' < n \ldotp \\
      \qquad \quad \npair[n']{R_\ms(r)} \in  \pwheap(r).H \; \xi^{-1}(R_W(r)) \wedge\\
      \exists R_\var{seal} : \dom(\activeReg{\pwheap}) \fun \powerset{\Seal} \wedge\\
      \quad \biguplus_{r \in \dom(\activeReg{\pwheap})} R_\var{seal}(r)) \subseteq \overline{\sigma} \wedge\\
      \quad \forall r \in \dom(\erase{\pwheap}{\pure})\ldotp \dom(\pwheap(r).H_\sigma) = R_\var{seal}(r)
    \end{array}
  \right.
\]
\end{definition}
Memory satisfaction, and thus also the heap relation, only considers the non-$\revoked$ regions.
The $\lrhname$-relation uses the function $\activeReg{}$ to erase all the $\revoked$ regions from the world.

To a large extent, the definition of $\lrhname$ is pretty standard.
$\lrhname$ assumes the existence of a partitioning of the \trgcm{} and \srccm{} heap memories that can be turned into memory segment pairs each satisfying the invariant of a region.
The heap satisfaction must also respect the world as an authority specification, so the heap satisfaction partitions the authority of the world using $\oplus$.
Each of the memory segment pairs must be in the region invariant with respect to a specific world partition which makes sure that uniqueness of linearity of capabilities is respected.

The heap sub-world contains all seal invariants.
Similar to memory segments, only one seal invariant should impose restrictions on a seal, which $\lrhname$ makes sure is the case.
\begin{definition}[Free stack relation]
\label{def:free-stack-rel}
\[
  \memSatFStack{\src{\ms_\stk},\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \gc = (\_,\stkb,\_,\_) \wedge\\
      W_\var{stack} = \pwfree \wedge \\
      \exists R_\ms : \dom(\activeReg{W_\var{stack}}) \fun \MemSeg \times \MemSeg \wedge \\
      \quad \ms_T = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_2(R_\ms(r)) \wedge \\
      \quad \src{\ms_\stk} = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_1(R_\ms(r)) \wedge \\
      \quad \stkb \in \dom(\ms_T) \wedge \stkb \in \dom(\src{\ms_\stk}) \wedge \\
      \quad \exists R_W : \dom(\activeReg{W_\var{stack}}) \fun \World\ldotp\\
      \qquad W = \bigoplus_{r \in \dom(\activeReg{W_\var{stack}})} R_W(r) \wedge\\
      \qquad \forall r \in \dom(\activeReg{W_\var{stack}}),n' < n \ldotp \\
      \qquad \quad \npair[n']{R_\ms(r)} \in  W_\var{stack}(r).H \; \xi^{-1}(R_W(r))
    \end{array}
  \right.
\]
\end{definition}
The free stack relation $\lrfree[]$ is in most regards like the heap relation, $\lrhname{}$.
The free stack relation, partitions the \srccm{} and \trgcm{} free stack memory, it partitions the authority of the world, and it requires the memory segment pairs to be related under part of the world.
For \stktokens{} to work, it should always work on the same stack.
As discussed in \sectionname~\ref{sec:stktokens-explained}, we make sure that it is always the same stack by requiring the address $\stkb$ to be the ''top'' address of the free stack address space.
As the free stack relation relates the stack of \srccm{} with the memory that represents the stack on \trgcm{}, it makes sure that $\stkb$ is the top address of the free stack address space.
\begin{definition}[Stack relation]
  \label{def:stack-rel}
\[
  \memSatStack{\src{\stk},\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \exists m, \src{\opc_0},\dots,\src{\opc_m}, \src{\ms_0}, \dots, \src{\ms_m}, W_\var{stack}\ldotp\\
      \quad\gc = (\_,\stkb,\_,\_) \wedge \\
      \quad W_\var{stack} = \pwpriv \wedge \\
      \quad\src{\stk} = \src{(\opc_0,\ms_0), \dots (\opc_m,\ms_m)} \wedge \\
      \quad\forall i \in \{0,\dots,m\} \ldotp (\dom(\src{\ms_i}) \neq \emptyset \wedge\\
      \quad\quad \forall j < i \ldotp \forall a \in \dom(\src{\ms_i}) \ldotp \forall a' \in \dom(\src{\ms_j}) \ldotp \stkb < a < a') \wedge\\
      \quad\exists R_\ms : \dom(\activeReg{W_\var{stack}}) \fun \MemSeg \times \Addr \times \MemSeg \ldotp \\
      \quad\quad \ms_T = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_3(R_\ms(r)) \wedge \\
      \quad\quad \src{\ms_0} \uplus \dots \uplus \src{\ms_m} = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_1(R_\ms(r)) \wedge \\
      \quad\quad \exists R_W : \dom(\activeReg{W_\var{stack}}) \fun \World \ldotp \\
      \quad\qquad W = \bigoplus_{r \in \dom(\activeReg{W_\var{stack}})} R_W(r) \wedge \\
      \quad\qquad \forall r \in \dom(\activeReg{W_\var{stack}}), n' < n\ldotp \\
      \quad\qquad \quad \npair[n']{(\pi_1(R_\ms(r)),\pi_3(R_\ms(r))} \in W_\var{stack}(r).H \; \xi^{-1}(R_W(r)) \wedge\\
      \quad\qquad \quad \pi_2(R_\ms(r)) = W_\var{stack}(r).\opc \wedge\\
      \quad\qquad \quad \exists i \ldotp \src{\opc_i} = W_\var{stack}(r).\opc \wedge \src{\ms_i} = \pi_1 (R_\ms(r))
    \end{array}
  \right.
\]
\end{definition}
The stack relation $\lrstk[]$ is similar to the heap relation in some ways.
The $\lrstk[]$ relation also partitions the \trgcm{} memory but only the \trgcm{} as the \srccm{} partitions are given as the stack frames.
The stack relation also partitions the authority of the world, so it can relate the stack frames in a way that respect linearity.
The stack on \srccm{} represents the call stack which means that each stack frame corresponds to a call and its local data.
The operational semantics of \trgcm{} does not have a built-in stack, so we emulate it by requiring that a stack like data structure resides in \trgcm{} memory.
That is for a memory segment that represents a stack frame, all the addresses of memory frames lower in the stack should have strictly smaller memory addresses.
Further, the stack frames should be in the part of the memory we agree to be the stack which means that the addresses should be smaller than $\stkb$.
Informally, this just means that the stack should be laid out in memory as a downwards growing stack with no addresses below $\stkb$.

According to \stktokens{} (described in \sectionname~\ref{sec:stktokens-explained}), stack frames must be non-empty, so they are distinguishable from a missing stack frame.
For this reason, $\lrstk[]$ requires every stack frame to be non-empty.
Note that each stack frame corresponds to a trusted call.
Untrusted calls are not protected which means that untrusted stack frames reside in the free stack memory (this does not mean that the untrusted stack frames are necessarily unprotected; it only means that they are not natively protected by \stktokens{}).
This means that the protected stack frames are not necessarily packed tightly in memory, and the memory in between is part of the free stack.
The free stack in between stack frames may be used by untrusted code for their local stack frames (Untrusted stack frames are not protected by \srccm{}, but this does not prevent untrusted code from securing their own stack frames).
\figurename~\ref{fig:mem-sketch} sketches this.

Each stack frame in the \srccm{} stack contains an old program pointer which corresponds to the old program counter recorded in the region of the world associated with the stack frame.
To achieve this, the partition function $R_\ms$ also records an $\opc$ for each region, and this $\opc$ should establish the link between the region and the stack frame.
\begin{figure}
  \centering
  \begin{tikzpicture}[scale=.5, every node={scale=.5}]
 
  \scope
    \clip (-.1,-.1) rectangle (4.6,11.1);
    \fill[fill=white] (0,0) rectangle (4.5,11);
    \draw (0,0) -- (0,11);
    \draw (4.5,0) -- (4.5,11);
  \endscope
  \draw (-1,0) node {};
  \draw (-1,12) node {};

  \draw[pattern=north west lines,draw=none] (0,0) rectangle (4.5,2);
  \draw[pattern=north west lines,draw=none] (0,9.5) rectangle (4.5,11);

  \draw[pattern=none] (0,2) rectangle (4.5,4);
  \draw[pattern=bricks] (0,4) rectangle (4.5,5);
  \draw[pattern=none] (0,5) rectangle (4.5,6);
  \draw[pattern=bricks] (0,6) rectangle (4.5,7.5);
  \draw[pattern=none] (0,7.5) rectangle (4.5,8.5);
  \draw[pattern=bricks] (0,8.5) rectangle (4.5,9.5);

  \draw (5.75,2.25) node[anchor=west] {\footnotesize $\stkb$};
  \draw (5.75,2.25) edge[-latex] (4.75,2.25);
  \draw (5,9.5) edge[-latex] (5,8);
%  \draw [decorate,decoration={brace,amplitude=7pt,mirror,raise=4pt},yshift=0pt] (-0.25,9.5) -- (-0.25,2) node [black,midway,xshift=-1cm,yshift=0.05cm,rotate=45] {stack};
  \draw [-|] (-0.5,9.5) edge (-0.5,2);
  \draw (-0.75,5.75) node[anchor=east] [black] {stack};
  \matrix [draw,below right] at (current bounding box.north east) {
    \node[pattern=north west lines,minimum size=0.4cm,draw,label=right:{\footnotesize Heap ($\ms$)}] {}; \\
    \node[minimum size=0.4cm,draw,label=right:{\footnotesize Free stack ($\ms_\stk$)}] {}; \\
    \node[pattern=bricks,minimum size=0.4cm,draw,label=right:{\footnotesize Encapsulated stack frame ($\stk$)}] {}; \\
};

  \end{tikzpicture}
  \caption{A sketch of how heap, encapsulated stack and free stack are laid out in memory.
    The encapsulated stack frames and the free stack constitutes the stack.
    The encapsulated stack frames may have free stack in between them where stack frames of non-trusted code may reside.
    The stack grows downwards in memory with $\stkb$ as the top address (and the base address of the free stack capability).}
  \label{fig:mem-sketch}
\end{figure}

In order to tie Definitions~\ref{def:heap-rel},~\ref{def:free-stack-rel},~and~\ref{def:stack-rel} together, we define memory satisfaction.
Memory satisfaction defines when a \srccm{} memory, consisting of a heap, a stack, and a free stack, relates to a \trgcm{} memory under a world.
\begin{definition}[Memory satisfaction]
  For memory segments $\ms_S$, $\ms_\stk$, and $\ms_T$, stack $\stk$, and world $W$ we define memory satisfaction as
\[
  \memSat{\src{\ms_S},\src{\ms_\stk},\src{\stk},\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \exists m,  \src{\opc_0}, \dots \src{\opc_m}, \src{\ms_0}, \dots, \src{\ms_m}, W_{\var{stack}}, W_{\var{free\_stack}}, W_{\var{heap}} \ldotp\\
      \quad \src{\stk} = \src{(\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)} \wedge \\
      \quad \src{\ms_S} \# \src{\ms_\stk} \# \src{\ms_0} \# \dots \# \src{\ms_m} \wedge\\
      \quad W = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}} \wedge\\
      \quad\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}, \ms_{T,f}, \src{\ms_{S,f}}, \src{\ms_S'},\overline{\sigma}\ldotp \\
      \qquad \src{\ms_S} = \src{\ms_{f,S}} \uplus \src{\ms_S'} \wedge \\
      \qquad \ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus \ms_\var{T,heap} \uplus \ms_{T,f} \wedge \\
      \qquad \dom(\ms_{\var{T,stack}} \uplus \ms_\var{T,free\_stack}) = [\baddr_\stk,\eaddr_\stk] \wedge \\
      \qquad \baddr_\stk -1,\eaddr_\stk + 1 \in \dom(\ms_{T,f}) \wedge \\
      \qquad \memSatStack{\src{\stk},\ms_\var{T,stack}}{W_{\var{stack}}} \wedge \\
      \qquad \memSatFStack{\src{\ms_\stk},\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}} \wedge \\
      \qquad \npair{(\overline{\sigma},\src{\ms_S'},\ms_\var{T,heap})} \in \lrheap(\pwheap)(W_{\var{heap}})
    \end{array}
  \right.
\]
\end{definition}
Memory satisfaction partitions the \trgcm{} memory in a heap, stack frames, a free stack and a frame.
The \srccm{} heap is split in two: the active heap and a frame.
Our configurations describe the complete machine state, but we may only be interested in the invariants on part of it.
The frame allows us to ignore the part of the memory that won't affect the computation.
Just like the previous memory relations, the world is split in three to make sure that linearity is respected.
Each part of the \srccm{} memory is related to the appropriate part of the memory from \trgcm{} by the relevant relation under a partition of the world.

\stktokens{} requires the stack to not be adjacent to heap or code memory.
This is enforced in the memory satisfaction by requiring that the addresses adjacent to the memory are in the frame.

% TODO take a look at notation and naming in this section. What do we want to call things
% TODO look over the original POPL paper to make sure to reuse all the text that makes sense to reuse.
\end{jversion}


\subsection{Constructing Worlds: Solving the Recursive Domain Equation}
\label{sec:rec-dom-eq}
In the previous sections, we sketched what our worlds should be.
However, the worlds we want constitute a self-referential domain equation for which no solution exists in set and domain theory.
% Move to a different domain
Therefore, we need to move to a different domain with enough structure for a solution to exist for recursive equations.
Solutions to recursive domain equations can be found using standard techniques~\citep{scott_1976,america_1989,Birkedal:2011:SKM:1926385.1926401}.
Essentially, we move to a setting where instead of sets we have c.o.f.e.'s (complete ordered families of equivalences), instead of functions we have non-expansive functions, and instead of relations we have downwards-closed relations.
A c.o.f.e.\ can be thought of as a set with added structure, specifically a step-indexed notion of equality and a limit to every Cauchy sequence (i.e.\ they are complete in a similar sense as to how the real numbers are complete but the rationals are not).

Explaining the construction of the world in detail would require a recap of the basic theory of c.o.f.e.'s.
For conciseness, we choose to not include this here, but instead refer to the PhD thesis of Skorstengaard \cite[\S 3.5]{skorstengaard_thesis_2019}, which includes a detailed explanation.
We only include the main result, which is the following theorem, asserting the existence of a World c.o.f.e.\ satisfying the recursive equation we encountered before.

% In this section, we explain our solution of the world equation.
% To make this paper self-contained, we include a recap of relevant concepts and theorems from the literature on c.o.f.e.'s.
% This section does not provide further intuition about the worlds and can be safely skipped.

% Recursive domain equations are so common and the solution so standard that frameworks implement them to lift the technical burden of constructing the world by hand.
% The technique we use to solve our recursive domain equation is essentially the same as what is used internally in the program logic framework Iris~\citep{iris,iris2,iris3} to construct worlds.
% We believe the worlds presented here could be developed in Iris.
% Had we done the development in Iris Coq, then we would have had the world tool support of Iris and the rigorousness of Coq which, in hindsight, would have been very beneficial.

% % Cofe's
% In this section, we explain how the world is constructed in detail (readers willing to trust us can safely skip to Section~\ref{subsubsec:joining-worlds}).
% To explain this, we present complete ordered family of equivalences \citep{di_gianantonio_2002}.
% We loosely follow the presentation in \citet{birkedal_taste_2014} and introduce the necessary definitions needed for our particular world.
% \begin{definition}[Ordered family of equivalences (o.f.e.)]
% An \emph{ordered family of equivalences} is a pair $\cofe{X}$ where $X$ is a set and $\nequal$ is an equivalence relation for each $n$.
% The pair must satisfy the following properties:
% \begin{enumerate}
% \item $\nequal[0]$ is the total relation.
% \item For all $n \in \nats$, $\nequal[n] \supseteq \nequal[n+1]$.
% \item For all $x,y \in X$,  if for all $n \in \nats$ $x \nequal y$, then $x = y$.
% \end{enumerate}
% \end{definition}
% \noindent An o.f.e.\ can be thought of as a set with extra structure.
% Intuitively, the index on the family of equivalences is a measure of precision.
% The larger the index is, the more refined the equivalences are which means that they can distinguish more elements from one another.
% On the other hand as the index decreases, the equivalences become increasingly imprecise and unable to distinguish certain elements.
% At index 0, all precision is lost and the equivalence cannot distinguish anything.
% \dominique{Introduce phrases like ``up to n steps'' etc.}
% \begin{definition}[Complete ordered family of equivalences (c.o.f.e.)]
%   \label{def:cauchy-sequence}
%   A \emph{complete ordered family of equivalences} is an ordered family of equivalences
%   $\cofe{X}$ such that every Cauchy sequence in $X$ has a limit
%   in $X$.

%   Let $\cofe{X}$ be an o.f.e. and $\seq{x}$ be a sequence of
%   elements in $X$. Then $\seq{x}$ is a \emph{Cauchy sequence} if
%   \begin{align*}
%     \forall k \in \nats, \exists j \in \nats, \forall n \geq j, x_j \nequal[k] x_n
%   \end{align*}
%   or in words, the elements of the chain get arbitrarily close.

%   An element $x \in X$ is the \emph{limit} of the sequence $\seq{x}$ if
%   \begin{align*}
%     \forall k \in \nats, \exists j \in \nats, \forall n \geq j, x \nequal[k] x_n.
%   \end{align*}
% \end{definition}
% In order to move from one c.o.f.e.\ to another, we define functions, just like we would when working with sets.
% Unlike functions between sets, functions between c.o.f.e.'s must preserve the c.o.f.e.\ structure which informally means that the measure of precision must be retained.
% This specifically means that functions between c.o.f.e.'s must be \emph{non-expansive} which basically means that they preserve $n$-equalities.
% Functions may not only retain equivalences but make it more precise.
% Such a function is said to be \emph{contractive}.
% \begin{definition}
%   \label{def:nonexpansive-contractive-ofe}
%   Let $\left(X,\left(\nequal[n]_X\right)_{n=0}^{\infty} \right)$ and $\left(Y,\left(\nequal[n]_Y\right)_{n=0}^{\infty} \right)$ be two ordered families of equivalences and $f$ a function from the set $X$ to the set $Y$.
%   The function $f$ is
%   \begin{description}
%   \item[non-expansive] when for all $x, x' \in X$, and all $n \in \nats$,
% \[
%   x \nequal_X x' \implies f(x) \nequal_Y f(x')
% \]
%   \item[contractive] when for any $x, x' \in X$, and any $n \in \nats$,
% \[
%   x \nequal_X x' \implies f(x) \nequal[n+1]_Y f(x') 
%   \qedhere
% \]
%   \end{description}
% \end{definition}
% \noindent The step-indexing provided by c.o.f.e.'s give enough structure to solve the recursive domain equation.
% There are a number of standard c.o.f.e.\ constructions for countably sets, products, sums, and functions.
% A set can be lifted to c.o.f.e.\ by having the normal equality for all positive indices and the total relation for $\nequal[0]$.
% The other standard constructions are defined naturally and compose new c.o.f.e.'s from existing c.o.f.e.'s.

% In some sense, the standard c.o.f.e.\ constructions maintain the precision of the underlying c.o.f.e.'s.
% This, however, does not utilise the c.o.f.e.\ structure in a way that allows us to construct a solution for a recursive domain equation.
% Intuitively, the step of the c.o.f.e.\ needs to go down before the recursive occurrence.
% To this end, we have the \emph{later} ($\blater$) c.o.f.e.:
% \begin{lemma}[$\blater$ c.o.f.e.]
%   \label{def:later-cofe}
%   Given a c.o.f.e $\left(X, \left(\nequal_X\right)_{n=0}^{\infty} \right)$ define the later c.o.f.e.\ as
%   \[
%     \blater\left(X, \left(\nequal_X\right)_{n=0}^{\infty} \right) = \left(X, \left(\nequal[n]_{\blater}\right)_{n=0}^{\infty} \right)
%   \]
%   where
%   \[
%     x \nequal[n]_{\blater} x' \text{ iff } \left\{
%       \begin{array}{l}
%         n = 0 \text{ or }\\
%         x \nequal[n-1]_X x'
%       \end{array}
%     \right. \qedhere
%   \]
% \end{lemma}
% The later c.o.f.e.\ should be placed before the self-reference to make the index decrease. 
% Intuitively, this gives something to recurse on in order to find a solution for the domain equation.
% If we limit ourselves to a handful of standard constructions (product, sum, arrow, later, and partial functions from the natural numbers) to construct self-referential equations and make sure to guard every occurrence of the self reference with a later, then the equation has a solution.

% Unfortunately, the standard c.o.f.e.\ constructions do not suffice for the worlds we want to define.
% The worlds we sketched have additional structure in terms of a future world relation.
% The future world relation is captured by adding a preorder to c.o.f.e.'s:
% \begin{definition}[Preordered c.o.f.e.]
%   A preordered c.o.f.e.\ is a c.o.f.e.\ equipped with a preorder on $X$, $\left(X, \left(\nequal\right)_{n=0}^{\infty}, \future \right)$. 
%   \begin{itemize}
%   \item The ordering preserves limits. That is, for Cauchy sequences $\{a_n\}_n$ and $\{b_n\}_n$ in $X$ if $\{a_n\}_n \future\{b_n\}_n$, then $\lim \{a_n\}_n \future \lim \{b_n\}_n$.
%   \end{itemize}
% \end{definition}
% The preorder must respect the existing structure of the c.o.f.e.'s which means that it must preserve limits.
% There are also natural constructions for preordered c.o.f.e.'s that rely on the underlying preorder.
% We will need the standard construction for later, product, and sum (defined in \appendixname~\ref{app:cofe}).

% Sometimes we will refer to c.o.f.e.'s and preordered c.o.f.e.'s simply by their underlying set.

% In the following, we will define a number of preordered c.o.f.e.'s that can be combined to get our world equation.
% First, we define the c.o.f.e.\ for the memory invariants (we do not need a preorder here).
% As a reminder, we sketched the memory invariants to as follows
% \[
%   \World \monfun \Rel{\MemSeg \times \MemSeg}
% \]
% To construct this, we need to define a c.o.f.e.\ for the relation and a c.o.f.e.\ for the monotone and non-expansive functions.
% We do not need a construction for the world as it will be given as the solution to the recursive equation.
% Generally, we can lift a set of relations to a c.o.f.e.\ by adding a downwards closed index to it.
% This means that if a pair is in the relation for a specific index, then it is also in the relation for all smaller indices.
% %% URel
% \begin{definition}[Uniform relation]
%   \label{def:uniform-rel-cofe}
%   Given a set $R = X \times Y$, we define $\URel{R} \subseteq \powerset{\nats \times R}$ as
%   \[
%     \URel{R} = \{ A \in \powerset{\nats \times R} \mid \forall n \in \nats \ldotp \forall r \in R \ldotp \npair{r} \in A \implies \forall m \leq n \ldotp \npair[m]{r} \in A\}
%   \]
%   The uniform relation c.o.f.e.\ $\cofe{\URel{R}}$ has $\URel{R}$ as the underlying set and the following family of equivalences:
%   \[
%     A \nequal B \text{ iff } \erasen{A}{n} = \erasen{B}{n}
%   \]
%   where erasure is defined as
%   \[
%     \erasen{A}{n} \defeq \{(k,a) \in A \mid k < n\}
%   \]
%   to get a preordered c.o.f.e.\ we use subset as the preorder.
% \end{definition}
% The uniform relation construction uses the canonical family of equivalences which basically ignores everything from the step up and requires the rest to be equal.
% This means that everything is equal at step $0$ as everything is left out.

% Next, we define a c.o.f.e.\ of monotone, non-expansive functions
% \begin{definition}[The c.o.f.e. of monotone and non-expansive functions]
% \label{def:monnefun-cofe}
%   Given a preordered c.o.f.e. $\left(W,\left(\nequal[n]_W\right)_{n=0}^{\infty},\future_W\right)$ and a preordered c.o.f.e.\ $\left(U,\left(\nequal[n]_U\right)_{n=0}^{\infty},\future_U\right)$ , define the c.o.f.e.\ $\left(W \monnefun U,\left(\nequal[n]\right)_{n=0}^{\infty}\right)$ where 
%   \[
%     h \nequal h' \text{ iff } \forall w \in \dom(h) \ldotp h(w) \nequal_U h'(w)
%   \]
% \end{definition}
% In order to construct the memory invariant, we use Definition~\ref{def:monnefun-cofe} with the world solution as the $W$ c.o.f.e.\  and a uniform relation over pairs of memory segments (Definition~\ref{def:uniform-rel-cofe}) as the $U$ c.o.f.e.

% Next, we construct the seal invariant.
% As a reminder, we sketched the seal invariant as
% \[
%   \Seal \parfun \World \monnefun \URel{\SealableCaps\times\SealableCaps}
% \]
% In order to define the c.o.f.e. for this, we can use Definitions~\ref{def:uniform-rel-cofe} and~\ref{def:monnefun-cofe}.
% This leaves us with the task of lifting the set of seals to a c.o.f.e.\ and defining the c.o.f.e.\ partial functions.
% Generally, all countable sets can be lifted to a c.o.f.e.\ with a family of equivalences that has full precision for all indices except index 0.
% \begin{definition}[Sets to c.o.f.e.]
%   \label{def:lift-set-cofe}
%   A countable set $S$ can be lifted to a c.o.f.e. $\cofe{S}$ where
%   \begin{itemize}
%   \item $\nequal[0]$ is the total relation
%   \item for $n > 0$ the relation $\nequal$ is the normal equality on the set
%   \end{itemize}
% \end{definition}
% This definition can be used to lift the set of all seals $\Seal$ to a c.o.f.e.

% The c.o.f.e.\ of partial, non-expansive functions is defined similarly to the c.o.f.e.\ of monotone non-expansive functions.
% \begin{definition}[The c.o.f.e. of partial, non-expansive functions]
% \label{def:parfun-cofe}
%   Given a c.o.f.e. $\left(S,\left(\nequal[n]_S\right)_{n=0}^{\infty}\right)$ and a c.o.f.e.\ $\left(H,\left(\nequal[n]_H\right)_{n=0}^{\infty}\right)$ , define the c.o.f.e.\ $\left(S \parfun H,\left(\nequal[n]\right)_{n=0}^{\infty} \right)$ where 
%   \[
%     h \nequal h' \text{ iff } \dom(h) = \dom(h') \wedge \forall w \in \dom(h) \ldotp h(w) \nequal_H h'(w)
%   \]
% \end{definition}
% The seal invariant is defined using Definition~\ref{def:lift-set-cofe} to lift $\SealableCaps$ to a c.of.e.\, defining a c.o.f.e.\ similar to the one for memory invariants, and finally combining the two with Definition~\ref{def:parfun-cofe}.

% Next, we want to define the regions of the world.
% As mentioned, our regions have the added structure of the future region relation, so we need to define them as a preordered c.o.f.e.
% The future region was presented in Section~\ref{subsubsec:ft-and-revocation}.
% On shared regions, the relation is equality which makes it straight forward to define:
% \begin{definition}[Shared region preordered c.o.f.e.\ ]
%   \label{def:pure-reg-p-cofe}
%   Given two c.o.f.e.'s $\left(\var{MemInv},\left(\nequal[n]_\var{MI}\right)_{n=0}^{\infty}\right)$ and $\left(\var{SealInv},\left(\nequal[n]_{\var{SI}}\right)_{n=0}^{\infty}\right)$, define the preordered c.o.f.e.\ of shared regions as
%   \[
%   \left(\{\pure\}\times \var{MemInv} \times \var{SealInv},\left(\nequal[n]\right)_{n=0}^{\infty},=\right)
%   \]
%   where the family of equivalences distributes to the underlying c.o.f.e.'s, i.e. given shared regions $(\pure,H,H_\sigma), (\pure,H',H_\sigma') \in \{\pure\}\times \var{MemInv} \times \var{SealInv}$,
%   \[
%   (\pure,H,H_\sigma) \nequal (\pure,H',H_\sigma') \text{ iff } H \nequal_\var{MI} H' \wedge H_\sigma \nequal_{SI} H_\sigma'
%   \]
% \end{definition}
% Definition~\ref{def:pure-reg-p-cofe} gives us the shared region for preorder c.o.f.e.\ when we use it with the memory invariant c.o.f.e.\ as $\var{MemInv}$ and the seal invariant c.o.f.e.\ as $\var{SealInv}$.

% Next, we define the preordered c.o.f.e.\ for spatial regions.
% The future region relation on spatial regions is non-trivial, so the definition of the preordered c.o.f.e.\ is slightly more involved.
% \begin{definition}[Spatial region preordered c.o.f.e.\ ]
%   \label{def:spatial-reg-p-cofe}
%   Given two c.o.f.e.'s $\left(\var{MemInv},\left(\nequal[n]_\var{MI}\right)_{n=0}^{\infty}\right)$ and $\left(\var{MemInv'},\left(\nequal[n]_\var{MI'}\right)_{n=0}^{\infty}\right)$, let
%   \[
%     \Regions = \{\spatial\}\times \var{MemInv} \cup \{\spatialo\} \times \var{MemInv'} \cup \{\revoked\}
%   \]
%   define the preordered c.o.f.e.\ of shared regions as
%   \[
%   \left(\Regions,\left(\nequal[n]\right)_{n=0}^{\infty},\future\right)
%   \]
%   where the preorder $\future$ is defined as
%   \begin{mathpar}
%   \inferrule{ r \in \Regions }{ r \future r }
%   \and
%   \inferrule{ }{ \revoked \future (\spatial,\_)}
%   \and
%   \inferrule{ }{ (\spatialo,H) \future (\spatial,H)}
%   \end{mathpar}
%   and $\left(\nequal[n]\right)_{n=0}^{\infty}$ is the total relation for $n=0$ and otherwise the region tags must be the same and the memory invariants $n$-equal, i.e.\ 
%   for $r ,r' \in \Regions$ we have $r \nequal r'$ when one of the following holds
%   \begin{itemize}
%   \item $n=0$
%   \item $n > 0$ and one of the following is true
%     \begin{itemize}
%     \item $r = r' = \revoked$
%     \item $r = (\spatial,H)$, $r' = (\spatial,H')$, and $H \nequal_\var{MI} H'$
%     \item $r = (\spatialo,H)$, $r' = (\spatialo,H')$, and $H \nequal_\var{MI'} H'$
%     \end{itemize}
%   \end{itemize}
% \end{definition}
% Definitions~\ref{def:pure-reg-p-cofe} and~\ref{def:spatial-reg-p-cofe} define the preordered c.o.f.e.'s necessary for the regions in our worlds.

% Next, we need to define the three sub-worlds for heap, encapsulated stack frames, and free stack.
% The definitions of the sub-worlds are very similar, so we can capture the essence of all three sub worlds in one definition.
% \begin{definition}[Sub-world preordered c.o.f.e.]
%   \label{def:sub-world-p-cofe}
%   Given preordered c.o.f.e. $\left(\var{Reg},\left(\nequal[n]_\var{Reg}\right)_{n=0}^{\infty},\future_\var{Reg}\right)$ define the sub-world preordered c.o.f.e.\ as
%   \[
%     \left(\nats \parfun \var{Reg},\left(\nequal[n]\right)_{n=0}^{\infty},\future \right)
%   \]
%   where the family of equivalences is defined by given $W,W' \in \nats \parfun \var{Reg}$,
%   \[
%     W \nequal W' \text{ iff } \dom(W) = \dom(W') \wedge \forall r \in \dom(W)\ldotp W(r) \nequal W'(r)
%   \]
%   and the future world relation is defined by given $W,W' \in \nats \parfun \var{Reg}$,
%   \[
%   W' \future W \text{ iff } \left\{
%     \array{l}
%     \exists m : \RegionName \fun \RegionName, \text{ injective}\ldotp\\
%     \quad \dom(W') \supseteq \dom(m(W)) \wedge \forall r \in \dom(W)\ldotp W'.i(m(r)) \future W(r)
%      \endarray
%   \right.
% \]
% \end{definition}
% The free stack sub-world preordered c.o.f.e.\ is constructed from the spatial region preordered c.o.f.e.\ (Definition~\ref{def:spatial-reg-p-cofe}) and the general sub-world construction in Definition~\ref{def:sub-world-p-cofe}.
% The result is the sub-world for the free stack
% \[
%   \Worldfs = \nats \parfun \Regions
% \]

% Next, we define the call stack sub-world.
% To this end, we use Definition~\ref{def:spatial-reg-p-cofe} to get the spatial region which we need to combine this with an address.
% We lift the set of addresses to a preordered c.o.f.e.\ $A$ (Definition~\ref{def:lift-set-cofe} with equality as the preorder) and combine the preordered c.o.f.e.'s $\Addr$ and $\Regions$ with the standard product construction.
% All in all, we get the a preordered c.o.f.e.\
% \[
%   \Regions \times \Addr
% \]
% which we use with Definition~\ref{def:sub-world-p-cofe} to get the preordered c.o.f.e.\ for the stack sub-world:
% \[
%   \Worlds = \nats \parfun \Regions \times \Addr
% \]

% Finally, we define the sub-world for the heap.
% To this end, we combine the shared region preordered c.o.f.e.\ (Definition~\ref{def:pure-reg-p-cofe}) with the spatial region preordered c.o.f.e.\ (Definition~\ref{def:spatial-reg-p-cofe}) using the standard union preordered c.o.f.e.\ construction.
% The result is a preordered c.o.f.e.\
% \[
%   \Regions \cup \Regionh
% \]
% which we use in the sub-world construction (Definition~\ref{def:sub-world-p-cofe}) to obtain the preordered c.o.f.e.\
% \[
%   \Worldh = \nats \parfun (\Regions \cup \Regionh)
% \]

% With the three sub-worlds defined, we combine them with the standard product construction for preordered c.o.f.e.'s to get our worlds.
% \[
%   \Worldh \times \Worlds \times \Worldfs
% \]
% This is the world, we would like to work with, but we still don't have a solution for the recursive domain equation.
% In fact, when we defined the regions, we just left world-index in the memory and seal invariants as an unspecified variable, which means that the above world has them as a variable.
% In order to find a solution, we still need to guard the recursive occurrence.
% To this end, we simply use the construction for later preordered c.o.f.e.'s in Definition~\ref{def:later-p-cofe} with the above to get.
% \[
%   \blater (\Worldh \times \Worlds \times \Worldfs)
% \]
% Now the recursive occurrence is guarded which means that there is a solution to the recursive domain equation.
\begin{theorem}
  \label{thm:rec-dom-eq-sol}
  There exists a complete ordered family of equivalences (c.o.f.e.) $\Wor$ and preorder $\future$ such that $(\Wor,\future)$ is a preordered c.o.f.e., and there exists an isomorphism $\xi$ such that
  \[
    \xi : \Wor \cong \blater (\Worldh \times \Worlds \times \Worldfs)
  \]
  and for $\hat{W},\hat{W}' \in \Wor$
  \[
    \hat{W}' \future \hat{W} \text{ iff } \xi(\hat{W}') \future \xi(\hat{W})
  \]
  for $\Worlds$, $\Worldh$, and $\Worldfs$ defined as follows
\[
  \Worldh = \RegionName \parfun (\Regions \cup \Regionh)
\]
and
\[
  \Worlds = \RegionName \parfun (\Regions \times \Addr)
\]
and
\[
  \Worldfs = \RegionName \parfun \Regions
\]
where $\RegionName = \nats$. $\Regions$ and $\Regionh$ defined as follows
\begin{multline*}
  \Regionh = 
  \{\pure \} \times (\Wor \monnefun \URel{\MemSeg\times\MemSeg}) \times \\
  (\Seal \parfun \Wor \monnefun \URel{\SealableCaps\times\SealableCaps})
\end{multline*}
and
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial, \spatialo\} \times (\Wor \monnefun \URel{\MemSeg\times\MemSeg}) \cup\\
    \{\revoked\}
  \end{array} \right.
\]
\end{theorem}
Theorem~\ref{thm:rec-dom-eq-sol} uses the method of~\citet{Birkedal:2011:SKM:1926385.1926401,birkedal_taste_2014} to construct the solution $\Wor$ to the recursive equation.
Note, that $\Wor$ is not equal to $\blater (\Worldh \times \Worlds \times \Worldfs)$; it is isomorphic.
This means that whenever we encounter $\Wor$, we have to apply $\xi$ and go under a later before we can actually use the world.
This makes it rather inconvenient to have $\Wor$ as the world, so instead we define the worlds as 
\[
  \World = \Worldh \times \Worlds \times \Worldfs
\]

%% Lau: not sure whether the following remarks should be included:
% Note that the later placement could have been different as it just needs to guard the recursive occurrence at some level.
% It could, for instance, have been directly on the recursive occurrence.
% By moving the later, we would also move the place we have to go under the later in our later definitions affecting how it is working with them.

% In worlds that has a simple future world relation and no future region relation, it may be an advantage to define the regions in terms of a self-referential equation, solve that, and define the worlds with the solution.
% The advantage of this approach is that it can be done entirely in c.o.f.e.'s.





\subsection{The Logical Relation}
\begin{jversion}
\label{subsec:logical-relation}
Using these Kripke worlds as assumptions, we can then define when different \srccm{} and \trgcm{} entities are related: values, jump targets, memories, execution configurations, components etc.
The most important relations are summarised in the following table, where we mention the general form of the relations, what type of things they relate and extra conditions that some of them imply:\\
% latex hack stolen from https://tex.stackexchange.com/questions/78788/align-equations-over-multiple-tabular-rows
% Lau: I find it difficult to easily see what constitutes a row in this table.
% I have updated it to a table I find easier to read.
\newcolumntype{R}{>{$}r<{$}}
\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{M}{R@{${}\in{}$}L}
\begin{tabular}{|M|c|p{4.8cm}|}
  \hline
  \multicolumn{2}{|c|}{General form} & Relates ... & and ...\\
  \hline
  \npair{(\src{w_S},w_T)} & \lrv(W) & values (machine words) & safe to pass to adversarial code\\
  \npair{(\src{w_S},w_T)} & \lrvtrusted(W) & values (machine words) & \\
  \npair{(\src{\reg_S},\reg_T)}  &  \lrr(W) & register files & safe to pass to adversarial code\\
  \npair{\src{\Phi_S},\Phi_T}  &  \lro & execution configurations & \\
  \npair{(\src{w_S},w_T)}  &  \lre(W) & $\tjmp{}$ targets &\\
  \left(\arraycolsep=1pt\array{l}(\src{w_{S,1}},\src{w_{S,2}}),\\(w_{T,1},w_{T,2})\endarray\right)  &  \lrexj(W) & $\txjmp{}{}$ targets &\\
  \multicolumn{2}{|c|}{$\memSat{\src{\ms_S},\src{\stk},\src{\ms_\stk},\ms_T}{W}$} & memory & satisfy the assumptions in $W$\\
  \hline
\end{tabular}\\
In Section~\ref{subsubsec:mem-sat}, we already defined memory satisfaction, the relation for memories.
In the following, we define each of the remaining relations and give some intuition about the definitions.
The logical relation we define ends up as a cyclic definition.
The circularity is resolved by another use of step-indexing in the definitions, but the circularity also poses a chicken and egg problem with respect to the order in which the definitions of the relations should be presented.
There is no canonical way of presenting the logical relation as we are bound to make forward references.
For this reason, we suggest making a cursory first read through to get an overview followed by a more thorough read.
% TODO something about relation naming?

\subsubsection{Observation relation}
The observation relation defines what machine configurations have related and permissible observable effects.
Generally speaking, an observation relation captures the property we want to prove.
Ultimately, we want to prove a full-abstraction theorem which is defined in terms of contextual equivalence for components that in turn is defined as co-termination in any context.
This means that the observation relation should capture co-termination.

So far, we have talked about the logical relation as though we define one.
However, we actually define two logical approximations that only differ in the observation relation.
We define a \srccm{} configuration to logically approximate a \trgcm{} configuration when the halting termination of the \srccm{} configuration implies the halting termination of the \trgcm{} configuration.
This also means that \srccm{} configurations that terminates by failing termination are related to any \trgcm{} configuration.
Intuitively, this is because the $\failed$ configuration signals that there was an attempt to break the guarantees of the capability machine.
For instance, a piece of code could have attempted to read from a part of memory it does not have access to, or a callee could have attempted to return out of order.
In both cases, we haven't defined a way to recover from such attempts to break the guarantees, so we are content with failure.
\begin{multline*}
  \lro[\preceq,(\ta,\stkb,\_,\_)] \defeq \\\left\{ \npair{\left(\array{l}\src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})},\\(\ms_T,\reg_T)\endarray\right)} \middle|
    \begin{array}{l}
      \forall i \leq n \ldotp \\
      \quad \src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})} \sterm[i]{\ta,\stkb} \\\qquad\Rightarrow (\ms_T,\reg_T) \term\\
    \end{array}
\right\}
\end{multline*}
The step-indexing plays a role here because we are only interested in \srccm{} configurations that terminate in $n$ or fewer steps.
However, if the \srccm{} configuration terminates successfully in $n$ steps, then the \trgcm{} configuration should just terminate in any number of step (possibly more than $n$ steps).
For the most part, it would make sense to require the \trgcm{} configuration to terminate in the same amount of steps as the \srccm{} configuration as they run in lockstep for most of the computation.
However, when it comes to calls and returns, the two configurations stop running in lockstep.
The \srccm{} configuration handles calls and returns in one step whereas \trgcm{} configurations need to execute each instruction of the call preparation as well as the return code.

We define a \trgcm{} configuration to approximate a \srccm{} configuration in a dual way to the above.
\begin{multline*}
  \lro[\succeq,(\ta,\stkb,\_,\_)] \defeq \\\left\{ \npair{\left(\array{l}\src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})},\\(\ms_T,\reg_T)\endarray\right)} \middle|
    \begin{array}{l}
      \forall i \leq n \ldotp \\ 
      \quad (\ms_T ,\reg_T) \term[i] \\\qquad\Rightarrow \src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})} \sterm{\ta,\stkb}
    \end{array}
\right\}
\end{multline*}
The remainder of our logical relation will be the same for both $\preceq$ and $\succeq$, so we will write $\square$ instead of the approximation.

\subsubsection{Value Relations}
The value relation relates \trgcm{} words to \srccm{} words.
The \srccm{} machine has special tokens that represent the stack capabilities and the return pointer components.
These tokens do not exist on \trgcm{}, but all of the tokens correspond to capabilities on \trgcm{}, and the value relation establishes the link between then.
\citet{skorstengaard_reasoning_2017} defines a logical relation that can be seen as a notion of capability safety.
When they define their value relation, they define based on the question ``What is the most an adversary can be allowed to do with this word without breaking memory invariants?''
This allows them to use the logical relation to reason about arbitrary (untrusted) programs.
We also want to be able to say something about arbitrary (untrusted) programs, but we also want to be able to say something about somewhat arbitrary trusted programs.
In our setting, a trusted program is a well-formed, reasonable program that follows the \stktokens{} calling convention, and an untrusted program is an arbitrary well-formed program.
In order for a trusted program to use \stktokens{}, it needs access to return seals, but we cannot allow untrusted programs access to the return seals.
A value relation based on what it is safe for an adversary to have should prohibit return seals, so such a relation cannot be used to reason about trusted programs.
For this reason, we define two value relations a trusted $\lrvname_{\trusted}$ and an untrusted $\lrvname_{\untrusted}$.
Anything safe for unstrusted programs is also safe to give to a trusted program, so the trusted value relation is defined as a super set of the untrusted value relation.

From time to time in this section, we will refer to safety of a capability or a word.
In some sense, our logical relation actually ends up as the definition of safety, so when we refer to a capability as \emph{safe} it is in an informal sense where it means that the capability cannot be used break memory invariants. 

In Figure~\ref{fig:value-relation}, we have sketched the two value relations.
This shows that for the most part, words on \srccm{} are related to words on \trgcm{} that are syntactical identical.
The only exception is stack pointers on \srccm{} that are related to linear capabilities on \trgcm{}.
Note that the return pointers of \srccm{} are not related to anything as it is never safe for any program, trusted or not, to have them.
The \srccm{} return pointers should only occur under a return seal, and they should only be used in a jump in which case the \srccm{} semantics transforms them to the capabilities they correspond to.

The value relation is defined in terms of a number of auxiliary definitions.
In the following, we introduce a number of \emph{standard regions} that express common requirements on memory. Based on the standard regions, we define what we call \emph{permission based conditions}, conditions that a capability with a specific permission must satisfy to be safe.

% The old section:
% Note first how we have two value relations, whose definitions are sketched in Figure~\ref{fig:value-relation}.
% The difference is that the untrusted value relation $\lrv(W)$ does not just express that the two values are related, but also that they are safe to pass to an untrusted adversary, i.e. they cannot be used to break LSE and WBCF.
% The trusted value relation does not have the latter requirement and is a superset of the former.

% Both relations trivially include numbers $(i,i)$ which are always related to themselves.
% The untrusted value relation also includes stack pointers and the underlying linear capability (with the same (non-executable) permission, range of authority, and current address), as well as syntactically equal memory capabilities, seals and sealed values, all under certain conditions involving the world $W$ and the capability's properties.

% Roughly, for stack capabilities, the omitted condition requires that the world contains a $\spatialo$ region governing this part of the stack.
% For memory capabilities $((\perm,\lin),\baddr,\eaddr,\aaddr)$, a region in the world must govern memory $[\baddr,\eaddr]$, either $\spatialo$ or $\pure$, depending on the linearity $\lin$ of the capability.
% If the capability is executable ($\perm \in \{\rx,\rwx\}$), then we additionally require that the governing region is a code region and that the two capabilities are related $\mathrm{jmp}$ targets, as expressed by the relation $\lre(W)$, in any future world (see below).

% Seals allocated to trusted code are related to themselves only by $\lrvtrusted(W)$, but other seals are in both value relations.
% Sealed values are in both relations essentially when the sealed values satisfy the relation that was registered for the seal in a region of the world.
% Additionally, when they are combined with any other pair of values related by that relation, they must be related as $\txjmp{}{}$ targets (i.e. in $\lrexj(W)$).
% Finally, capabilities to code memory are related to themselves in the trusted value relation ($\lrvtrusted(W)$) when there is an appropriate code region in the world.
% They are not in the untrusted value relation because the code memory contains copies of the return seals used by the code, which must not end up in the hands of an adversary.

\begin{figure}
  \centering
  \begin{align*}
  \lrv(W) ={} & \left\{ \npair{\stpair[.]{i}{i}} \;\middle|\; i \in \ints \right\}\cup \\ &
%
    \left\{
%    \begin{array}{l}
      \npair{\left(\src{\stkptr{\perm,\baddr,\eaddr,\aaddr}}, ((\perm,\linear),\baddr,\eaddr,\aaddr) \right)} \mid\dots
        % \perm \not\in \{\rx,\rwx\} \tand \\
        % % \perm = \noperm & \Rightarrow & \npair{(\linear,\baddr,\eaddr)} \in
        % % \lrp(W) \wedge \\
        % \quad\perm \in \{\ro,\rw\} \Rightarrow \npair{[\baddr,\eaddr]} \in \stackReadCond{W} \tand \\
        % \quad\perm = \rw  \Rightarrow \npair{[\baddr,\eaddr]} \in \stackWriteCond{W}
%    \end{array}
    \right\} \cup \\ &
%
    \left\{
%    \begin{array}{l}
      \npair{\left(\src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}}, \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \right)} \mid 
      % [\sigma_\baddr,\sigma_\eaddr] \mathrel{\#} (\sigrets \cup \sigcloss) \wedge 
                       \dots 
      % \quad\forall \sigma' \in [\sigma_\baddr,\sigma_\eaddr] \ldotp \exists r \in \dom(\pwheap) \ldotp \\
      % \quad \pwheap(r) = (\pure,\_,H_\sigma) \tand H_\sigma \; \sigma' \nequal (\lrv \circ \xi)
%    \end{array}
    \right\} \cup \\ &
        \left\{
%    \begin{array}{l}
      \npair{\left(\src{\sealed{\sigma,\vsc_S}}, \sealed{\sigma,\vsc_T} \right)} \mid \dots
      % \isLinear{\src{\vsc_S}} \text{ iff } \isLinear{\vsc_T} \tand \\
      % \quad\exists r \in \dom(\pwheap), \sigrets,\sigcloss,\mscode \ldotp \pwheap(r) = (\pure,\_,H_\sigma) \tand \\
      % \qquad H_\sigma \; \sigma \nequal H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \mscode \; \gc \; \sigma \tand \\
      % \qquad \npair[n']{\stpair[.]{\vsc_S}{\vsc_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W) \text{ for all $n' < n$}\tand\\
      % \qquad (\nonLinear{\src{\vsc_S}} \Rightarrow \\
      % \qquad\quad\forall W' \future \purePart{W}, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      % \qquad \qquad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o)) \tand \dots
      % % \quad (\isLinear{\src{\vsc_S}} \Rightarrow \\
      % % \qquad\forall W' \future W, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      % % \qquad \quad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o)) \wedge \\
%    \end{array}
    \right\}\cup\\ &
%
     \left\{ \npair{\left(\src{((\perm,\lin),\baddr,\eaddr,\aaddr)}, ((\perm,\lin),\baddr,\eaddr,\aaddr)\right)} \mid \dots
    % \begin{array}{l}
    %   [b,e] \mathrel{\#} \ta \tand\\
    %   \begin{array}{r l l }
    %     % \perm = \noperm & \Rightarrow & \npair{(\lin,\baddr,\eaddr)} \in
    %     % \lrp(W) \wedge \\
    %     \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \readCond{\lin,W} \wedge\\
    %     \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \writeCond{\lin,W} \wedge\\
    %     % we are excluding rwx pointers.
    %     \perm \neq \rwx \wedge \\
    %     % \perm = \rwx &\Rightarrow&
    %     % \array[t]{l}\npair{(\{\rwx,\rx\},\baddr,\eaddr)} \in \execCond{\lin,W}
    %     % \wedge \\
    %     % \npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W} \endarray\\
    %     \perm = \rx &\Rightarrow& \array[t]{l}\npair{[\baddr,\eaddr]} \in \execCond{W} \wedge\\
    %     \npair{[\baddr,\eaddr]} \in \xReadCond{W} \wedge \\
    %     \lin = \normal \\ \endarray
    %   \end{array}
    % \end{array}
     \right\} \\
%  \end{array}
  \lrvtrusted(W) ={} & \lrv(W)\cup \\
%  \begin{array}[t]{l}
    &\left\{
    %\begin{array}{l}
      \npair{\left(\src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}}, \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \right)} \mid
      % [\sigma_\baddr,\sigma_\eaddr] \subseteq(\sigrets \cup \sigcloss) \wedge 
      \dots 
    %           \exists r \in \dom(\pwheap) \ldotp \\
    %           \quad \pwheap(r) \nequal \codereg{\sigrets,\sigcloss,\mscode,\gc} \tand \dom(\mscode) \subseteq \ta \\
    %           \quad \tand [\sigma_\baddr,\sigma_\eaddr] \subseteq (\sigrets\cup\sigcloss) \tand \sigrets \subseteq \gsigrets \tand \sigcloss \subseteq \gsigcloss
    % \end{array}
    \right\} \cup \\
    & \left\{
%    \begin{array}{l}
      \npair{\left(\src{((\perm,\normal),\baddr,\eaddr,\aaddr)},((\perm,\normal),\baddr,\eaddr,\aaddr) \right)} \mid \perm \le \rx \wedge \dots
    %   \quad \perm \sqsubseteq \rx \tand 
    %    [\baddr,\eaddr] \subseteq \ta \tand 
    %    \npair{[\baddr,\eaddr]} \in \xReadCond[\square,\gc]{W} 
    % \end{array}
    \right\}
%  \end{array}
\end{align*}
\caption{Sketches of the trusted and untrusted value relation. The untrusted and trusted value relation both relates \srccm{} and \trgcm{} words. The untrusted value relation $\lrvname_{\untrusted}$ relates words that are safe to give to untrusted programs and $\lrvname_\trusted$ relates words that are safe to give to trusted programs.}
\label{fig:value-relation}
\end{figure}

% \begin{figure}
%   \centering
% \begin{align*}
%   \lrrg{\trust}(W) &= \left\{ \npair{\stpair{\reg}{\reg}} \middle|
%     \begin{array}{l}
%     % Lau: Consider using \Wor instead of \World as we have not made a distinction between the two.
%       \exists S : (\RegName \setminus \{\pcreg \})\fun \World \ldotp \\
%       \quad W = \bigoplus_{r \in (\RegName\setminus (\{\pcreg \} \cup R))} S(r) \wedge \\
%       \quad \forall r \in \RegName \setminus \{\pcreg \}\ldotp \npair{\stpair[.]{\src{\reg_S(r)}}{\reg_T(r)}} \in \lrvg{\trust}(S(r))
%     \end{array}
%             \right\}\\
%   \lre(W)&= \left\{ \begin{array}{l}
%     \npair{\stpair[.]{w_{c,S}}{w_{c,T}}} | \\
%     \quad\forall \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk}, W_\lrrs , W_\lrm \ldotp \\
%     \qquad\npair{\stpair{\reg}{\reg}} \in \lrr(W_\lrrs ) \tand \memSat{\stpair[.]{\ms_S,\stk,\ms_\stk}{\ms_T}}{W_\lrm} \tand\\
%     \qquad\Phi_S = \src{(\ms_S,\reg_S,\stk, \ms_\stk)} \tand \Phi_S' = \Phi_S \updReg{\pcreg}{w_{c,S}} \tand\\
%                      \qquad\Phi_T = (\ms_T,\reg_T) \tand \Phi_T' = \Phi_T\updReg{\pcreg}{w_{c,T}} \tand \\
%                      \qquad W \oplus W_\lrrs \oplus W_\lrm \text{ is defined }\\
%     \qquad\qquad\Rightarrow\npair{\left(\Phi_S', \Phi_T' \right)}\in \lro
%   \end{array}
%   \right\}
% \end{align*}
%   \begin{align*}
%   \lro[] ={}&\{ \npair{\left(\src{\Phi_S},\Phi_T\right)} \mid
%     \src{\Phi_S \sterm{}} \Leftrightarrow \Phi_T \trg{\term} \}
% \end{align*}
% \caption{Simplified sketches of the register file relation $\lrr(W)$, the relation
%   for $\com{jmp}$ targets $\lre(W)$  and the observation relation $\lro(W)$.}
% \label{fig:obs-rel}
% \end{figure}

\paragraph{Standard regions}
\label{par:standard-regions}
The notion of regions we defined in Section~\ref{subsec:worlds} is general enough to allow a wide variety of regions.
There are, however, some regions that may seem more natural or standard than others.
In particular, when it comes to capability safety, it seems natural to have a region that requires everything in memory to be safe.
This is exactly what we refer to as a \emph{standard region} because we usually define a region like that along with a logical relation. 

We define a $\pure$, $\spatial$, and $\spatialo$ standard region. They all have the same invariant which is defined as follows:
\[
  H_A^{\mathrm{std},\square} \; \gc \; \hat{W} \defeq \left\{ \npair{\src{\ms_S},\ms_T} \middle|
    \begin{array}{l}
      \dom(\src{\ms_S}) = \dom(\ms_T) = A \wedge \\
% There should be a later on the right side of the equality? Lau: To myself, on second thought we leave that implicit. This should be fine.
      \exists S : A \fun \World \ldotp \xi(\hat{W}) = \oplus_{\aaddr \in A} S(\aaddr) \wedge\\ 
      \quad \forall \aaddr \in A \ldotp \npair{(\src{\ms_S}(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))
    \end{array}
  \right\}
\]
The standard region invariant requires the memory segment pairs to have a specific address space $A$.
Further, the two memory segments must contain words from the untrusted value relation.
The memory segments may contain linear capabilities, so we must distribute the ownership of the world between each memory cell which the function $S$ takes care of.
Note that the invariant takes a $\hat{W}$ from $\Wor$ as argument which means that we must apply the isomorphism $\xi$ before the world can be used.
Using this invariant, we define the standard $\spatial$ and $\spatialo$ regions as follows:
\[
  \stdreg{A,\gc}{v} \defeq (v,H_A^{\mathrm{std},\square} \; \gc) , v \in \{\spatial,\spatialo\}
\]
and the standard $\pure$ regions as follows
\[
  \stdreg{A,\gc}{\pure} \defeq (\pur,H_A^{\mathrm{std},\square} \; \gc, \lambda \_ \; \_ \ldotp \emptyset)
\]
Note that the standard $\pure$ region has an empty seal invariant and thus puts no requirements on seals.

Sometimes we need to know that the contents of a memory segment stays the same.
For instance, the contents of encapsulated stack frames do not change which we need to be able to rely on.
To express this, we define a \emph{static region}.
The static region is parameterised with a memory segment pair which is the only memory segment pair the region accepts.
The memory invariant is defined as follows
\[
  H^\mathrm{sta,\square}_{\stpair{\ms}{\ms}} \; \gc \; \hat{W} \defeq \left\{ \npair{\stpair{\ms}{\ms}} \middle| 
    \begin{array}{l}
      \dom(\src{\ms_S}) = \dom(\ms_T) \wedge \\
      \exists S : \dom(\src{\ms_S}) \fun \World \ldotp \xi(\hat{W}) = \oplus_{\aaddr \in \dom(\ms)} S(\aaddr) \wedge\\
      \quad \forall \aaddr \in \dom(\src{\ms_S}) \ldotp \npair{(\src{\ms_S}(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))
    \end{array}
\right\}
\]
The region also requires the static memory to contain words from the untrusted value relation.
This means that the stack should not be used to store return seals, closure seals, and code pointers for trusted code.
With the memory invariant, we define the static region as follows:
\[
  \stareg[\stpair{\ms}{\ms},\gc]{v,\square} \defeq (v,H^\mathrm{sta,\square}_{\stpair{\ms}{\ms}} \; \gc) , v \in \{\spatial,\spatialo\}
\]
A $\pure$ static region can be defined in a similar fashion to that of the standard region.

In our result, we assume well-formed components which puts certain syntactic constraints on the components.
We also have the semantic assumption that trusted components are reasonable.
Both assumptions need to be captured in the logical relation in order for us to rely on them.
To this end, we define a \emph{code region} which captures the syntactic and semantic assumptions we make on components.
The memory invariant of the code region is defined as
\begin{multline*}
  H^\mathrm{code} \; \sigrets \; \sigcloss \; \code \; (\ta,\_,\gsigrets,\gsigcloss) \; \hat{W} =\\
  \left\{\npair{\arraycolsep=0pt\left(\array{l}\code \uplus \mspad,\\ \code \uplus \mspad\endarray\right)} \middle|
    \begin{array}{l}
    \dom(\code) = [\baddr,\eaddr] \wedge \\
      ([\baddr - 1, \eaddr + 1] \subseteq \ta \wedge \sigrets \subseteq \gsigrets \wedge \sigcloss \subseteq \gsigcloss \wedge \trust = \trusted) \vee \\
      \quad ([\baddr-1,\eaddr+1]\mathrel{\#} \ta \wedge \sigrets = \emptyset \wedge \trust =\untrusted) \wedge \\
      \mspad = [\baddr-1 \mapsto 0] \uplus [\eaddr + 1 \mapsto 0]\wedge\\
      \sigrets,\sigcloss,\ta \vdash_{\mathrm{comp-code}} \code \wedge\\
      \forall a \in \dom(\code)\ldotp\\
      \quad\npair{(\code(a),\code(a))} \in \lrvg{\trust}(\purePart{\xi(\hat{W})})
    \end{array}
  \right\}
\end{multline*}
The code region is more restrictive than the standard region.
It only allows one memory segment, namely $\code$ padded with zeroes that make sure that two capabilities cannot be spliced to cause unintended control-flow.
We use the relation to reason about trusted components (well-formed and reasonable) as well as untrusted components (well-formed).
The assumptions we can make on the code depends on whether it is part of a trusted or untrusted component.
This is captured by requiring the contents of the code memory to be in the trusted or untrusted value relation depending on the trustworthiness of the code.
That is, if all the code memory addresses are in the trusted address space and the seals are from the global seals, then the component is trusted.
On the other hand, if the code memory addresses are disjoint from the trusted addresses and there are no return seals, then the component is untrusted.
In either case, the words should be in the value relation with respect to the $\purePart{}$ of the world which means that the code memory cannot contain linear capabilities.

\stktokens{} rely on proper seal usage to guarantee well-bracketed control-flow and local state encapsulation.
This means that components must use return and closure seals for their intended purpose for \stktokens{} to work.
The code region has a seal invariant $H^\mathrm{code,\square}_\sigma$ to guarantee that the return and closure seals of the region are used correctly.
The seal invariant is displayed in Figure~\ref{fig:code-reg-seal-inv}.
The return seals $\sigrets$ in a code region should only be used to seal return pointers.
That is on \srccm{}, the return seals should only be used to seal $\retptrc{}$ and $\retptrd{}$.
\begin{figure}
  \centering
  \begin{multline*}
  H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \code \;
  (\ta,\stkb,\_,\gsigrets) \; \sigma \; \hat{W} \defeq \\
  \begin{array}[t]{l}
\left\{
    \begin{array}{l}
\left. \npair{\arraycolsep=0pt\left(\array{l}\src{\retptrc(\baddr,\eaddr,\aaddr'+\calllen)},\\((\rx,\normal),\baddr,\eaddr,\aaddr)\endarray\right)} \middle| \right. \\
      \begin{array}{l}
        \sigrets \subseteq \gsigrets \tand \\
        \dom(\code) \subseteq \ta \tand\\
        \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
        \aaddr = \aaddr' + \retoffset \tand \\
        \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets \tand\\
        \lbrack \aaddr',\aaddr' + \calllen -1 \rbrack \subseteq \lbrack \baddr, \eaddr \rbrack
      \end{array}
    \end{array}
      \right\} \cup \\
\left\{
    \begin{array}{l}
\left. \npair{\arraycolsep=0pt\left(\array{l}\src{\retptrd(\baddr,\eaddr)},\\((\rw,\linear),\baddr,\eaddr,\baddr-1)\endarray\right)} \middle| \right. \\
      \begin{array}{l}
        \sigrets \subseteq \gsigrets \tand \\
        \dom(\code) \subseteq \ta \tand\\
        \exists r \in \addressable{\linear,\pwpriv[\xi(\hat{W})]} \ldotp \\
        \quad\pwpriv[\xi(\hat{W})](r) \nequal (\stareg[(\ms_S,\ms_T)]{\spatialo,\square} \; (\ta,\stkb), \aaddr'+\calllen) \tand \\
        \quad \dom(\ms_S) = \dom(\ms_T) = [\baddr,\eaddr] \tand\\
        \quad \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
        \quad \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets
      \end{array}
    \end{array}
    \right\} \\
  \end{array}\\
    \text{ for } \sigma \in \sigrets
\end{multline*}
\begin{multline*}
  H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \code \;
  (\ta,\stkb,\gsigcloss,\gsigrets) \; \sigma \; \hat{W} \defeq \\
  \left\{
    \begin{array}{l}
\left. \npair{(\src{\vsc}, \vsc' )} \middle| \right. \\
      \begin{array}{l}
        (\dom(\code) \mathrel{\#} \ta \tand \npair{(\src{\vsc},\vsc')} \in \lrv \; \xi(\hat{W})) \vee\\
        (\dom(\code) \subseteq \ta \tand \sigcloss \subseteq \gsigcloss \tand \sigrets \subseteq \gsigrets \tand \\
         \quad((\exec{\src{\vsc}} \wedge \npair{(\src{\vsc},\vsc')} \in \lrvtrusted \; \xi(\hat{W})) \vee\\
         \quad\ (\nonExec{\src{\vsc}} \wedge\npair{(\src{\vsc},\vsc')} \in \lrv \; \xi(\hat{W}))))
      \end{array}
    \end{array}
  \right\}\\
  \text{ for } \sigma \in \sigcloss
\end{multline*}

\caption{The seal invariant for code regions.}
\label{fig:code-reg-seal-inv}
\end{figure}
% Code return pointer
If we allowed any $\retptrc$ to be sealed, then we could not be sure that the $\retptrc$ came from a call even though it should only be possible to get a return pointer from a call.
For this reason, we require that the \srccm{} return pointer actually points to the first address after a call.
For a \trgcm{} capability related to a \srccm{} code return pointer, we require it to point to the first address of the return code, not the first address after the call, as the return instructions must be executed.

% Data return pointer
For sealed data return pointers, we need to know that the world contains a region that governs the local stack frame.
That is, there should be a static region with the contents of the stack frame.
The fact that it is static signifies that the contents will remain the same.
The region that governs the stack frame must come from the call-stack sub-world which means that it is paired with a return address.
The return address should correspond to an actual return address of a call in $\code$.

% Closure seals
Unlike return seals, both trusted and untrusted components can have closure seals.
For untrusted components (components with their code address space disjoint from the trusted address space), we allow everything in the untrusted value relation to be sealed.
Intuitively, untrusted components are assumed to have access to words from the untrusted value relation, and we cannot know how the words are used, so we need to assume that an untrusted component may seal untrusted words.
Trusted components only use closure seals for sealed capability pairs that represent actual closures.
The code capability for a closure must point to the code memory because it is the only part of memory that is executable.
Untrusted components cannot safely have a capability for a trusted components code (it could be used to read return capabilities or start execution in the middle of a call), so capabilities for the code memory of a trusted component is in the trusted value relation.
While it is not safe to give a bare capability for a trusted components code memory, it can be perfectly safe to give a sealed capability for a trusted components code.
For this reason, the seal invariant allows executable capabilities from the trusted value relation to be sealed with a closure seal.

When it comes to the data capability of a closure, we just require that it comes from the untrusted value relation because the trusted value relation contains nothing that makes sense to seal as the data capability (we return to the specific contents of the two value relations later in this section).

With the memory invariant and seal invariant in hand, we define the code region as follows:
\[
  \codereg{\sigrets,\sigcloss,\code,\gc} \defeq (\pure, H^\mathrm{code,\square} \; \sigrets \; \sigcloss \; \code \; \gc, H^\mathrm{code}_\sigma \; \sigrets \; \sigcloss \; \code \; \gc)
\]
The code region is $\pure$ because it needs to contain a seal invatiant and because we assume that code pointers are normal capabilities.

% TODO in the above, add something about the untrusted case where the seals should not be in the "global" seals because the global seals are the one that we globally agree to be trusted.

\paragraph{Permission based conditions}
\label{par:perm-cond}
The safe capabilities will be defined by the value relation.
However, the safety requirements for a capability depends on the authority the capability gives.
Therefore, rather than bundling everything into the value relation, we first present a number of \emph{permission based conditions} that each spell out what the requirements are for each permission.

The world can be seen as an authority specification which means that it dictates what kind of capabilities can address a certain part of memory.
Specifically, linear capabilities can only address memory governed by a $\spatialo$ region, and normal capabilities can only address memory governed by a $\pure$ region.
All the permission based condition we define project the regions that the capability may address from the world.
The addressable $\addressable{}$ function takes care of the projection:
\[
  \addressable{\lin,W} \defeq
  \begin{cases}
    \{ r \mid W(r) = (\pure,\_) \} & \text{if $\lin = \normal$} \\
    \{ r \mid W(r) = (\spatialo,\_) \}  & \text{otherwise (i.e. $\lin = \linear$)} \\
  \end{cases}
\]

We capture the essence of what it means for a capability with read permission to be safe in the condition $\readCond[]{}$.
% each of the regions upper bounded by std region
The main purpose of $\readCond[]{}$ is to make sure that only safe words can be read from the memory governed by a read capability.
This is done by putting an upper bound on what requirements an invariant can impose on the memory segments governed by the capability.
In particular a region that governs the memory a read capability has access to can at most allow safe values to be read.
Without this requirement, a read capability could potentially be used to break memory invariants if it were used to read capabilities that has the authority to break memory invariants.
The read condition is defined as follows
\[
  \readCond{\lin,W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\lin, \pwheap} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \ldotp\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge\\
      \qquad (\lin = \linear \Rightarrow \forall r \in S \ldotp |R(r)|  = 1) \wedge\\
      \qquad \forall r \in S \ldotp \pwheap(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H
    \end{array}
  \right\}
\]
% splicing and what part of the range each region governs
The $\readCond[]{}$ is compatible with all the operations that can be performed on capabilities.
This means that if two capabilities, for which $\readCond[]{}$ holds, are spliced together, we can establish that $\readCond[]{}$ holds for the resulting capability.
To support this, we require the presence of a set of regions $S$ that governs the addresses the capability has authority over rather than just a single region.
If we need to establish the $\readCond[]{}$ after a splice, we can simply use the union of the regions that witnessed the $\readCond[]{}$ of the two individual capabilities.
We also need to support splitting which is no problem for normal capabilities as the same $\pure$ region can be used to establish the $\readCond[]{}$ for multiple normal capabilities.
On the other hand, a $\spatialo$ region can only be used to establish the $\readCond[]{}$ for one linear capability because the ownership of a spatial region can only go to one world when splitting the ownership.
None the less, we need to support arbitrary splitting of linear capabilities, which means that $\readCond[]{}$ must make sure that the necessary regions are in the world to argue that the result of a split preserves $\readCond[]{}$.
This is why, $\readCond[]{}$ requires all regions to only govern one address when the capability is linear.
This means that after a split, the authority of the regions for the bottom half of the split can go to one capability and the remaining regions can go to the top half.

A safe read capability only gives authority to read safe words.
The invariant on the memory a read capability gives access to may be even more restrictive than just requiring safe words.
For instance, the invariant may require a flag to stay unchanged.
We express the fact that a region may be more restrictive by making the standard region $\stdreg{R(r),\gc}{\pur}$, which permits all memory segments with safe words, the upper bound of what a region may require when it governs a memory segment that can be accessed through a safe read capability.

% TODO is there a point to be made about limited write for reading of linear capabilities?
% When a linear capability is read from memory, the source address must be cleared.
% This means that a linear capability with read permission also has a very limited form of write authority which only permits it to write zeroes.

Similarly to $\readCond[]{}$, we define a condition that captures the essence of what it means for a capability with writer permission to be safe.
We call this condition $\writeCond[]{}$.
A capability with write permission can be used to write to memory.
The question is, what can we safely allow to be written to memory without any memory invariants being broken.
The answer to this is anything - even words that are unsafe.
Say, you manage to write something that can break memory invariants, then it would not be possible to read it back again as write permission, generally speaking, does not entail read permission.
If the capability had read permission, then $\readCond[]{}$ would make sure that the word would have to be safe\footnote{It should not be possible to obtain a capability that can be used to break invariants. After all, if such a capability was obtained, memory invariants could be broken.
  However, the $\writeCond[]{}$ tries to capture the essence of safety and in principle it is safe to write an unsafe capability that cannot be read back.}.
It should always be possible to write safe values, so we impose this as a lower bound.

A safe write capability must respect the memory invariant of the region that governs the memory the capability gives access to.
Now consider the case, where the invariant permits two memory segments that differs in two or more addresses.
In this case, the write capability cannot be used to transform the memory from one memory segment to the other because only one memory address can be updated at a time.
If an adversary had such a capability, then it should be possible for them to transform the memory in a way that is consistent with the region.
In other words, the adversarial code should be able to transform the memory segment to any memory segment permitted by the region.
This is captured by address stratification (Definition~\ref{def:address-stratified}) which basically says that if a region permits two memory segments, then all the intermediate memory segments you may end up with when transforming one memory segment to the other must be permitted as will.
\begin{definition}
  \label{def:address-stratified}
  We say that a region $\iota = (\_,H,\_)$ is address stratified iff
  \[
    \begin{array}{l}
      \forall n, \src{\ms_S},\ms_T,\src{\ms_S'},\ms_T',s,\hat{W}\ldotp \\
      \quad \npair{\stpair{\ms}{\ms}}, \npair{\stpair[.]{\ms_S'}{\ms_T'}} \in H \; \hat{W} \wedge \\
      \quad \dom(\src{\ms_S}) = \dom(\ms_T) = \dom(\src{\ms_S'}) = \dom(\ms_T') \\
      \quad \Rightarrow \\
      \qquad \forall \aaddr \in \dom(\ms_S) \ldotp \npair{(\src{\ms_S}\update{\aaddr}{\src{\ms_S'}(\aaddr)},\ms_T\update{\aaddr}{\ms_T'(\aaddr)})} \in H \; \hat{W}
    \end{array}
  \]
\end{definition}
With address stratification defined, we define the write condition.
\begin{definition}
\[
  \writeCond{\lin,W} \defeq \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\lin, \pwheap} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats}\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge\\
      \qquad (\lin = \linear \Rightarrow \forall r \in S \ldotp |R(r)|  = 1) \wedge\\
      \qquad \forall r \in S \ldotp \pwheap(r).H \nsupeq \stdreg{R(r),\gc}{\pur}.H \wedge\\
      \qquad \quad \pwheap(r) \text{ is address-stratified}
    \end{array}
  \right\}
\]
\end{definition}
The definition of $\writeCond[]{}$ is very similar to $\readCond[]{}$.
Support for split and splice is done in the same way, and the bound is defined in terms of the standard region.

The $\readCond[]{}$ and $\writeCond[]{}$ specifically uses the heap sub-world which means that it can only be used for heap capabilities.
This means that we cannot use it for stack capabilities.
To take care of stack capabilities, we define two more conditions a $\stackReadCond[]{}$ and $\stackWriteCond[]{}$.
The two new condition are essentially the same as the $\readCond[]{}$ and $\writeCond[]{}$ except that they use the free stack sub-world and assume that the capability is linear as all stack capabilities are linear.
Note that we do not have any condition that talks about the stack-frames sub world because we should never have a capability that allows us to directly read from or write to that part of memory.
\begin{definition}
\[
  \stackReadCond{W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\linear, \pwfree} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \ldotp\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge \\
      \qquad \forall r \in S \ldotp |R(r)| = 1\\
      \qquad \forall r \in S \ldotp \pwfree(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H
    \end{array}
  \right\}
\]
\end{definition}
\begin{definition}
\[
  \stackWriteCond{W} = \left\{ \npair{A}) \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\linear, \pwfree} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge \\
      \qquad \forall r \in S \ldotp |R(r)| = 1 \wedge \\
      \qquad \forall r \in S \ldotp \pwfree(r).H \nsupeq \stdreg{R(r),\gc}{\pur}.H \wedge\\
      \qquad \quad \pwfree(r) \text{ is address-stratified}
    \end{array}
  \right\}
\]
\end{definition}
The final permission, we define conditions for is the execute permission.
We define two conditions $\execCond[]{}$ and $\xReadCond[]{}$.
The $\execCond[]{}$ captures what operations an execute-capability can be used for, i.e.\ execution.
The $\xReadCond[]{}$ captures some additional read assumptions we can make on a capability when we know the capability is executable.

The $\execCond[]{}$ intuitively says that an execute capability is safe when any capability that can be derived from it is safe as a program counter now and in the future.
We later define the $\lrename$-relation which captures what it means for a word to be safe as a program counter, but for now it suffices to think of it as a program counter that causes an execution that does not break memory invariants.
An executable capability can have its range of authority shrunk or its current address changed which changes what instructions are executed and thus potentially whether the code respects memory invariants.
For this reason, the condition requires that any executable capability with a derived range of authority and a current address in that range is safe to use for execution.
The $\execCond[]{}$ is quantified over all future worlds of the $\purePart{}$ of $W$.
We do not know when the executable capability will be used, so it should be safe even in the future when the memory has changed.
The $\purePart{}$ function turns the spatial regions of a world into shadow copies.
This means that the capability cannot depend on linear capabilities and thus the contents of the stack.
When we define the logical relation, we even require the executable capability to not be linear.
Linear executable capabilities would likely not be useful because they cannot be moved from the $\pcreg$-register without crashing the execution.
This may sound like an ideal primitive for constructing something that can be executed once, however, most programs rely on loading other capabilities or seal sets using the program counter capability which is not possible when the program counter is linear.
\begin{align*}
  \execCond{W} &=
  \left\{ \npair{A} \middle|
    \begin{array}{l}
      \forall n' < n, W' \future \purePart{W}\ldotp \forall b',e'\ldotp \forall \aaddr \in [b',e'] \subseteq A \ldotp\\
      \quad \npair[n']{\left( \arraycolsep=0pt\array{l}((\rx,\normal),\baddr',\eaddr',\aaddr),\\((\rx,\normal),\baddr',\eaddr',\aaddr)\endarray\right)} \in \lre(W')
    \end{array}
    \right\}
\end{align*}
The $\readCond[]{}$ condition by itself allows many different regions and thus potentially many different memory segments.
However, when we have a read capability with execute permission, we know that the capability must point to a piece of code memory.
For this reason, we define the $\xReadCond[]{}$ to capture the additional assumptions that we can make when a capability is executable.
\[
  \xReadCond{W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists r \in \addressable{\normal, \pwheap}, \code \ldotp \\
      \qquad \pwheap(r) \nequal \codereg{\_,\_,\code,\gc}\wedge\\
      \qquad \dom(\code) \supseteq A 
    \end{array}
  \right\}
\]
The $\xReadCond[]{}$ requires that the memory segment an executable capability has authority over is governed by a code region.
Note that we do not define $\execCond[]{}$ and $\xReadCond[]{}$ for the stack because the stack is not executable.

The $\execCond[]{}$ handles normal jumps, but it does not cover the case of $\txjmp{}{}$.
Executable capabilities can be used on their own whereas sealed capabilities must be jumped to in pairs.
However, we do not need to consider arbitrary pairs: given a sealed capability we only have to consider the capabilities permitted by the relevant seal invariant.
Just like the $\lrename$ relation captures what it means for a word to be safe as a program counter, we later define $\lrexjname$ that define what it means for a code and data capability pair to be safe together as program counter and data capability, respectively.
A sealed capability is safe when it can be paired with any sealed capability from the seal invariant such that the pair is in the $\lrexjname$ relation.
Just like safe executable capabilities, a sealed capability may be stored, so it should also be safe to use in future worlds.
The condition for sealed capabilities is defined by $\sealedCond[]{}$.
\begin{multline*}
\sealedCond{W,H_\sigma} =\\
\left\{\npair{(\sigma, \src{\vsc_S},\vsc_T)}\middle|
  \begin{array}{l}
  \forall W' \future W, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp\\
    \quad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o))
  \end{array}
\right\}
\end{multline*}

\paragraph{The untrusted value relation}
\label{par:untrusted-val-rel}
The untrusted value relation $\lrvname_\untrusted$ relates all the words that untrusted components can safely posses.
That is words that cannot be used to break any memory invariants.
The relation is displayed in \figurename~\ref{fig:untrusted-val-rel}.

The untrusted value relation has five cases: data, capabilities, stack pointers, sealed capabilities, seal sets, and stack pointers.
In the following, we will give some intuition about why it is safe to give these words to untrusted code as well motivate the conditions they are safe under.

The first case is data.
Data grant no authority, so data is always safe.
Further unlike capabilities, it is always possible to construct a new integer with the move instruction.

Next we have capabilities that do not have a special representation on \srccm{}, i.e.\ all capabilities but stack pointers and return pointers.
For two capabilities to be related, they should be syntactically equal.
That is, they should have the same range of authority, linearity and so one.
Generally speaking, untrusted components should not have direct access to a trusted components code, so we require that capabilities must have a range of authority outside the trusted address space if they are to be related.
The safety of a capability also depends on the world and whether the capability can be used to break the memory invariants of the world.
For instance, if a capability has read-permission, then it should not be possible to read something unsafe, i.e.\ something that can break memory invariants.
This condition and conditions for the other permissions are captured by the permission based conditions, so we use them to express the necessary conditions.
That is, if a capability has read permission, then $\readCond[]{}$ must be satisfied, if it has write permission, then $\writeCond[]{}$ must be satisfied, and if it has execute permission, then $\execCond[]{}$ and $\xReadCond[]{}$ must be satisfied.
If the capability has execute permission, then it must also be a normal capability.
Finally, the capability cannot have read/write/execute permission because that would break the write-XOR-execute assumption, i.e.\ the code memory in non-writable and data memory is non-executable.

Stack pointers on \srccm{} are represented with the special token $\stkptr{\perm,\baddr,\eaddr,\aaddr}$.
The corresponding capability on \trgcm{} is a linear capability with the same permission and addresses.
We assume that the stack is non-executable, so the permission for a stack pointer cannot have execute permission.
Similarly to the normal capabilities, we use the permission based conditions for the stack to ensure that the stack capability is safe to use.

% Encapsulation
A sealed capability encapsulates the authority of the underlying capability, and the authority is only released when the sealed capability is used in an $\txjmp{}{}$.
The $\xjmp{}{}$ takes a pair of sealed capabilities, so the authority of a sealed capability depends on what other sealed capabilities it might be used with.
The seal invariant specifies the capabilities that may be sealed with a given seal and thus the capabilities that may be used together as a sealed pair.
As discussed, closure and return seals must be used in specific ways which is captured in the code region seal invariant.
In order for a pair of \srccm{} and \trgcm{} sealed capabilities to be in the untrusted value relation, they must be sealed with the same seal $\sigma$ and related in the appropriate seal invariant.
% Sealed capability only useful with pairing. Sealed caps must be permitted.
Further, they should satisfy the $\sealedCond[]{}$ which means that they can safely be paired up with any other pair of capabilities from the seal invariant and used safely for execution.

For sets of seals to be related related in the untrusted relation they must be syntactically equal.
Further, the seals in the set should be disjoint from the return seals and trusted closure seals ($\gsigrets$ and $\gsigcloss$) because the trusted code relies on having the sole access to them.
We do not know what an adversary may seal or what seal they may use, so, for every seal in the seal set, we require the seal invariant to be essentially equal to the untrusted value relation.

\begin{figure}
  \centering
  \[
  \lrv(W) =
  \begin{array}[t]{l}
    \left\{ \npair{\stpair[.]{i}{i}} \;\middle|\; i \in \ints \right\}\cup \\
%
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{((\perm,\lin),\baddr,\eaddr,\aaddr)},\\ ((\perm,\lin),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\; 
    \begin{array}{l}
      [b,e] \mathrel{\#} \ta \wedge\\
      \begin{array}{r l l }
        % \perm = \noperm & \Rightarrow & \npair{(\lin,\baddr,\eaddr)} \in \lrp(W) \wedge \\
        \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \readCond{\lin,W} \wedge\\
        \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \writeCond{\lin,W} \wedge\\
        % we are excluding rwx pointers.
        \perm \neq \rwx \wedge \\
        % \perm = \rwx &\Rightarrow& \array[t]{l}\npair{(\{\rwx,\rx\},\baddr,\eaddr)} \in \execCond{\lin,W} \wedge \\
        %                            \npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W} \endarray\\
        \perm = \rx &\Rightarrow& \array[t]{l}\npair{[\baddr,\eaddr]} \in \execCond{W} \wedge\\
        \npair{[\baddr,\eaddr]} \in \xReadCond{W} \wedge \\
                                  \lin = \normal \\ \endarray
      \end{array}
    \end{array}
    \right\}\cup \\
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\stkptr{\perm,\baddr,\eaddr,\aaddr}},\\ ((\perm,\linear),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\;
    \begin{array}{l}
      \begin{array}{r l l}
        \perm \not\in \{\rx,\rwx\} \wedge\\
        % \perm = \noperm & \Rightarrow & \npair{(\linear,\baddr,\eaddr)} \in \lrp(W) \wedge \\
        \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \stackReadCond{W} \wedge \\
        \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \stackWriteCond{W}
      \end{array}
    \end{array}
    \right\} \cup \\
%
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l}\src{\sealed{\sigma,\vsc_S}},\\ \sealed{\sigma,\vsc_T} \endarray\right)} \;\middle| \;
    \begin{array}{l}
      (\isLinear{\src{\vsc_S}} \text{ iff } \isLinear{\vsc_T}) \wedge\\
      \exists r \in \dom(\pwheap), \sigrets,\sigcloss,\mscode \ldotp \\
      \quad\pwheap(r) = (\pure,\_,H_\sigma) \tand \\
      \quad H_\sigma \; \sigma \nequal H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \mscode \; \gc \; \sigma \tand \\
      \quad \npair[n']{\stpair[.]{\vsc_S}{\vsc_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W) \text{ for all $n' < n$}\wedge\\
      \quad \isLinear{\src{\vsc_S}} \\
      \qquad \Rightarrow \npair{(\sigma,\src{\vsc_S},\vsc_T)}\in \sealedCond{W,H_\sigma} \wedge\\
      \quad \nonLinear{\src{\vsc_S}} \\
      \qquad \Rightarrow  \npair{(\sigma,\src{\vsc_S},\vsc_T)}\in \sealedCond{\mathit{purePart}(W),H_\sigma}\\
      % This case was never used (?) so it is not necessary.
      % \wedge \\
      % \quad \npair[n']{\src{\vsc_S'},\src{\vsc_S},\vsc_T',\vsc_T} \in \lrexj(W' \oplus W_o)
    \end{array}
    \right\}\cup\\
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}},\\ \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \endarray \right)} 
    \; \middle| \;
    \begin{array}{l}
      [\sigma_\baddr,\sigma_\eaddr] \mathrel{\#} (\gsigrets \cup \gsigcloss) \tand\\
      \forall \sigma' \in [\sigma_\baddr,\sigma_\eaddr] \ldotp \exists r \in \dom(\pwheap) \ldotp \\
      \quad \pwheap(r) = (\pure,\_,H_\sigma) \tand H_\sigma \; \sigma' \nequal (\lrv \circ \xi)
    \end{array}
    \right\} 
  \end{array}
\]
\caption{The untrusted value relation relates all the words on \srccm{} to all the words on \trgcm{} that are safe for non-trusted components to posses.}
\label{fig:untrusted-val-rel}
\end{figure}

When we give a word to untrusted code, we can make no assumptions on when they will use it.
For instance, they may store it in memory and use it in a later call.
This means that a safe word must not only be safe now but also at any point in the future.
The untrusted value relation ensures this as it is monotone with respect to future worlds.
\begin{lemma}[Untrusted value relation monotonicity]
  \label{lem:monotonicity}
  For all integers $n$, words $\src{w_1}$ and $w_2$, and worlds $W' \future W$, if $\npair{(\src{w_1},w_2)} \in \lrv(W)$, then $\npair{(\src{w_1},w_2)} \in \lrv(W')$.
\end{lemma}

\paragraph{The trusted value relation}
\label{par:trusted-val-rel}
The trusted value relation $\lrvname_\trusted$ relates everything safe for a trusted component to have without breaking memory invariants.
For the most part, we allow them to contain the same words as the untrusted components, but we also need to allow them to have seal sets with trusted closure seals and return seals which we cannot allow untrusted components to have.
Further, we need to allow trusted components to have capabilities for the trusted code which, again, is something that we cannot allow untrusted components to have.
The untrusted value relation is defined in Figure~\ref{fig:trusted-val-rel}.

The words in $\lrvname_\trusted$ but not in the $\lrvname_\untrusted$ have the potential to break the system invariants \stktokens{} rely on.
We can only let trusted components have words from $\lrvname_\trusted$ because the trusted component promises to not break the invariant by behaving reasonably.
This promise is expressed formally in $\lrvname_\trusted$ by requiring the presence of a code region in both cases specific to $\lrvname_\trusted$.
As explained previously, the code region essentially captures the requirements put on components by well-formedness and the reasonability condition which constitutes the promise to use seals and trusted code pointers in a way that does not break invariants.

% Trusted seals
The trusted closure seals and return seals serve a specific purpose, namely they must be used for return pointers and closures.
To make sure this is the case, there must be a code region in the world that governs the code.
The code region contains a seal invariant that makes sure that the seals are only used for their intended purpose.
This is why the trusted value relation only relates seal sets of trusted closure seals and return seals when the world contains an appropriate code region.

% Code pointers for trusted code
Two capabilities are related as trusted code pointers if they are normal, has a permission derivable from read-execute, and has a range of authority within the trusted address space, $\ta$.
Further, we need to know that the capabilities actually point to a piece of code which is why we require the $\xReadCond[]{}$ to be satisfied.
This makes sure that the region that governs the memory the capability points to is a code region.
Note that even though the capability has read permission, we do not require the read condition to hold.
The code memory contains trusted closure seals and return seals that we cannot let untrusted code have and the read condition requires everything to be in $\lrvname_\untrusted$, so the read condition would not hold.
However, trusted code can have access to such seals because we expect the trusted code to treat the seals reasonably.
\begin{figure}
  \centering
  \[
  \lrvtrusted[\square,\gc](W) =
  \begin{array}[t]{l}
    \lrv(W)\cup \\
%
    \left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}},\\ \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \endarray \right)} 
    \; \middle| \;
    \begin{array}{l}
      \gc = (\ta,\stkb,\gsigrets,\gsigcloss)  \wedge \\
      \exists r \in \dom(\pwheap) \ldotp \\
      \quad \pwheap(r) \nequal \codereg{\sigrets,\sigcloss,\code,\gc} \wedge\\
      \quad \dom(\code) \subseteq \ta \wedge [\sigma_\baddr,\sigma_\eaddr] \subseteq (\sigrets\cup\sigcloss) \wedge\\
      \quad \sigrets \subseteq \gsigrets \wedge \sigcloss \subseteq \gsigcloss
    \end{array}
    \right\} \cup \\
    \left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{((\perm,\normal),\baddr,\eaddr,\aaddr)},\\ ((\perm,\normal),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\; 
    \begin{array}{l}
      \perm \sqsubseteq \rx \wedge \\
      \gc = (\ta,\stkb,\gsigrets,\gsigcloss)  \wedge \\
      {} [\baddr,\eaddr] \subseteq \ta \wedge\\
      \npair{[\baddr,\eaddr]} \in \xReadCond[\square,\gc]{W} 
    \end{array}
    \right\}
  \end{array}
\]

\caption{The trusted value relation $\lrvname_\trusted$ relates all the words that are safe for trusted components to contain. A trusted component may contain untrusted words (\figurename~\ref{fig:untrusted-val-rel}), return seals and trusted closure seals, and code pointers for trusted code. }
\label{fig:trusted-val-rel}
\end{figure}
Like the untrusted value relation, the trusted value relation is monotone.
Intuitively, the two relations are monotone for the same reason; words are potentially used at any point in time.
If words are safe now (in the current world), then they should also be safe to use later (in any possible future world).
\begin{lemma}[Trusted value relation monotonicity]
  \label{lem:monotonicity-trusted}
  For all integers $n$, words $\src{w_1}$ and $w_2$, and worlds $W' \future W$, if $\npair{(\src{w_1},w_2)} \in \lrvtrusted(W)$, then $\npair{(\src{w_1},w_2)} \in \lrvtrusted(W')$.
\end{lemma}
Another, perhaps unsurprising property, of the trusted value relation it that non-linear words do not depend on the spatial regions that may be in the world.
This is unsurprising as normal capabilities do not necessarily reference memory uniquely.
\begin{lemma}[Non-linear words are independent of spatial regions]
  \label{lem:non-linear-pure}
 If $\npair{(w_1,w_2)} \in \lrvtrusted(W)$ and either $\nonLinear{w_1}$ or $\nonLinear{w_2}$, then
 \[
   \npair{(w_1,w_2)} \in \lrvtrusted(\purePart{W})\text{.\qedhere}
 \]
\end{lemma}
This is similar to Lemma~\ref{lem:non-linear-pure} for the untrusted value relation.

\subsubsection{Register file relation}
The register file relation relates \srccm{} register files to \trgcm{} register files.
Intuitively, two register files are related when they only contain safe words, i.e.\ words from the value relation.
This raises the question ``which value relation?''
We only use the register file relation to relate register files for components we do not trust, so the answer is the untrusted value relation.
The definition of the register-file relation is straightforward.
It distributes the authority of the world among the registers and requires each of the registers to contain a safe word with respect to the authority it is given.
The register file never takes into account the $\pcreg$ and it can leave out further registers.
We use this to not relate register content that will be overwritten anyway.
We write $\lrrs(W)$ to mean $\lrrs(\emptyset)(W)$.
That is, if we do not need to exclude additional registers, then we simply omit that argument.
The register file relation is defined in \figurename~\ref{fig:reg-file-rel}.

\begin{figure}
  \centering
  \[
  \lrr(R)(W) = \left\{ \npair{\stpair{\reg}{\reg}} \middle|
    \begin{array}{l}
      \exists S : (\RegName \setminus (\{\pcreg \} \cup R))\fun \World \ldotp \\
      \quad W = \bigoplus_{r \in (\RegName\setminus (\{\pcreg,\rdata \} \cup R))} S(r) \wedge \\
      \quad \forall r \in \RegName \setminus (\{\pcreg \} \cup R)\ldotp\\
      \qquad\npair{(\src{\reg_S}(r),\reg_T(r))} \in \lrv(S(r))
    \end{array}
            \right\}
\]
\caption{The register file relation relates register files. Two register files are related when their content is related.}
\label{fig:reg-file-rel}
\end{figure}

\subsubsection{Expression relations}
The expression relation $\lrename$ defines when two capabilities can be used in the $\pcreg$-register to produce related executions, i.e. the capabilities can be used to construct configurations in the observation relation.
The $\lrename$ relation can be used to reason about the safety of an executable capability, i.e.\ capabilities that can change the control flow during execution when a $\tjmp{}$ instruction is executed.
In the setting of \srccm{} and \trgcm{}, we can also use sealed capabilities to change the control flow by using the $\txjmp{}{}$ instruction.
The $\txjmp{}{}$ instruction updates the $\pcreg$ register and the $\rdata$ register, however, the $\lrename$ relation only updates the $\pc$-register, so we cannot use $\lrename$ to reason about sealed capabilities.
Instead, we define the relation $\lrename_\mathrm{xjmp}$ which relates two pairs of capabilities when they are safe to use with the $\txjmp{}{}$ instruction.

Executions are related when the observable effect of the executions are permissible.
The permissible observations are defined by the observation relation, so we define the expression relation in terms of the observation relation.
However, the observation relation relates configurations, not capabilities.
We lift the capabilities to configurations simply by plugging the two capabilities into the $\pcreg$-register of two configurations.
We cannot pick arbitrary configurations because an arbitrary configuration may contain words that can be used to break memory invariants and thus create unacceptable observable effects.
Instead, we need to pick configurations made out of related components, i.e.\ related register files and related memories that respect linearity.
The type of execution captured by $\lrename$ corresponds to a normal jump.
When a $\tjmp r$ instruction is interpreted, the $\pcreg$-register is replaced with the contents of register $r$, i.e. the current configuration is plugged with a new pc.
The $\lrename$ relation is defined in \figurename~\ref{fig:expr-rels}

The $\lrename_\mathrm{xjmp}$ relation looks very much like the $\lrename$ relation.
It takes related memories and register files (ignoring the $\rdata$ register) and combines them into two configurations.
Each of the configurations are plugged with a code capability and a data capability just like the $\txjmp{}{}$ instruction would do it and requires the resulting configurations to be in the $\lroname$ relation.
The $\lrename_\mathrm{xjmp}$ relation is defined in \figurename~\ref{fig:expr-rels}.
\begin{figure}
  \centering
  \begin{align*}
  \lre(W) &= \left\{ \npair{\stpair[.]{v_{c,S}}{v_{c,T}}} \middle| 
    \begin{array}{l}
      \forall n' \leq n, \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk} \ldotp\\
      \quad \forall W_\lrrs , W_\lrm \ldotp \\
      \qquad\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_\lrrs) \wedge\\
      \qquad\memSat[n']{\src{\ms_S,\stk,\ms_\stk},\ms_T}{W_\lrm} \\
      \qquad\src{\Phi_S} = \src{(\ms_S,\reg_S,\stk, \ms_\stk)}\\
      \qquad\src{\Phi_S'} = \src{\Phi_S} \updReg{\pcreg}{\src{v_{c,S}}}\\
      \qquad\Phi_T = (\ms_T,\reg_T)\\
      \qquad\Phi_T' = \Phi_T\updReg{\pcreg}{v_{c,T}}\\
      \qquad W \oplus W_\lrrs \oplus W_\lrm\\
      \qquad\Rightarrow\npair[n']{\left(\src{\Phi_S'}, \Phi_T' \right)}\in \lro
    \end{array}
    \right\}
\\  \lrexj(W) &= \left\{ \npair{\stpair[.]{v_{c,S},v_{d,S}}{v_{c,T},v_{d,T}}} \middle| 
    \begin{array}{l}
      \forall n' \leq n, \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk} \ldotp\\
      \quad \forall W_\lrrs , W_\lrm \ldotp \\
      \qquad\npair[n']{\stpair{\reg}{\reg}} \in \lrr(\{\rdata\}) (W_\lrrs ) \wedge\\
      \qquad\memSat[n']{\src{\ms_S,\stk,\ms_\stk},\ms_T}{W_\lrm} \wedge \\
      \qquad\src{\Phi_S} = \src{(\ms_S,\reg_S,\stk, \ms_\stk)}\wedge\\
      \qquad\Phi_T = (\ms_T,\reg_T) \wedge\\
      \qquad W \oplus W_\lrrs \oplus W_\lrm \text{ is defined }\\
      \qquad\Rightarrow \exists \src{\Phi_S'},\Phi_T'\ldotp\\
      \quad\qquad \src{\Phi_S'} = \xjumpResult{\src{v_{c,S}}}{\src{v_{d,S}}}{\src{\Phi_S}} \tand\\
      \quad\qquad\Phi_T' = \xjumpResult{v_{c,T}}{v_{d,T}}{\Phi_T}\tand\\
      \quad\qquad\npair[n']{\left(\src{\Phi_S'}, \Phi_T' \right)}\in \lro
    \end{array}
    \right\}
\end{align*}

\caption{The expression relation relates capabilities capabilities that can safely be used for execution. The xjmp expression relation can be used to relate capabilities that are safe as sealed capabilties.}
\label{fig:expr-rels}
\end{figure}

\subsection{Fundamental Theorem}
% Include the actual FTLR
An important lemma in our proof of full abstraction of the embedding of \srccm{} into \trgcm{}, is the fundamental theorem of logical relations (FTLR).
The name indicates that it is an instance of a general pattern in logical relations proofs, but is otherwise unimportant.
\begin{theorem}[FTLR]
  \label{thm:ftlr}
  For all $n,W,\lin,\baddr,\eaddr,\aaddr$,
  If
  \begin{itemize}
  \item $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$
  \end{itemize}
  and one of the following sets of requirements holds:
  \begin{itemize}
  \item $[\baddr,\eaddr] \subseteq \ta$ and
 $({((\rx,\normal),\baddr,\eaddr,\aaddr)}$ behaves reasonably up to $n$ steps (see Section~\ref{sec:well-form-reas}).
  \item $[\baddr,\eaddr] \mathrel{\#} \ta$
  \end{itemize}
  then
  \[
    \npair{\left(\src{((\rx,\normal),\baddr,\eaddr,\aaddr)}, ((\rx,\normal),\baddr,\eaddr,\aaddr)\right)} \in \lre(W) \qedhere
  \]
\end{theorem}
Roughly speaking, this lemma says that under certain conditions, executing any executable capability under \srccm{} and \trgcm{} semantics will produce the same observable behavior.
The conditions require that the capability points to a memory region where code is loaded and that code must be either trusted and behave reasonably (i.e.\ respect the restrictions that \stktokens{} relies on, see Section~\ref{sec:well-form-reas}) or untrusted (in which case, it cannot have WBCF or LSE expectations, see Section~\ref{sec:well-form-reas}).

The proof of the lemma consists of a big induction where each possible instruction is proven to behave the same in source and target in related memories and register files.
After that first step, the induction hypothesis is used for the rest of the execution.

\subsection{Related Components}
\label{subsec:component-rel}
In order to show full abstraction (Theorem~\ref{thm:full-abstraction}), we need not only to relate the words on \srccm{} with words on \trgcm{} we also need to relate \srccm{} components with \trgcm{} components.
Specifically, we say that two components are related when they are syntactically equal, after all, a \srccm{} component is in some sense the same as a \trgcm{} as we only see the difference during execution when a call happens and when we lift a component to a configuration where we need to introduce a stack pointer.
However, we cannot take arbitrary components as they could potentially break memory invariants.
For related base components, we require that if the imports are satisfied with related words, then the resulting memory should be safe.
Further, related components must have safe exports.
Components with a main are related when the base components are related and the main capabilities are in the public interface, that is they must be in the exports.

\begin{definition}[Component relation]
  \label{def:component-rel}
\begin{align*}
  \lrcomp(W) &=
  \left\{\begin{aligned}
     &\npair{\src{\var{comp}},\src{\var{comp}}} \;\mid \;\\
      &\qquad\var{comp} = (\mscode,\msdata,\overline{a_{\mathrm{import}} \mapsfrom s_{\mathrm{import}}},\overline{s_{\mathrm{export}} \mapsto w_{\mathrm{export}}},\sigrets,\sigcloss) \text{ and} \\
      &\qquad\text{For all } W' \future W \ldotp \\
      &\qquad\quad\text{If } \overline{\npair[n']{(\src{w_{\mathrm{import}}},w_{\mathrm{import}})}} \in \lrv(\purePart{W'}) \text{ for all $n' < n$}\\
      &\qquad\quad\text{and } \msdata' = \msdata{}[\overline{a_{\mathrm{import}} \mapsto w_{\mathrm{import}}}] \\
      &\qquad\quad\text{then } \npair{(\sigrets\uplus\sigcloss,\src{\mscode\uplus \msdata'}, \mscode\uplus\msdata')} \in \lrheap(\pwheap)(W') \text{ and }\\
      &\qquad\quad\overline{\npair{(\src{w_{\mathrm{export}}},w_{\mathrm{export}})}} \in \lrv(\purePart{W'})
  \end{aligned}
    \right\}\\
  &\cup \left\{
    \begin{multlined}
     \npair{\src{(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})},(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})} \;\mid \;\\
     \npair{(\src{\var{comp}_0},\var{comp}_0)} \in \lrcomp(W) \text{ and}\\
     \{(\_ \mapsto \src{c_{\mathrm{main},c}}),(\_ \mapsto c_{\mathrm{main},d})\} \subseteq \overline{w_{\mathrm{export}}}
       \end{multlined}
    \right\} 
\end{align*}
\end{definition}
% TODO include central lemmas?

\subsection{Related Execution Configuration}
The full abstraction theorem (Theorem~\ref{thm:full-abstraction}) is stated in terms of contextual equivalence.
Contextual equivalence (Definition~\ref{def:contextual-equivalence}) plugs two components into a context and requires equitermination of the resulting executable configurations.
This means that we need to lift relatedness one step further than the components, namely to the level of execution configurations.
To this end, we define $\lrecname$.
\begin{definition}[Related execution configuration]
\label{def:exec-conf-rel}
  \[
  \lrec(W) = \left\{
    \begin{multlined}
\npair{\left(
        \src{(\ms_S,\reg_S,\stk,\ms_\stk)},
        (\ms_T,\reg_T)\right)} \; \mid \; \\
    \begin{array}{l}
      \gc = (\ta,\stkb) \tand\\
      \exists W_M,W_R,W_\pcreg \ldotp W = W_M \oplus W_R \oplus W_\pcreg \tand\\
      \npair{( (\src{\reg_S}(\pcreg),\src{\reg_S}(\rdata)), (\reg_T(\pcreg),\reg_T(\rdata)) )} \in \lrexj(W_\pcreg) \tand \\
      \src{\reg_S}(\pcreg) \neq \src{\retptrc(\_)} \wedge 
      \src{\reg_S}(\rdata) \neq \src{\retptrd(\_)} \wedge \\
      \nonExec{\src{\reg_S}(\rdata)} \wedge
      \nonExec{\reg_T(\rdata)}\\
      \memSat{\src{\ms_S},\src{\ms_\stk},\src{\stk},\ms_T}{W_M} \tand\\
      \npair{\stpair{\reg}{\reg}} \in \lrr(\{\rdata\})(W_R)
    \end{array}
  \end{multlined}
\right\}
\]
\end{definition}
Definition~\ref{def:exec-conf-rel} essentially says that two executable configurations are related when they are made out of related components.
That is, the authority of the world must be distributed such that the code and data pointer pairs are safe for execution, i.e.\ the contents of the $\pcreg$ and $\rdata$ registers are related by the $\lrename_\mathrm{xjmp}$ relation.
Further, the two memories and the two register files should be related.
This means that the executable configuration only contains words that respect memory invariants.

% TODO Include central lemmas?
\end{jversion}

\subsection{Full Abstraction Proof Sketch}
\label{subsec:proof-sketch}
Using Lemma~\ref{thm:ftlr}, we can now proceed to proving Theorem~\ref{thm:full-abstraction} (full abstraction).

% Essentially, it relates a component to itself if instantiating their imports with related values produces related exports and code memory satisfying the appropriate code region in the world.
% The component relation $\mathcal{C}(W)$ basically lifts the logical relation we have presented above to components.
% The component relation relates a component $(\mscode,\msdata,\overline{\mathrm{import}},\overline{\mathrm{export}},\sigrets,\sigcloss)$ to itself when two conditions are satisfied.
% First, when words that relate to them selves in the untrusted value relation are used to satisfy the imports, i.e.\ the words are placed on the import addresses in $\msdata$, and this data memory is combined with the code memory $\mscode$, then it forms a safe heap, i.e.\ it is in the $\mathcal{H}$ relation.
% Second, the exports should always be safe to use which means that they must be in the untrusted value relation in any future world.
% \begin{multline*}
%   \lrcomp(W) =\\
%   \left\{\begin{aligned}
%       &\npair{\var{comp},\var{comp}} \;\mid \;\\
%       &\qquad\var{comp} = (\mscode,\msdata,\overline{a_{\mathrm{import}} \mapsfrom s_{\mathrm{import}}},\overline{s_{\mathrm{export}} \mapsto w_{\mathrm{export}}},\sigrets,\sigcloss) \tand \\
%       &\qquad\text{For all } W' \future W \ldotp \\
%       &\qquad\quad\text{If } \overline{\npair[n']{(w_{\mathrm{import}},w_{\mathrm{import}})}} \in \lrv(\purePart{W'}) \text{ for all $n' < n$}\\
%       &\qquad\quad\text{and } \msdata' = \msdata{}[\overline{a_{\mathrm{import}} \mapsto w_{\mathrm{import}}}] \\
%       &\qquad\quad\text{then } \npair{(\sigrets\uplus\sigcloss,\mscode\uplus \msdata', \mscode\uplus\msdata')} \in \lrheap(\pwheap)(W') \tand\\
%       &\qquad\quad\overline{\npair{(w_{\mathrm{export}},w_{\mathrm{export}})}} \in \lrv(\purePart{W'})
%     \end{aligned}
%   \right\}\\
% \cup \left\{
%     \begin{multlined}
%       \npair{(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d}),(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})} \;\mid \;\\
%       \npair{(\var{comp}_0,\var{comp}_0)} \in \lrcomp(W) \tand
%       \{(\_ \mapsto c_{\mathrm{main},c}),(\_ \mapsto c_{\mathrm{main},d})\} \subseteq \overline{w_{\mathrm{export}}}
%     \end{multlined}
%   \right\} 
% \end{multline*}
%
Using Lemma~\ref{thm:ftlr} and the definitions of the logical relations, we can then prove the following two lemmas.
The first is a version of the FTLR for components, stating that all components are related to themselves if they are either (1) well-formed and untrusted or (2) well-formed, reasonable and trusted.
\begin{lemma}[FTLR for components]
  \label{lem:ftlr-comps}
  If $\comp$ is a well-formed component, i.e. $\wdjud{\comp}$ and either
    $\dom(\comp.\mscode) \subseteq \ta$ and $\src{\comp}$ is a reasonable component; or
    $\dom(\comp.\mscode) \mathrel{\#} \ta$,
  then there exists a $W$ such that
  $\npair{(\src{\comp},\comp)} \in \lrcomp(W)$.
\end{lemma}

Another lemma then relates the component relation and context plugging: plugging related components into related contexts produces related execution configurations.
\begin{lemma}
  \label{lem:adeq-context-plug}
  If $\npair{\stpair{\context}{\context}}\in\lrcomp(W_1)$ and $\npair{\stpair{\comp}{\comp}} \in \lrcomp(W_2)$ and $W_1\oplus W_2$ is defined, then
  $\plug{\src{\context_S}}{\src{\comp_S}}$ terminates iff $\plug{\context_T}{\comp_T}$ terminates.
\end{lemma}
% Finally, we have an adequacy lemma for the execution configuration relation.
% This lemma says that for related \srccm{} and \trgcm{} configurations, one terminates iff the other does.
% \begin{multline*}
%   \lrec[\square,\gc = (\ta,\stkb)](W) = \\
% \left\{
%   \begin{array}{l}
%      \npair{\left(
%     (\ms_S,\reg_S,\stk,\ms_\stk),
%     (\ms_T,\reg_T)\right)} \mid \\
%     \quad \exists W_M,W_R,W_\pcreg \ldotp W = W_M \oplus W_R \oplus W_\pcreg \tand\\
%     \qquad \npair{( (\reg_S(\pcreg),\reg_S(\rdata)), (\reg_T(\pcreg),\reg_T(\rdata)) )} \in \lrexj(W_\pcreg) \tand \\
%     \qquad \reg_S(\pcreg) \neq \retptrc(\_) \tand
%     \reg_S(\rdata) \neq \retptrd(\_) \tand \\
%     \qquad \nonExec{\reg_S(\rdata)} \tand  
%      \nonExec{\reg_T(\rdata)} \tand \\
%     \qquad \memSat{\ms_S,\ms_\stk,\stk,\ms_T}{W_M} \tand \npair{\stpair{\reg}{\reg}} \in \lrr(\{\rdata\})(W_R)
%   \end{array}
% \right\}
% \end{multline*}
% \begin{lemma}[Adequacy of execution configuration logical relation]
%   \label{lem:adequacy}
%   If $\npair{\stpair{\Phi}{\Phi}}\in\lrec(W)$ then $\src{\Phi_S} \sterm{}$ iff $\Phi_T\term$.
% \end{lemma}

Finally, we use these two lemmas to prove Theorem~\ref{thm:full-abstraction}.
\begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
  Both directions of the proof are similar, so we only show the right direction.
  To show the \trgcm{} contextual equivalence, assume w.l.o.g\ a well-formed context $\trg{\context}$ such that ${\plug{\trg{\context}}{\src{\comp_1}} \term[]{}}$.
  The proof is sketched in Figure~\ref{fig:fa-proof-sketch}.
  By the statement of Theorem~\ref{thm:full-abstraction}, we may assume that the trusted components $\src{\comp_1}$ and $\src{\comp_2}$ are well-formed and reasonable.
  We prove arrow (1) in the figure by using the mentioned assumptions about $\src{\comp_1}$ and $\trg{\context}$ along with Lemma~\ref{lem:ftlr-comps} and \ref{lem:adeq-context-plug}.
  Now we know that ${\plug{\trg{\context}}{\src{\comp_1}} \sterm[]{}{}}$, so by the assumption that $\src{\comp_1}$ and $\src{\comp_2}$ are contextually equivalent on \srccm{} we get ${\plug{\trg{\context}}{\src{\comp_2}} \sterm[]{}{}}$, i.e.\ arrow (2) in the figure.
  To prove arrow (3), we again apply Lemma~\ref{lem:ftlr-comps}, \ref{lem:adeq-context-plug}; but this time, we use the assumption that $\src{\comp_2}$ is well-formed and reasonable and that $\trg{\context}$ is well-formed.
\end{proof}

\renewcommand{\comp}{C}
\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=.9}]
    % \draw[help lines,yellow] (0,0) grid (10,7);
    \node at (5,4.7) { ${\src{\comp_1}\mathrel{\sconeq} \src{\comp_2}}$ };

    \node at (3.4,4) { ${\plug{\trg{\context}}{\src{\comp_1}} \sterm[]{\gc}{}}$ };
    \node at (5,4) { $\mathrel{\Rightarrow}$ };
    \node at (6.6,4) { ${\plug{\trg{\context}}{\src{\comp_2}} \sterm[]{\gc}{}}$ };

    \node at (4.35,2.8) { (1) };
    \node at (5,3.6) { (2) };
    \node at (5.65,2.8) { (3) };

    \draw[out=100,in=260,double,-implies,double equal sign distance] (4,2.6) to (4,3.4);

    \draw[out=280,in=80,double,-implies,double equal sign distance] (6,3.4) to (6,2.6);

    \node[align=center] at (8.2,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_2}} \cong {\src{\comp_2}}$};
    \node[align=center] at (1.8,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_1}} \cong {\src{\comp_1}}$};
    % \node at (9,2.7) { $e  {\src{C_1}} \cong \src{C_1}} : tau$ };
    % \node at (8.7,3.3) { $ {\trg{\context}} \cong \trg{\context} :{\emptyset},tau \ra e,{\cdots}$ };
    % \node at (.8,3) { $e  {\src{C_1}} \cong {\src{C_1}} : tau$ };

    \node at (3.4,2) { ${\plug{\trg{\context}}{\src{\comp_1}} \term[]{}}$ };
    \node at (5,2.1) { $\overset{?}{\Rightarrow}$ };
    \node at (6.6,2) { ${\plug{\trg{\context}}{\src{\comp_2}} \term[]{}}$ };

    \node at (5,1.3) { ${\src{\comp_1}}\mathrel{\overset{?}{\tconeq}}{\src{\comp_2}}$ };

    \draw[out=-90,in=90,double,-implies,double equal sign distance] (0,5) to node[sloped, yshift =.7em]{\Small Contextual equivalence preservation} (0,1);
  \end{tikzpicture}
  \caption{Proving one direction of fully abstract compilation (contextual equivalence preservation).}
  \label{fig:fa-proof-sketch}
\end{figure}


% \subsection{Proof sketch}
% \label{subsec:proof-sketch}
% \begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
  % \item Consider first the upward arrow.
  %   Assume $\src{\var{comp}_1} \tconeq \src{\var{comp}_2}$.

  %   Take a $\src{\context}$ such that $\vdash \src{\context}$, take $\src{\ta[,i]}
  %   = \src{\dom(\var{comp}_i.\mscode)}$, $\gsigrets_i = \var{comp}_i.\sigrets$ and
  %   $\gsigcloss_i = \var{comp}_i.\sigcloss$, $\gc_i = (\ta[,i],\stkb_i,\gsigrets_i,\gsigcloss_i)$ and we will prove that
  %   $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}} \Leftrightarrow
  %   \src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.

  %   By symmetry, we can assume w.l.o.g. that $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}}$ and prove that $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.
  %   Note that this implies that $\src{\context}$ is a valid context for both $\src{\var{comp}_1}$ and $\src{\var{comp}_2}$.

  %   First, we show that also $\plug{\context}{\var{comp}_1} \trg{\term}$.
  %   Take $n$ the amount of steps in the termination of $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}}$.
  %   It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\var{comp}_1,\var{comp}_1)} \in \lrcomp[\preceq,\gc_1](W_1)$ for some $W_1$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
  %   It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\context,\context)} \in \lrcomp[\preceq,\gc_1](W_1')$ for some $W_1'$ that we can choose such that $W_1 \uplus W_1'$ is defined.
  %   Lemma~\ref{lem:compat-context-plug} then tells us that $\npair{(\plug{\context}{\var{comp}_1}, \plug{\context}{\var{comp}_1})} \in \lrec[\preceq,\gc_1](W_1\uplus W_1')$
  %   Together with $\src{\plug{\context}{\var{comp}_1} \sterm[n]{\gc_1}}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_1} \trg{\term}$.

  %   It follows from $\src{\var{comp}_1} \tconeq \src{\var{comp}_2}$ that also $\plug{\context}{\var{comp}_2} \trg{\term}$.

  %   It now remains to show that also $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.
  %   Take $n'$ the amount of steps in the termination of $\plug{\context}{\var{comp}_2} \trg{\term}$.
  %   It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\var{comp}_2,\var{comp}_2)} \in \lrcomp[\succeq,\gc_2](W_2)$ for some $W_2$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
  %   It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\context,\context)} \in \lrcomp[\succeq,\gc_2](W_2')$ for some $W_2'$ that we can choose such that $W_2 \uplus W_2'$ is defined.
  %   Lemma~\ref{lem:compat-context-plug} then tells us that $\npair[n']{(\plug{\context}{\var{comp}_2}, \plug{\context}{\var{comp}_2})} \in \lrec[\succeq,\gc_2](W_2\uplus W_2')$
  %   Together with $\plug{\context}{\var{comp}_2} \trg{\term[n']}$, Lemma~\ref{lem:adequacy} then tells us that $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$, concluding this direction of the proof.

%   First consider the right arrow:

%     Assume $\src{\var{comp}_1} \sconeq \src{\var{comp}_2}$. Take $\src{\ta[,i]} = \src{\dom(\var{comp}_i.\mscode)}$, $\gsigrets_i = \var{comp}_i.\sigrets$ and $\gsigcloss_i = \var{comp}_i.\sigcloss$, $\gc_i = (\ta[,i],\stkb_i,\gsigrets_i,\gsigcloss_i)$.
% %
%     Take a $\trg{\context}$ such that $\vdash \trg{\context}$ and we will prove that
%     $\trg{\plug{\context}{\var{comp}_1} \term} \Leftrightarrow
%     \trg{\plug{\context}{\var{comp}_2} \term}$.
% %
%     By symmetry, we can assume w.l.o.g. that $\trg{\plug{\context}{\var{comp}_1} \term}$ and prove that $\trg{\plug{\context}{\var{comp}_2} \term}$.
%     Note that this implies that $\trg{\context}$ is a valid context for both $\trg{\var{comp}_1}$ and $\trg{\var{comp}_2}$.
% %
%     First, we show that also $\plug{\context}{\var{comp}_1} \src{\sterm{\gc_1}}$.
%     Take $n$ the amount of steps in the termination of $\plug{\context}{\var{comp}_1} \trg{\term}$.
%     It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\var{comp}_1,\var{comp}_1)} \in \lrcomp[\succeq,\gc_1](W_1)$ for some $W_1$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
%     It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\context,\context)} \in \lrcomp[\succeq,\gc_1](W_1')$ for some $W_1'$ that we can choose such that $W_1 \uplus W_1'$ is defined.
%     Lemma~\ref{lem:compat-context-plug} then tells us that $\npair{(\plug{\context}{\var{comp}_1}, \plug{\context}{\var{comp}_1})} \in \lrec[\succeq,\gc_1](W_1\uplus W_1')$
%     Together with $\plug{\context}{\var{comp}_1} \trg{\term[n]}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_1} \src{\sterm{\gc_1}}$.
% %
%     It follows from $\src{\var{comp}_1} \sconeq \src{\var{comp}_2}$ that also $\plug{\context}{\var{comp}_2} \src{\sterm{\gc_2}}$.
% %
%     It now remains to show that also $\plug{\context}{\var{comp}_2} \trg{\term}$.
%     Take $n'$ the amount of steps in the termination of $\plug{\context}{\var{comp}_2} \src{\sterm{\gc_2}}$.
%     It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\var{comp}_2,\var{comp}_2)} \in \lrcomp[\preceq,\gc_2](W_2)$ for some $W_2$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
%     It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\context,\context)} \in \lrcomp[\preceq,\gc_2](W_2')$ for some $W_2'$ that we can choose such that $W_2 \uplus W_2'$ is defined.
%     Lemma~\ref{lem:compat-context-plug} then tells us that $\npair[n']{(\plug{\context}{\var{comp}_2}, \plug{\context}{\var{comp}_2})} \in \lrec[\preceq,\gc_2](W_2\uplus W_2')$
%     Together with $\plug{\context}{\var{comp}_2} \trg{\term[n']}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_2} \trg{\term}$, concluding the second direction of the proof.

%  The left arrow is proven in a similar manner.
% \end{proof}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End: