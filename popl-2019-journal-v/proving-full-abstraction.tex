%\todo[inline]{Write small introduction. Maybe something about the difficulty of full-abstraction proofs (with references?) but mention that this is easier than some other cases (reference approximate back translation?) because back translation is trivial.}
% \begin{itemize}
% \item Logical relation
% \item FTLR
% \item Sketch high-level structure of the proof
% \end{itemize}
To prove Theorem~\ref{thm:full-abstraction}, we will essentially show that trusted components in \srccm{} are related in a certain way to their embeddings in \trgcm{}, and that untrusted \trgcm{} components are similarly related to their embeddings in \srccm{}.
We will then prove that these relations imply that the combined programs have the same observable behavior, i.e.\ one terminates if and only if the other does.
The difficult part is to define when components are related.
In the next section, we give an informal overview of the relation we define, and then we sketch the full-abstraction proof in Section~\ref{subsec:proof-sketch}.

\subsection{Kripke worlds}
\label{subsec:worlds}
The relation between \srccm{} and \trgcm{} components is non-trivial: essentially, we will say that components are related if invoking them with related values produces related observable behavior.
However, values are often only related under certain assumptions about the rest of the system.
For example, the linear data part of a return capability should only be related to the corresponding \srccm{} capability if no other value in the system references the same inactive stack frame and it is sealed with a seal only used for return pointers to the same code location.
To accommodate such conditional relatedness, we construct the relation as a step-indexed Kripke logical relation with recursive worlds.
\begin{jversion}
In this presentation, we try to include most of the details.
We refer to the conference version of this paper for a presentation\lau{insert reference} with fewer details and emphasis on the intuition.
\end{jversion}

\begin{jversion}
Assumptions about the system that relatedness is predicated on are gathered in (Kripke) worlds.
A world is a semantic model of the memory.
In its simplest form, it is a collection of invariants that the memory must satisfy.
The invariants of a world can vary in complexity and expressiveness depending on the application.
The possible contents of the memory also influences what the world looks like.
For instance, the uniqueness of the linear capabilities on \trgcm{} and \srccm{} are modelled by the worlds.
In order to related \trgcm{} and \srccm{}, we need to model all the features of \srccm{} in the worlds which means we have to model:
\begin{itemize}
\item Three kinds of memory: heap, stack of local frames, and free stack
\item Linearity
\item Call stack
\item Seals
\end{itemize}

\subsubsection{Triple world and regions}
\srccm{}s memory is split in three: heap, free stack and encapsulated local stack frames.
In order to model the three kinds of memory, we simply have three sub-worlds.
That is, our world is defined as
\[
  \World = \Worldh \times \Worlds \times \Worldfs
\]
The sub-worlds are partial maps from names $\RegName$, modelled as natural numbers, to invariants.
In order to define what this actually means, we need to be more precise about what we mean by invariants.
We call the invariants regions because, as we will see later, they turn out to not be invariant.
A region describes a collection of related memory segments, so it is simply represented as a relation over memory segments ($\Rel{\MemSeg \times \MemSeg}$).
Intuitively, we want to be able to say that two memory segments are related when their contents are related.
That is, for every address in the two memory segments, the words that resides there must be related.
In Section~\ref{subsec:logical-relation}, we define precisely what it means for words to be related, but for now consider the intuition.
Say we have two integers, then they are related if they are equal.
If we instead have two capabilities, then they should also be related if they in some sense are equal, but what does it mean for capabilities to be ``equal''?
Intuitively, it should mean that the capabilities give you the same authority, for instance, if you have two executable capabilities, they should observably do the same computation.
As a capability points to a piece of memory, the authority of the capability depends on the contents of that memory.
To say whether two capabilities are related, we must know the possible contents of the memory.
This is exactly what our world express, so our regions will be world indexed, i.e.
\[
  \Worldh = \RegName \parfun (\World \fun \Rel{\MemSeg \times \MemSeg})
\]
At this point, we can see that we have constructed a recursive domain equation.
If we inline $\Worldh$ in $\World$, then we have a circular equation with no solution because the self-reference happens in a negative position.
Luckily, we can solve circular equations if we move to a different domain.
For now, we will ignore the problem and return to the issue in Section~\ref{subsubsec:rec-dom-eq}.

For the sake of readability, we introduce the following notation
\begin{gather*}
  \pwheap = \pi_1(W)\\
  \pwpriv = \pi_2(W)\\
  \pwfree = \pi_3(W)
\end{gather*}

If we just wanted to model the memory, then the above regions would suffice, but we also need the world to model linearity and seals.
In the following subsections, we will gradually introduce the necessary components for our worlds.

\subsubsection{Linearity and world joins}
% Linearity
The linear capabilities of \srccm{} and \trgcm{} guarantee that they have the sole authority over the memory they can reference.
In order to model this uniqueness, we need to keep track of which parts of memory that are uniquely referenced and make sure that only one capability references the unique parts.
%% Bookkeeping done by worlds
We use the world to keep track of what parts of memory must be uniquely referenced by having two kinds of regions: shared and spatial.
If a memory segment is governed by a shared region, then non-linear capabilities may reference it.
On the other hand, if a memory segment is governed by a spatial region, then only linear capability may reference it.
%%% spatial/spatial_owned
We cannot let multiple linear capabilities reference the same memory, so we add ownership to spatial regions.
It is only the spatial owned regions that can be referenced by a capability.
Specifically, we add tags $\spatial$ and $\spatialo$ to the spatial regions:
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \uplus \\
    \{\spatialo \} \times (\World \fun \Rel{\MemSeg \times \MemSeg})\uplus \\ 
  \end{array} \right.
\]
For readability, we also add a tag $\pure$ to the shared regions:
\[
  \Regionh = \{\pure \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) 
\]
For readability we will sometimes use $\spao$ as short for $\spatialo$, $\spa$ as short for $\spatial$, and $\pur$ as short for $\pure$.

% What parts of memory are linear
We will extend the regions further in Sections~\ref{subsubsec:seals}~and~\ref{subsubsec:ft-and-revocation}, but for now we have introduced enough to finish the definition of each of the three sub-worlds.
The sub-world $\Worldh$ specifies the heap memory which can be referenced by both linear and non-linear capabilities, so it should contain both shared and spatial regions.
For this reason, it is defined as
\[
  \Worldh = \RegName \parfun (\World \fun \Regionh + \Regions)
\]
\srccm{} internalizes the \stktokens{} stack, so it can only be referenced by linear capabilities which means that the two stack regions should only have spatial regions.
For instance the $\Worldfs$ is defined as
\[
  \Worldfs = \RegName \parfun (\World \fun \Regions)
\]
$\Worlds$ can also only be referenced by linear capabilities, so it should also only have spatial regions.
$\Worlds$ not only models the memory contents of the local stack frames, it also models the call stack that consists of the stack frames.
Conceptually, this means that each of the stack frames is connected with a return point in some code.
In a traditional C calling convention, the code return point would even be stored in the stack frame.
However, with \stktokens{} a stack frame does not contain any information about the corresponding code return point.
Instead, the stack frame and code return point is connected by the capabilities that reference them as they are sealed with the same seal and together constitute the sealed return pair.
In order to ensure that each call actually returns to the correct point of the code, we must still include the address of the return point in our model.
To this end, each shared region in $\Worlds$ must be paired with a return address:
\[
\Worlds = \RegName \parfun (\World \fun \Regions) \times \Addr 
\]

% Ensuring linearity
The spatial regions add the necessary bookkeeping to the worlds to model linear capabilities.
The logical relation presented in Section~\ref{subsec:logical-relation} uses this bookkeeping to ensure that linear capabilities uniquely references part of memory.

\subsubsection{Seals}
\label{subsubsec:seals}
% StkTokens designate seals for certain purposes, return, closure, etc
In order to guarantee well-bracketed control flow and local-state encapsulation, \stktokens{} designates seals for return capabilities and closure seals and relies on designated seals only being used for their intended purpose.
The designation of return seal is a system invariant that is modelled in the world as a \textit{seal interpretation function}.
This function takes a seal and returns a world-indexed relation that relates all the sealables that may be sealed with this specific seals.
That is
\[
  \Seal \parfun \World \fun \Rel{\SealableCaps \times \SealableCaps}
\]
%% Shared region has a seal indexed invariant that specifies what sealables can be sealed with a specific seal
In Section~\ref{subsubsec:ft-and-revocation}, we will see that not all regions are invariant.
The seal interpretation function should be an invariant, so we need to add it to a type of region that is invariant.
As we will see, shared regions are invariant, so we add the seal interpretation function as follows
\begin{multline*}
  \Regionh = 
  \{\pure \} \times (\World \fun \Rel{\MemSeg\times\MemSeg}) \times \\
  (\Seal \parfun \World \fun \Rel{\SealableCaps \times \SealableCaps})
\end{multline*}

\lau{Maybe add a bit more of explanation? Invariant needed for the LR to make sure that designated seals are used for their purpose. }

\subsubsection{Future worlds and revocation}
\label{subsubsec:ft-and-revocation}
% Memory evolves over time, we need to model this.
The world specifies the contents of the memory.
When a machine executes, the contents of the memory changes and parts of memory may be repurposed.
The world must model these changes.
% Future World
To this end, we have a future world relation $\future$ that describes how worlds may change over time.
For our purpose, relating \trgcm{} to \srccm{}, we are mainly interested in changes to the stack as it is the part that will be repurposed.
Specifically, we need to introduce regions to govern new encapsulated stack frames, and we need to revoke regions that govern call frames that have been popped from the call stack, so the stack frame can be reused for a new call frame.
We allow introduction of new regions simply by extension.
That is, a future world can have new regions that was not present in a past world.
Things are a bit more complicated when it comes to revocation.
\lau{Can we give a more precise explanation of why regions cannot be removed from the world (still in terms of intuition).}
For technical reasons, we need the worlds to be extensional which means that when it comes to removing regions in future worlds, we cannot simply forget about them.
Instead of removing the regions, we keep them around and tag them as removed with a $\revoked$ tag.
This means that the regions should be able to get the $\revoked$ tag which we express in a future region relation.
It is not all regions that need to be able to be revoked.
Specifically, it should only be the regions that specify memory governed by linear capabilities as linear capabilities in some sense can be revoked.
A linear capability is the sole authority over some memory, so when a program possesses a linear capability, it knows for sure that no one else has access to that memory.
This means that it is safe to repurpose that part of memory.
On the other hand, non-linear capabilities may have an alias, so it is not safe to repurpose the memory a non-linear capability has authority over.
It is only spatial regions that specify memory governed by linear capabilities, so we only add the revoked tag to the $\Regions$.
The $\revoked$ region does not specify any memory, so we drop the world indexed relation.
That is, we have
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \uplus \\
    \{\spatialo \} \times (\World \fun \Rel{\MemSeg \times \MemSeg}) \uplus \\
    \{\revoked \}
  \end{array} \right.
\]
The rules for the future region relation are displayed in Figure~\ref{fig:ft-reg-rel}.
% Revocation of spatial regions. 'revocation' of linear capabilities.
All regions are future regions of themselves, so regions are allowed to stay unchanged.
The $\spatial$ regions can become $\revoked$ which means that nothing can depends on the region anymore.
% Spatial -> spatialo ~ affine ?
\todo[inline]{Lau: explain why $\spatialo \future \spatial$ gives us affine capabilitites. This is claimed in the technical report, but I don't see how this is different from revoking $\spatial$ regions and adding a new region with the future world relation.}
\begin{figure}[htb]
  \centering
  \begin{mathpar}
  \inferrule{ }{ \revoked \future (\spatial,\_)}
  \and
  \inferrule{ }{ (\spatialo,H) \future (\spatial,H)}
  \and
  \inferrule{ r \in \Regions \cup \Regionh }{ r \future r}
\end{mathpar}
  \caption{Future region relation.}
  \label{fig:ft-reg-rel}
\end{figure}

With the future region relation in place, we define the future world relation as follows:
\begin{mathpar}
  \inferrule{ \text{for $i \in \{\mathrm{heap},\mathrm{free},\mathrm{priv} \}$} \\ \exists m_i : \RegionName \fun \RegionName, \text{ injective}\ldotp \dom(W'.i) \supseteq \dom(m_i(W.i)) \wedge \forall r \in \dom(W.i)\ldotp W'.i(m_i(r)) \future W.i(r) }
            { W' \future W }
\end{mathpar}
The relation says that each of the three worlds must be an extension of the past world and for each of the existing regions that must be a future region.
% injective function
Note that the future world relation has a mapping function $m_i$ which allows us to change the naming of regions in future worlds.
The definition is a generalization of the standard definition where $m_i$ would be the identity\footnote{In \citet{skorstengaard_reasoning_2017} the future region relation and the reasoning about the awkward example could have been simplified with this future world relation.}.

% TODO monotonicity of regions

\subsubsection{Solving the recursive domain equation}
\label{subsubsec:rec-dom-eq}
%solving the recursive domain equation means that we can present the actual definitions
In the previous sections, we have sketched what we would like our worlds to look like.
However, the worlds we want constitute a self-referential domain equation for which no solution exists in set theory.
% Move to a different domain
Therefore, we need to move to a different domain with enough structure for a solution to exist for such an equation.
We move to a setting where instead of sets we have c.o.f.e.'s (complete ordered families of equivalences), instead of functions we have non-expansive functions, and instead of relations we have downwards-closed relations.
Intuitively, a c.o.f.e. is a set with some extra structure.
Specifically, c.o.f.e.'s have a step-index which provide sufficient structure for us to solve recursive domain equations.
In this section we present the relevant definitions, the final world domain equation, and sketch what needs to be proven to get a solution to the recursive domain equation.

% Cofe's
In the following, we present complete ordered family of equivalences \citep{di_gianantonio_2002}.
We loosely follow the presentation in \citet{birkedal_taste_2014} and introduce the necessary definitions needed for this particular setting.
\begin{definition}[Ordered family of equivalences (o.f.e.)]
An \emph{ordered family of equivalences} is a pair $\cofe{X}$ where $X$ is a set and for each $n$ $\nequal$ is an equivalence relation.
The pair must satisfy the following properties
\begin{enumerate}
\item $\nequal[0]$ is the total relation.
\item For all $n \in \nats$, $\nequal[n] \supseteq \nequal[n+1]$.
\item For all $x,y \in X$,  if for all $n \in \nats$ $x \nequal y$, then $x = y$.
\end{enumerate}
\end{definition}
\noindent One can think of the indexes on the family of equivalences as a measure of precision.
The larger $n$ is, the more refined the equivalence may be.
On the other hand as $n$ decreases, the equivalence becomes more and more imprecise and may be unable to distinguish elements that where distinguishable at higher indices.
At index 0, all precision is lost and the equivalence cannot distinguish anything.
% TODO: Lau write intuition for sequences and why they are necessary.
\begin{definition}[Complete ordered family of equivalences (c.o.f.e.)]
  \label{def:cauchy-sequence}
  A \emph{complete ordered family of equivalences} is an ordered family of equivalences
  $\cofe{X}$ such that every Cauchy sequence in $X$ has a limit
  in $X$.

  Let $\cofe{X}$ be an o.f.e. and $\seq{x}$ be a sequence of
  elements of $X$. Then $\seq{x}$ is a \emph{Cauchy sequence} if
  \begin{align*}
    \forall k \in \nats, \exists j \in \nats, \forall n \geq j, x_j \nequal[k] x_n
  \end{align*}
  or in words, the elements of the chain get arbitrarily close.

  An element $x \in X$ is the \emph{limit} of the sequence $\seq{x}$ if
  \begin{align*}
    \forall k \in \nats, \exists j \in \nats, \forall n \geq j, x \nequal[k] x_n.
  \end{align*}
\end{definition}
% TODO write something here about why the different things (the meassure of the ofe and the guaranteed limits of the cofe) gives us in terms of finding a solution.
Functions between c.o.f.e.'s must retain the added structure relatively to sets.
To this end, we require all our functions to be \emph{non-expansive} which means that $n$-equivalences are preserved.
A function is called \emph{contractive} when it not only retain equivalences but makes them more precise.
\begin{definition}
  \label{def:nonexpansive-contractive-ofe}
  Let $\left(X,\left(\nequal[n]_X\right)_{n=0}^{\infty} \right)$ and $\left(Y,\left(\nequal[n]_Y\right)_{n=0}^{\infty} \right)$ be two ordered families of equivalences and $f$ a function from the set $X$ to the set $Y$.
  We 
  The function $f$ is
  \begin{description}
  \item[non-expansive] when for all $x, x' \in X$, and all $n \in \nats$,
\[
  x \nequal_X x' \implies f(x) \nequal_Y f(x')
\]
  \item[contractive] when for any $x, x' \in X$, and any $n \in \nats$,
\[
  x \nequal_X x' \implies f(x) \nequal[n+1]_Y f(x') 
  \qedhere
\]
  \end{description}
\end{definition}
\noindent The step-indexing provided by c.o.f.e.'s give enough structure to solve the recursive domain equation.
However, this is not the only structure we would like to impose on our sets.

% Not sure this is necessary:
% % preordered cofe constructions
% %% cofe to preordered cofe
% \begin{lemma}[c.o.f.e.'s are preordered c.o.f.e's]
%   A c.o.f.e $\cofe{X}$, is also a preordered c.o.f.e. with the order $=$.
% \end{lemma}
In order to express the domain equation, we must lift all parts of the world definition from sets to c.o.f.e.'s.
That is, we need to lift the sets of partial functions, monotone non-expansive functions, and relations, respectively to c.o.f.e.'s.

We need to lift the set of relations over $R$, $\Rel{R}$, to a c.o.f.e.
However, the set of relations have no inherent step-index which means that we need to add one.
We need to add the step-index in such a way that we can define a family of equivalences that satisfies the c.o.f.e.\ conditions.
To this end, we define the uniform relations over $R$ $\URel{R}$.
%% URel
\begin{definition}[Uniform relation]
  Given a relation $R \subseteq X \times Y$, we define $\URel{R} \subset \powerset{\nats \times R}$ as
  \[
    \URel{R} = \{ A \in \powerset{\nats \times R} \mid \forall n \in \nats\ldotp \forall r \in R \ldotp \npair{r} \in A \implies \forall m \leq n \ldotp (n,r) \in A\}
  \]
  The c.o.f.e.\ $\cofe{\URel{R}}$. Define erasure as
  \[
    \erase{A}{n} \defeq \{(k,a) \in A \mid k < n\}
  \]
  and the family of equivalences as
  \[
    A \nequal B \text{ iff } \erase{A}{n} = \erase{B}{n}
  \]
\end{definition}
The $n$-equivalences of the uniform relation basically forgets everything from the step and up and requires the rest to be equal.
This means that everything is equal at step $0$ as everything is left out.

Next, we define the c.o.f.e.\ of monotone and non-expansive functions.
%% Monotone, non-expansive
\begin{lemma}[The c.o.f.e. of monotone and non-expansive functions]
  Given c.o.f.e.'s $\left(W,\left(\nequal[n]_W\right)_{n=0}^{\infty}, \future_W\right)$ and $\left(U,\left(\nequal[n]_U\right)_{n=0}^{\infty}\right)$ and a preorder $\future$ on $W$, define the preordered c.o.f.e.\ $\left(W \monnefun U,\left(\nequal[n]\right)_{n=0}^{\infty}, \future \right)$ as follows 
  \[
    h \nequal h' \text{ iff } \forall w \in \dom(h) \ldotp h(w) \nequal_U h'(w)
  \]
\end{lemma}
Next, we define the product c.o.f.e.
%% Product
\begin{lemma}[Product c.o.f.e.]
  Given two c.o.f.e's $\left(X, \left(\nequal_X\right)_{n=0}^{\infty}, \right)$ and $\left(Y, \left(\nequal_Y\right)_{n=0}^{\infty}, \right)$ define the product c.o.f.e.\ as $\left(X \times Y, \left(\nequal\right)_{n=0}^{\infty}, \right)$
  where the family of equivalences are defined as follows
  \[
    (x,y) \nequal (x',y') \text{ iff } x \nequal_X x' \wedge y \nequal_Y y'
  \]
\end{lemma}
Similarly to the product c.o.f.e. we have a sum c.o.f.e.
%% Sum
\begin{lemma}[Sum c.o.f.e.]
  Given two c.o.f.e's $\left(X, \left(\nequal_X\right)_{n=0}^{\infty}, \right)$ and $\left(Y, \left(\nequal_Y\right)_{n=0}^{\infty}, \right)$ define the sum c.o.f.e.\ as $\left(X \cup Y, \left(\nequal\right)_{n=0}^{\infty}, \right)$
  where the family of equivalences are defined as follows
  \[
    a \nequal b \text{ iff }
    \left\{
      \begin{aligned}
        a,b \in X \wedge a \nequal_X b \vee \\
        a,b \in Y \wedge a \nequal_Y b
      \end{aligned}
    \right.
  \]
\end{lemma}
\todo[inline]{Lau: Do we need to use the future world relation here? Generally where do we need to use the prior defined relations?}
%% Partial function from set
\begin{lemma}[The c.o.f.e.\ of partial functions]
  Given a set $S$ and a c.o.f.e $P$, the set of partial non-expansive functions $S \parfun P$ can be lifted to a preordered c.o.f.e.\ with family of equivalences
  \[
    f \nequal[0] g \wedge f \nequal g \text{ iff } \forall x \in \dom(f) \ldotp f(x) \nequal g(x)
  \]
\end{lemma}

In Section~\ref{subsubsec:ft-and-revocation}, we described a future world relation which models changes to the memory.
The future world relations is essentially a preorder structure that we would like to impose on our sets.
We impose this structure on our sets by moving to \emph{preordered c.o.f.e.'s}.
% preordered cofe
\begin{definition}[Preordered c.o.f.e.]
  A preordered c.o.f.e.\ is a c.o.f.e.\ equipped with a preorder on $X$, $\left(X, \left(\nequal\right)_{n=0}^{\infty}, \future \right)$. 
  \begin{itemize}
  \item The ordering preserves limits. That is, for Cauchy sequences $\{a_n\}_n$ and $\{b_n\}_n$ in $X$ if $\{a_n\}_n \future\{b_n\}_n$, then $\lim \{a_n\}_n \future \lim \{b_n\}_n$.
  \end{itemize}
\end{definition}
The new structure we add to the set, the preorder, must be consistent with the existing structure which is why it must preserve limits.

Functions between preordered c.o.f.e's must preserve the ordering which means that they must be monotone with respect to the ordering.
% monotone functions
\begin{lemma}
  \label{def:monotone-preordered-cofe}
  Let $\left(X,\left(\nequal[n]_X\right)_{n=0}^{\infty},\future_X \right)$ and $\left(Y,\left(\nequal[n]_Y\right)_{n=0}^{\infty} ,\future_Y\right)$ be two preordered c.o.f.e.'s and $f$ a function from the set $X$ to the set $Y$.
  We 
  The function $f$ is
  \begin{description}
  \item[monotone] when for all $x, x' \in X$,
\[
  x' \future_X x \implies f(x) \future_Y f(x')
\]
  \end{description}
\end{lemma}
% TODO a preordered c.o.f.e. w/ our world?

In some sense, the step-index in a c.o.f.e. gives us a metric that we may use to find a fixed-point.
However, for a fixed-point to exist, the metric must decrease before a self-reference.
As this is not an inherent property of c.o.f.e.'s, we have a c.o.f.e.\ construction called \emph{later} with the sole purpose of decrementing the index.
%% Later cofe
\begin{lemma}[$\blater$ preordered c.o.f.e.]
  Given a preordered c.o.f.e $\left(X, \left(\nequal_X\right)_{n=0}^{\infty}, \future_X \right)$ define
  \[
    \blater\left(X, \left(\nequal\right)_{n=0}^{\infty}, \future \right) = \left(X, \left(\nequal[n]'\right)_{n=0}^{\infty}, \future \right)
  \]
  where
  \[
    x \nequal[0]' x' \wedge x \nequal[n]' x' \text{ iff } x \nequal[n+1] x'
  \]
\end{lemma}
The later needs to guard all negative self-references in a recursive domain equation in order for a solution to exist.
The modality does not have to be placed directly on the self-reference.
For instance, in the following it is placed on the world itself.
The later placement does, however, affect what the logical relation definitions in Section~\ref{subsec:logical-relation} looks like, so in the end it is a matter of taste.
% Solution theorem
\begin{theorem}
  \label{thm:rec-dom-eq-sol}
  There exists a c.o.f.e.\ $\Wor$ and preorder $\future$ such that $(\Wor,\future)$ is a preordered c.o.f.e., and there exists an isomorphism $\xi$ such that
  \[
    \xi : \Wor \cong \blater (\Worldh \times \Worlds \times \Worldfs)
  \]
  and for $\hat{W},\hat{W}' \in \Wor$
  \[
    \hat{W}' \future \hat{W} \text{ iff } \xi(\hat{W}') \future \xi(\hat{W})
  \]
  for $\Worlds$, $\Worldh$, and $\Worldfs$ defined as follows
\[
  \Worldh = \RegionName \parfun (\Regions + \Regionh)
\]
and
\[
  \Worlds = \RegionName \parfun (\Regions \times \Addr)
\]
and
\[
  \Worldfs = \RegionName \parfun \Regions
\]
where $\RegionName = \nats$. $\Regions$ and $\Regionh$ defined as follows
\begin{multline*}
  \Regionh = 
  \{\pure \} \times (\Wor \monnefun \URel{\MemSeg^2}) \times \\
  (\Seal \parfun \Wor \monnefun \URel{\SealableCaps^2})
\end{multline*}
and
\[
  \Regions = \left\{
  \begin{array}{l}
    \{\spatial \} \times (\Wor \monnefun \URel{\MemSeg^2}) \uplus \\
    \{\spatialo \} \times (\Wor \monnefun \URel{\MemSeg^2})\uplus \\ 
    \{\revoked\}
  \end{array} \right.
\]
\end{theorem}
% TODO informally describe how solution to recursive domain equation is found (in terms of what we have to show, not the fixed-point theorem).
%% The category-theoretic solution of recursive metric-space equations, Birkedal et al?
%% Aleš note? Tutorial note?

The domains in Theorem~\ref{thm:rec-dom-eq-sol} are made from the c.o.f.e.\ and preorder c.o.f.e.\ constructions we presented earlier in this section.
They are also the definitions we use in our world definition.
We do not define $\Wor$ to be our worlds.
Instead, we define our world as
\[
  \World = \Worldh \times \Worlds \times \Worldfs
\]
which is easier as we only have to use $\xi$ and move under a later when we have gone into the region and need to work with $\Wor$.

\subsubsection{Joining worlds}
% TODO rewrite this introduction, add text between definitions (?), and reread this section.
In order to express this, we will need to split the ownership of the world in disjoint parts.
%% Disjoint union \oplus
To this end, we introduce the operator $\oplus$ which is a disjoint union.
\begin{definition}[$\oplus$, disjoint union of ownership]
  \[
    W_1 \oplus W_2 = W
  \text{ iff }
  \begin{array}[t]{l}
    \dom(\pwheap) = \dom(\pwheap[W_1]) = \dom(\pwheap[W_2]) \tand \\
    \dom(\pwfree) = \dom(\pwfree[W_1]) = \dom(\pwfree[W_2]) \tand \\
    \dom(\pwpriv) = \dom(\pwpriv[W_1]) = \dom(\pwpriv[W_2]) \tand \\
    \forall r \in \dom(\pwheap) \ldotp \pwheap(r) = \pwheap[W_1](r) \oplus \pwheap[W_2](r) \tand \\
    \forall r \in \dom(\pwfree) \ldotp \pwfree(r) = \pwfree[W_1](r) \oplus \pwfree[W_2](r) \tand \\
    \forall r \in \dom(\pwpriv) \ldotp \pi_1(\pwpriv(r)) = \pi_1(\pwpriv[W_1](r)) \oplus \pi_1(\pwpriv[W_2](r))
  \end{array}
  \]
\end{definition}

\begin{definition}[World disjoint union $\uplus$]
  Given worlds $W_1$, $W_2$, $W$
  \[
    W_1 \uplus W_2 = W
    \text{ iff }
    \begin{array}[t]{l}
      \dom(\pwheap) = \dom(\pwheap[W_1]) \uplus \dom(\pwheap[W_2]) \tand \\
      \dom(\pwfree) = \dom(\pwfree[W_1]) \uplus \dom(\pwfree[W_2]) \tand \\
      \dom(\pwpriv) = \dom(\pwpriv[W_1]) \uplus \dom(\pwpriv[W_2]) \\
    \end{array}
  \]
\end{definition}

The two operators $\uplus$ and $\oplus$ are quite different.
The difference is most clear in the treatment of pure regions: $\uplus$ allows both worlds to have the same pure region, while $\oplus$ forbids this.
To understand this different treatment ($W_1 \uplus W_2$ and $W_1 \oplus W_2$), you should understand that the two are intended for different usages of worlds.
The $W_1 \oplus W_2$ operator treats the worlds as specifications of authority: taking the disjoint union of worlds specifying non-exclusive ownership of a block of memory is allowed and produces a new world that also specifies non-exclusive ownership of world. 
The $W_1 \uplus W_2$  operator treats worlds as specifications of memory contents: taking the disjoint union of worlds specifying the presence of the same memory range is not allowed.
The latter operator is used in the logical relation for components which specifies (among other things) that the world should specify the presence of the component's data memory.
Linking two components then produces a new component with both components' data memory.
The linked component is then valid in a world that has the combined memory presence specifications, not the combined authority.
In other words, $\oplus$ specifies disjoint authority distribution, while $\uplus$ specifies disjoint memory allocation.

Note also that this picture is further complicated by our usage of non-authority-carrying $\spatial$ regions.
They are really only there in a world $W$ as a shadow copy of a $\spatialo$ region in another world $W'$ that $W$ will be combined with.
The shadow copy is used for specifying when a memory satisfies a world: the memory should contain all memory ranges that anyone has authority over, not just the ones whose authority belongs to the memory itself.
For example, if a register contains a linear pointer to a range of memory, then the register file will be valid in a world where the corresponding region is $\spatialo$, while the memory will be valid in a world with the corresponding region only $\spatial$.
However, for the memory to satisfy the world, the block of memory needs to be there, i.e. the memory should contain blocks of memory satisfying every region that is $\spatialo$, $\pure$, but also just $\spatial$ (because it may be $\spatialo$ in, for example, the register file's world).

%% This both makes world a specification of authority as well as a specification of memory.

\subsubsection{Memory satisfaction}
\label{subsubsec:mem-sat}
% Specification
The world can be seen as a specification of the memory contents.
This means that we need to define what it means for a pair of \trgcm{} and \srccm{} memories to satisfy the specification.
% Call stack
The world also keeps track of the structure of the call stack, the allowed uses of designated seals, and linear capability authority, so these things also influence memory satisfaction.
% Well-formedness
The memory satisfaction also acts as a well-formedness judgement.
Our world definition allows regions to be overlapping in the sense that two regions may allow memory segments with the same addresses.
We want the regions to be disjoint, so we easily can get the invariants of each memory segment.

Memory satisfaction is split into four definitions.
At the top-level we have $\memSat{\ms_S,\ms_\stk,\stk,\ms_T}{W}$ which relates the source memory, $\ms_S$, $\ms_\stk$, and $\stk$, from \srccm{} to the target memory $\ms_T$ from \trgcm{}.
The top memory satisfaction splits the target memory in three parts, one for each of the three kinds of source memory.
It also splits the world in three to distribute the authority of the world.
The three parts of $\ms_T$ are related to $\ms_S$, $\ms_\stk$, and $\stk$ by the relations $\lrheap$, $\lrstk[]$, and $\lrfree[]$, respectively. 
The $\lrheap$ relation relates the \srccm{} heap (non-stack memory) to the corresponding heap memory on \trgcm{}.
The $\lrheap$ relation also ensures that the seal invariants associated with each regions do not put invariants on the same seals.
The $\lrstk[]$ relation relates the stack of encapsulated stack frames on \srccm{} to the corresponding memory on \trgcm{}.
The layout of the stack determines the call order, so $\lrstk[]$ also makes sure that the stack frames have the correct order relative to each other as well as the base address of the stack.
Finally, $\lrfree[]$ relates the free part of the stack of \srccm{} to the corresponding memory segment on \trgcm{}.
$\lrfree[]$ also makes sure that that base address of the stack is actually part of the stack.
\begin{definition}[Heap relation]
\label{def:heap-rel}
For a set of seals $\overline{\sigma}$, memory segments $ms$ and $\ms_T$, and worlds $W$ and $W'$, we define the heap relation $\lrheap$ as:
\[
  \npair{(\overline{\sigma},ms,\ms_T)} \in \lrheap(\pwheap)(W') = 
  \left\{
    \begin{array}{l}
      \exists R_\ms : \dom(\activeReg{\pwheap}) \fun \MemSeg \times \MemSeg \wedge \\
      \quad \ms_T = \biguplus_{r \in \dom(\activeReg{\pwheap})} \pi_2(R_\ms(r)) \wedge \\
      \quad \ms = \biguplus_{r \in \dom(\activeReg{\pwheap})} \pi_1(R_\ms(r)) \wedge \\
      \quad \exists R_W : \dom(\activeReg{\pwheap}) \fun \World\ldotp\\
      \qquad W' = \oplus_{r \in \dom(\activeReg{\pwheap})} R_W(r) \wedge\\
      \qquad \forall r \in \dom(\activeReg{\pwheap}), n' < n \ldotp \\
      \qquad \quad \npair[n']{R_\ms(r)} \in  \pwheap(r).H \; \xi^{-1}(R_W(r)) \wedge\\
      \exists R_\var{seal} : \dom(\activeReg{\pwheap}) \fun \powerset{\Seal} \wedge\\
      \quad \biguplus_{r \in \dom(\activeReg{\pwheap})} R_\var{seal}(r)) \subseteq \overline{\sigma} \wedge\\
      \quad \forall r \in \dom(\activeReg{\pwheap})\ldotp \dom(\pwheap(r).H_\sigma) = R_\var{seal}(r)
    \end{array}
  \right.
\]
\end{definition}
Memory satisfaction, and thus also the heap relation, only considers the non-$\revoked$ regions.
The $\lrheap$-relation uses the function $\activeReg{}$ to erase all the $\revoked$ regions from the world.

To a large extend, the way $\lrheap$ is defined is pretty standard.
$\lrheap$ assumes the existence of a partitioning of the \trgcm{} and \srccm{} heap memories that can be turned into pairs each satisfying the invariant of a region.
The heap satisfaction must also respect the world as an authority specification, so the heap satisfaction also partition the authority of the world.
Each of the memory segment pairs must be in the region invariant with respect to a specific world partition which makes sure that uniqueness of linearity of capabilities is respected.

The heap sub-world contains all seal invariants.
Similar to memory segments, only one seal invariant should impose restrictions on a seal which $\lrheap$ makes sure is the case.
\begin{definition}[Free stack relation]
\label{def:free-stack-rel}
\[
  \memSatFStack{ms_\stk,\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \gc = (\_,\stkb,\_,\_) \wedge\\
      W_\var{stack} = \pwfree \wedge \\
      \exists R_\ms : \dom(\activeReg{W_\var{stack}}) \fun \MemSeg \times \MemSeg \wedge \\
      \quad \ms_T = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_2(R_\ms(r)) \wedge \\
      \quad \ms_\stk = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_1(R_\ms(r)) \wedge \\
      \quad \stkb \in \dom(\ms_T) \wedge \stkb \in \dom(\ms_\stk) \wedge \\
      \quad \exists R_W : \dom(\activeReg{W_\var{stack}}) \fun \World\ldotp\\
      \qquad W = \oplus_{r \in \dom(\activeReg{W_\var{stack}})} R_W(r) \wedge\\
      \qquad \forall r \in \dom(\activeReg{W_\var{stack}}),n' < n \ldotp \\
      \qquad \quad \npair[n']{R_\ms(r)} \in  W_\var{stack}(r).H \; \xi^{-1}(R_W(r))
    \end{array}
  \right.
\]
\end{definition}
The free stack relation $\lrfree[]$ is in most regards like the heap relation.
The free stack relation, partitions the \srccm{} and \trgcm{} free stack memory, it partitions the authority of the world, and it requires the memory segment pairs to be related under the
\begin{definition}[Stack relation]
  \label{def:stack-rel}
\[
  \memSatStack{\stk,\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \gc = (\_,\stkb,\_,\_) \wedge \\
      W_\var{stack} = \pwpriv \wedge \\
      \stk = (\opc_0,\ms_0), \dots (\opc_m,\ms_m) \wedge \\
      \forall i \in \{0,\dots,m\} \ldotp (\dom(\ms_i) \neq \emptyset \wedge\\
      \quad \forall j < i \ldotp \forall a \in \dom(\ms_i) \ldotp \forall a' \in \dom(\ms_j) \ldotp \stkb < a < a') \wedge\\
      \exists R_\ms : \dom(\activeReg{W_\var{stack}}) \fun \MemSeg \times \Addr \times \MemSeg \ldotp \\
      \quad \ms_T = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_3(R_\ms(r)) \wedge \\
      \quad \ms_0 \uplus \dots \uplus \ms_m = \biguplus_{r \in \dom(\activeReg{W_\var{stack}})} \pi_1(R_\ms(r)) \wedge \\
      \quad \exists R_W : \dom(\activeReg{W_\var{stack}}) \fun \World \ldotp \\
      \qquad W = \bigoplus_{r \in \dom(\activeReg{W_\var{stack}})} R_W(r) \wedge \\
      \qquad \forall r \in \dom(\activeReg{W_\var{stack}}), n' < n\ldotp \\
      \qquad \quad \npair[n']{(\pi_1(R_\ms(r)),\pi_3(R_\ms(r))} \in W_\var{stack}(r).H \; \xi^{-1}(R_W(r)) \wedge\\
      \qquad \quad \pi_2(R_\ms(r)) = W_\var{stack}(r).\opc \wedge\\
      \qquad \quad \exists i \ldotp \opc_i = W_\var{stack}(r).\opc \wedge \ms_i = \pi_1 (R_\ms(r))
    \end{array}
  \right.
\]
\end{definition}
The stack relation $\lrstk[]$ is similar to the heap relation in some ways.
$\lrstk[]$ also partitions the memory but only the \trgcm{} as the \srccm{} partitions are given as the stack frames, and it also partitions the authority of the world, so it can relate the stack frames such that they respect linearity.
The stack on \srccm{} represents the call stack which means that each stack frame represents a call and its local data.
The operational semantics of \trgcm{} does not enforce the same stack structure, so we make sure that a \srccm{} stack is only related to \trgcm{} stack that has the same structure.
That is for a memory segment that represents a stack frame, all the addresses of memory frames lower in the stack should have strictly smaller memory addresses .
Further, the stack frames should be in the part of the memory we agree to be the stack which means that the addresses should be less than $\stkb$.
Informally, this just means that the stack should be laid out in memory as a downwards growing stack with no addresses below $\stkb$.
% TODO add figure that illustrates this.
According to \stktokens{} (described in \sectionname~\ref{sec:stktokens-explained}), stack frames must be non-empty, so they are distinguishable from a missing stack frame.
For this reason, $\lrstk[]$ requires every stack frame to be non-empty.
Each stack frame in the \srccm{} stack contains an old program pointer.
Each of the old program counters on the stack should correspond to the old program counter recorded in the region of the world associated with the stack frame.
To achieve this, the partitioning function $R_\ms$ also records an $\opc$ for each region, and this $\opc$ should establish the link the region and the stack frame.

In order to tie Definition~\ref{def:heap-rel},~\ref{def:free-stack-rel},~and~\ref{def:stack-rel}, we define memory satisfaction.
Memory satisfaction defines when a \srccm{} memory , consisting of a heap, a stack, and a free stack, relates to a \trgcm{} memory under a world.
\begin{definition}[Memory satisfaction]
  For memory segments $\ms_S$, $\ms_\stk$, and $\ms_T$, stack $\stk$, and world $W$ we define memory satisfaction as
\[
  \memSat{\ms_S,\ms_\stk,\stk,\ms_T}{W} \text{ iff } 
  \left\{
    \begin{array}{l}
      \exists \opc_0, \dots \opc_m, \ms_0, \dots, \ms_m, W_{\var{stack}}, W_{\var{free\_stack}}, W_{\var{heap}} \ldotp\\
      \quad \stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m) \wedge \\
      \quad \ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m  \text{ is defined} \wedge\\
      \quad W = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}} \wedge\\
      \quad\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}, \ms_{T,f}, \ms_{S,f}, \ms_S',\overline{\sigma}\ldotp \\
      \qquad \ms_S = \ms_{f,S} \uplus \ms_S' \wedge \\
      \qquad \ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus \ms_\var{T,heap} \uplus \ms_{T,f} \wedge \\
      \qquad \dom(\ms_{\var{T,stack}} \uplus \ms_\var{T,free\_stack}) = [\baddr_\stk,\eaddr_\stk] \wedge \\
      \qquad \baddr_\stk -1,\eaddr_\stk + 1 \in \dom(\ms_{T,f}) \wedge \\
      \qquad \memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}} \wedge \\
      \qquad \memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}} \wedge \\
      \qquad \npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(\pwheap)(W_{\var{heap}})
    \end{array}
  \right.
\]
\end{definition}
Memory satisfaction partitions the \trgcm{} memory in a heap, stack frames, a free stack and a frame.
The \srccm{} heap is split in two: the active heap and a frame.
Our configurations describe the complete machine state, but we may only be interested in the invariants on part of it.
The frame allows us to basically ignore the part of the memory that won't affect the computation.
Just like the previous memory relations, the world is split in three to make sure that linearity is respected.
Each part of the \srccm{} memory is related to the appropriate part of the memory from \trgcm{} by the relevant relation under a partition of the world.

\stktokens{} requires the stack to not be adjacent to heap or code memory.
This is enforced in the memory satisfaction by requiring that the addresses next to the memory are in the frame.

% TODO take a look at notation and naming in this section. What do we want to call things
% TODO look over the original POPL paper to make sure to reuse all the text that makes sense to reuse.
% TODO add an introduction to c.o.f.e.'s that describe how standard c.o.f.e. constructions always can be used to construct something with a solution.
\end{jversion}


\subsection{The Logical Relation}
\begin{jversion}
\label{subsec:logical-relation}
Using these Kripke worlds as assumptions, we can then define when different \srccm{} and \trgcm{} entities are related: values, jump targets, memories, execution configurations, components etc.
The most important relations are summarised in the following table, where we mention the general form of the relations, what type of things they relate and extra conditions that some of them imply:\\
% latex hack stolen from https://tex.stackexchange.com/questions/78788/align-equations-over-multiple-tabular-rows
% Lau: I find it difficult to easily see what constitutes a row in this table.
% I have updated it to a table I find easier to read.
\newcolumntype{R}{>{$}r<{$}}
\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{M}{R@{${}\in{}$}L}
\begin{tabular}{|M|c|p{4.8cm}|}
  \hline
  \multicolumn{2}{|c|}{General form} & Relates ... & and ...\\
  \hline
  \npair{(w_S,w_T)} & \lrv(W) & values (machine words) & safe to pass to adversarial code\\
  \npair{(w_S,w_T)} & \lrvtrusted(W) & values (machine words) & \\
  \npair{(\reg_S,\reg_T)}  &  \lrr(W) & register files & safe to pass to adversarial code\\
  \npair{(\reg_S,\reg_T)}  &  \lrrtrusted(W) & register files & \\
  \npair{\Phi_S,\Phi_T}  &  \lro & execution configurations & \\
  \npair{(w_S,w_T)}  &  \lre(W) & $\tjmp{}$ targets &\\
  \left(\arraycolsep=1pt\array{l}(w_{S,1},w_{S,2}),\\(w_{T,1},w_{T,2})\endarray\right)  &  \lrexj(W) & $\txjmp{}{}$ targets &\\
  \multicolumn{2}{|c|}{$\memSat{\ms_S,\stk,\ms_\stk,\ms_T}{W}$} & memory & satisfy the assumptions in $W$\\
  \hline
\end{tabular}\\
These relations are defined using a set of mutually recursive equations, with cyclicity resolved through another use of step-indexing.
In Section~\ref{subsubsec:mem-sat}, we already defined memory satisfaction, the relation for memories.
In the following, we define each of the remaining relations and give some intuition about the definitions.
The logical relation we define ends up as a recursive definition.
The circularity is resolved by a step-index in the definitions, but the circularity also poses a chicken and egg kinda situation with respect to the order in which the definitions of the relations should be presented.
There is no canonical way of presenting the logical relation as we are bound to make forward references.
For this reason, we suggest making a cursorily first read through followed by a more thorough read.

\subsubsection{Observation relation}
% TODO write section
\[
  \lro[\preceq,(\ta,\stkb,\_,\_)] = \left\{ \npair{\left(\array{l}\src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})},\\(\ms_T,\reg_T)\endarray\right)} \middle|
    \begin{array}{l}
      \forall i \leq n \ldotp \\
      \quad \src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})} \sterm[i]{\ta,\stkb} \\\qquad\Rightarrow (\ms_T,\reg_T) \term\\
    \end{array}
\right\}
\]
\[
  \lro[\succeq,(\ta,\stkb,\_,\_)] = \left\{ \npair{\left(\array{l}\src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})},\\(\ms_T,\reg_T)\endarray\right)} \middle|
    \begin{array}{l}
      \forall i \leq n \ldotp \\ 
      \quad (\ms_T ,\reg_T) \term[i] \\\qquad\Rightarrow \src{(\ms_S,\reg_S,\stk_S,\ms_{\stk,S})} \sterm{\ta,\stkb}
    \end{array}
\right\}
\]


\subsubsection{Value Relations}
The value relation relates \trgcm{} words to \srccm{} words.
The \srccm{} machine has special tokens that represent the stack capabilities and the return pointer components.
These tokens do not exist on \trgcm{}, but all of the tokens correspond to capabilities on \trgcm{}, and the value relation establishes the link between then.
\citet{skorstengaard_reasoning_2017} defines a logical relation that can be seen as a notion of capability safety.
When they define their value relation, they define based on the question ``What is the most we can allow an adversary to do with this word without breaking memory guarantees?''
This allows them to use the logical relation to reason about arbitrary (untrusted) programs.
We also want to be able to say something about arbitrary (untrusted) programs, but we also want to be able to say something about somewhat arbitrary trusted programs.
In our setting, a trusted program is a well-formed, reasonable program that follows the \stktokens{} calling convention, and an untrusted program is an arbitrary well-formed program.
In order for \stktokens{} to work, it needs access to return seals, but we cannot allow untrusted programs access to the return seals.
A value relation based on what an adversary could do should permit return seals, so such a relation cannot be used to reason about trusted programs.
For this reason, we define two value relations a trusted $\lrvtrusted$ and an untrusted $\lrv$.
It is safe to give trusted programs anything that is safe for an untrusted program, so the trusted value relation is defined as a super set of the untrusted value relation.

In this section, we will from time to time refer to safety of a capability or a word.
In some sense, our logical relation actually ends up as the definition of safety, so when we refer to a capability as \emph{safe} it is in an informal sense where it means that the capability cannot be used break memory invariants. 

In Figure~\ref{fig:value-relation}, we have sketched the two value relations.
This shows that for the most part, words on \srccm{} are related to words on \trgcm{} that are syntactical identical.
The only exception is stack pointers on \srccm{} that are related to linear capabilities on \trgcm{}.
Note that the return pointers of \srccm{} are not related to anything as it is never safe for any program, trusted or not, to have them.
The \srccm{} return pointers should only occur under a seal, and they should only be used to jump to in which case the \srccm{} semantics transforms them to the capabilities they correspond to.

The value relation is defined in terms of a number of auxiliary definitions.
In the following, we introduce a number of \emph{standard regions} that express common requirements on memory. Based on the standard regions, we define what we call \emph{permission based conditions}, conditions that a capability with a specific permission must satisfy to be safe.

% The old section:
% Note first how we have two value relations, whose definitions are sketched in Figure~\ref{fig:value-relation}.
% The difference is that the untrusted value relation $\lrv(W)$ does not just express that the two values are related, but also that they are safe to pass to an untrusted adversary, i.e. they cannot be used to break LSE and WBCF.
% The trusted value relation does not have the latter requirement and is a superset of the former.

% Both relations trivially include numbers $(i,i)$ which are always related to themselves.
% The untrusted value relation also includes stack pointers and the underlying linear capability (with the same (non-executable) permission, range of authority, and current address), as well as syntactically equal memory capabilities, seals and sealed values, all under certain conditions involving the world $W$ and the capability's properties.

% Roughly, for stack capabilities, the omitted condition requires that the world contains a $\spatialo$ region governing this part of the stack.
% For memory capabilities $((\perm,\lin),\baddr,\eaddr,\aaddr)$, a region in the world must govern memory $[\baddr,\eaddr]$, either $\spatialo$ or $\pure$, depending on the linearity $\lin$ of the capability.
% If the capability is executable ($\perm \in \{\rx,\rwx\}$), then we additionally require that the governing region is a code region and that the two capabilities are related $\mathrm{jmp}$ targets, as expressed by the relation $\lre(W)$, in any future world (see below).

% Seals allocated to trusted code are related to themselves only by $\lrvtrusted(W)$, but other seals are in both value relations.
% Sealed values are in both relations essentially when the sealed values satisfy the relation that was registered for the seal in a region of the world.
% Additionally, when they are combined with any other pair of values related by that relation, they must be related as $\txjmp{}{}$ targets (i.e. in $\lrexj(W)$).
% Finally, capabilities to code memory are related to themselves in the trusted value relation ($\lrvtrusted(W)$) when there is an appropriate code region in the world.
% They are not in the untrusted value relation because the code memory contains copies of the return seals used by the code, which must not end up in the hands of an adversary.

\begin{figure}
  \centering
  \begin{align*}
  \lrv(W) ={} & \left\{ \npair{\stpair[.]{i}{i}} \;\middle|\; i \in \ints \right\}\cup \\ &
%
    \left\{
%    \begin{array}{l}
      \npair{\left(\src{\stkptr{\perm,\baddr,\eaddr,\aaddr}}, ((\perm,\linear),\baddr,\eaddr,\aaddr) \right)} \mid\dots
        % \perm \not\in \{\rx,\rwx\} \tand \\
        % % \perm = \noperm & \Rightarrow & \npair{(\linear,\baddr,\eaddr)} \in
        % % \lrp(W) \wedge \\
        % \quad\perm \in \{\ro,\rw\} \Rightarrow \npair{[\baddr,\eaddr]} \in \stackReadCond{W} \tand \\
        % \quad\perm = \rw  \Rightarrow \npair{[\baddr,\eaddr]} \in \stackWriteCond{W}
%    \end{array}
    \right\} \cup \\ &
%
    \left\{
%    \begin{array}{l}
      \npair{\left(\src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}}, \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \right)} \mid 
      % [\sigma_\baddr,\sigma_\eaddr] \mathrel{\#} (\sigrets \cup \sigcloss) \wedge 
                       \dots 
      % \quad\forall \sigma' \in [\sigma_\baddr,\sigma_\eaddr] \ldotp \exists r \in \dom(\pwheap) \ldotp \\
      % \quad \pwheap(r) = (\pure,\_,H_\sigma) \tand H_\sigma \; \sigma' \nequal (\lrv \circ \xi)
%    \end{array}
    \right\} \cup \\ &
        \left\{
%    \begin{array}{l}
      \npair{\left(\src{\sealed{\sigma,\vsc_S}}, \sealed{\sigma,\vsc_T} \right)} \mid \dots
      % \isLinear{\src{\vsc_S}} \text{ iff } \isLinear{\vsc_T} \tand \\
      % \quad\exists r \in \dom(\pwheap), \sigrets,\sigcloss,\mscode \ldotp \pwheap(r) = (\pure,\_,H_\sigma) \tand \\
      % \qquad H_\sigma \; \sigma \nequal H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \mscode \; \gc \; \sigma \tand \\
      % \qquad \npair[n']{\stpair[.]{\vsc_S}{\vsc_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W) \text{ for all $n' < n$}\tand\\
      % \qquad (\nonLinear{\src{\vsc_S}} \Rightarrow \\
      % \qquad\quad\forall W' \future \purePart{W}, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      % \qquad \qquad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o)) \tand \dots
      % % \quad (\isLinear{\src{\vsc_S}} \Rightarrow \\
      % % \qquad\forall W' \future W, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      % % \qquad \quad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o)) \wedge \\
%    \end{array}
    \right\}\cup\\ &
%
     \left\{ \npair{\left(\src{((\perm,\lin),\baddr,\eaddr,\aaddr)}, ((\perm,\lin),\baddr,\eaddr,\aaddr)\right)} \mid \dots
    % \begin{array}{l}
    %   [b,e] \mathrel{\#} \ta \tand\\
    %   \begin{array}{r l l }
    %     % \perm = \noperm & \Rightarrow & \npair{(\lin,\baddr,\eaddr)} \in
    %     % \lrp(W) \wedge \\
    %     \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \readCond{\lin,W} \wedge\\
    %     \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \writeCond{\lin,W} \wedge\\
    %     % we are excluding rwx pointers.
    %     \perm \neq \rwx \wedge \\
    %     % \perm = \rwx &\Rightarrow&
    %     % \array[t]{l}\npair{(\{\rwx,\rx\},\baddr,\eaddr)} \in \execCond{\lin,W}
    %     % \wedge \\
    %     % \npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W} \endarray\\
    %     \perm = \rx &\Rightarrow& \array[t]{l}\npair{[\baddr,\eaddr]} \in \execCond{W} \wedge\\
    %     \npair{[\baddr,\eaddr]} \in \xReadCond{W} \wedge \\
    %     \lin = \normal \\ \endarray
    %   \end{array}
    % \end{array}
     \right\} \\
%  \end{array}
  \lrvtrusted(W) ={} & \lrv(W)\cup \\
%  \begin{array}[t]{l}
    &\left\{
    %\begin{array}{l}
      \npair{\left(\src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}}, \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \right)} \mid
      % [\sigma_\baddr,\sigma_\eaddr] \subseteq(\sigrets \cup \sigcloss) \wedge 
      \dots 
    %           \exists r \in \dom(\pwheap) \ldotp \\
    %           \quad \pwheap(r) \nequal \codereg{\sigrets,\sigcloss,\mscode,\gc} \tand \dom(\mscode) \subseteq \ta \\
    %           \quad \tand [\sigma_\baddr,\sigma_\eaddr] \subseteq (\sigrets\cup\sigcloss) \tand \sigrets \subseteq \gsigrets \tand \sigcloss \subseteq \gsigcloss
    % \end{array}
    \right\} \cup \\
    & \left\{
%    \begin{array}{l}
      \npair{\left(\src{((\perm,\normal),\baddr,\eaddr,\aaddr)},((\perm,\normal),\baddr,\eaddr,\aaddr) \right)} \mid \perm \le \rx \wedge \dots
    %   \quad \perm \sqsubseteq \rx \tand 
    %    [\baddr,\eaddr] \subseteq \ta \tand 
    %    \npair{[\baddr,\eaddr]} \in \xReadCond[\square,\gc]{W} 
    % \end{array}
    \right\}
%  \end{array}
\end{align*}
\caption{Sketches of the trusted and untrusted value relation. The untrusted and trusted value relation both relates \srccm{} and \trgcm{} words. The untrusted value relation $\lrv$ relates words that are safe to give to untrusted programs and $\lrvtrusted$ relates words that are safe to give to trusted programs.}
\label{fig:value-relation}
\end{figure}

% \begin{figure}
%   \centering
% \begin{align*}
%   \lrrg{\trust}(W) &= \left\{ \npair{\stpair{\reg}{\reg}} \middle|
%     \begin{array}{l}
%     % Lau: Consider using \Wor instead of \World as we have not made a distinction between the two.
%       \exists S : (\RegName \setminus \{\pcreg \})\fun \World \ldotp \\
%       \quad W = \bigoplus_{r \in (\RegName\setminus (\{\pcreg \} \cup R))} S(r) \wedge \\
%       \quad \forall r \in \RegName \setminus \{\pcreg \}\ldotp \npair{\stpair[.]{\src{\reg_S(r)}}{\reg_T(r)}} \in \lrvg{\trust}(S(r))
%     \end{array}
%             \right\}\\
%   \lre(W)&= \left\{ \begin{array}{l}
%     \npair{\stpair[.]{w_{c,S}}{w_{c,T}}} | \\
%     \quad\forall \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk}, W_\lrrs , W_\lrm \ldotp \\
%     \qquad\npair{\stpair{\reg}{\reg}} \in \lrr(W_\lrrs ) \tand \memSat{\stpair[.]{\ms_S,\stk,\ms_\stk}{\ms_T}}{W_\lrm} \tand\\
%     \qquad\Phi_S = \src{(\ms_S,\reg_S,\stk, \ms_\stk)} \tand \Phi_S' = \Phi_S \updReg{\pcreg}{w_{c,S}} \tand\\
%                      \qquad\Phi_T = (\ms_T,\reg_T) \tand \Phi_T' = \Phi_T\updReg{\pcreg}{w_{c,T}} \tand \\
%                      \qquad W \oplus W_\lrrs \oplus W_\lrm \text{ is defined }\\
%     \qquad\qquad\Rightarrow\npair{\left(\Phi_S', \Phi_T' \right)}\in \lro
%   \end{array}
%   \right\}
% \end{align*}
%   \begin{align*}
%   \lro[] ={}&\{ \npair{\left(\src{\Phi_S},\Phi_T\right)} \mid
%     \src{\Phi_S \sterm{}} \Leftrightarrow \Phi_T \trg{\term} \}
% \end{align*}
% \caption{Simplified sketches of the register file relation $\lrr(W)$, the relation
%   for $\com{jmp}$ targets $\lre(W)$  and the observation relation $\lro(W)$.}
% \label{fig:obs-rel}
% \end{figure}

\paragraph{Standard regions}
\label{par:standard-regions}
The notion of regions we defined in Section~\ref{subsec:worlds} is general enough to allow a wide variety of regions.
There are, however, some regions that may seem more natural or standard than others.
In particular, when it comes to capability safety, it seems natural to have a region that requires everything in memory to be safe.
This is exactly what we refer to as a \emph{standard region} because we usually define a region like that along with a logical relation. 

We define a $\pure$, $\spatial$, and $\spatialo$ standard. They all have the same invariant which is defined as follows:
\[
  H_A^{\mathrm{std},\square} \; \gc \; \hat{W} \defeq \left\{ \npair{\ms_S,\ms_T} \middle|
    \begin{array}{l}
      \dom(\ms_S) = \dom(\ms_T) = A \wedge \\
      \exists S : A \fun \World \ldotp \xi(\hat{W}) = \oplus_{\aaddr \in A} S(\aaddr) \wedge\\ % TODO there should be a later on the right side of the equality?
      \quad \forall \aaddr \in A \ldotp \npair{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))
    \end{array}
  \right\}
\]
The standard region invariant requires the memory segment pairs to have a specific address space $A$.
Further, the two memory segments must contain words from the untrusted value relation.
The memory segments may contain linear capabilities, so we must distribute the ownership of the world between each memory cell which the function $S$ takes care of.
Note that the invariant takes a $\hat{W}$ from $\Wor$ as argument which means that we must apply the isomorphism $\xi$ before the world can be used.
Using this invariant, we define the standard $\spatial$ and $\spatialo$ regions as follows:
\[
  \stdreg{A,\gc}{v} \defeq (v,H_A^{\mathrm{std},\square} \; \gc) , v \in \{\spatial,\spatialo\}
\]
and the standard $\pure$ regions as follows
\[
  \stdreg{A,\gc}{\pure} \defeq (\pur,H_A^{\mathrm{std},\square} \; \gc, \lambda \_ \; \_ \ldotp \emptyset)
\]
Note that the standard $\pure$ region puts no requirements on seals.

Sometimes we need to know that the contents of a memory segment stays the same.
For instance, the contents of encapsulated stack frames don't change which we need to be able to rely on.
To express this, we define a \emph{static region}.
The static region is parameterised with a memory segment pair which is the only memory segment pair the region accepts.
The memory invariant is defined as follows
\[
  H^\mathrm{sta,\square}_{\stpair{\ms}{\ms}} \; \gc \defeq \left\{ \npair{\stpair{\ms}{\ms}} \middle| 
    \begin{array}{l}
      \dom(\ms_S) = \dom(\ms_T) \wedge \\
      \exists S : \dom(\ms_S) \fun \World \ldotp \xi(W) = \oplus_{\aaddr \in \dom(\ms)} S(\aaddr) \wedge\\
      \quad \forall \aaddr \in \dom(\ms_S) \ldotp \npair{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))
    \end{array}
\right\}
\]
The region also requires the static memory to contain words from the untrusted value relation.
Which just means that the stack shouldn't be used for return seals, closure seals, and code pointers for trusted code.
With the memory invariant, we define the static region as follows:
\[
  \stareg[\stpair{\ms}{\ms},\gc]{v,\square} \defeq (v,H^\mathrm{sta,\square}_{\stpair{\ms}{\ms}} \; \gc) , v \in \{\spatial,\spatialo\}
\]
A $\pure$ static region can be defined in a similar fashion to that of the standard region.

In our results, we assume that we execute well-formed components which allows us to make certain assumptions about the code we execute.
We express these assumption in what we call a \emph{code region}.
The invariant of the code region is defined as
\begin{multline*}
  H^\mathrm{code} \; \sigrets \; \sigcloss \; \code \; (\ta,\_,\gsigrets,\gsigcloss) \; \hat{W} =\\
  \left\{\npair{\arraycolsep=0pt\left(\array{l}\code \uplus \mspad,\\ \code \uplus \mspad\endarray\right)} \middle|
    \begin{array}{l}
    \dom(\code) = [\baddr,\eaddr] \wedge \\
      ([\baddr - 1, \eaddr + 1] \subseteq \ta \wedge \sigrets \subseteq \gsigrets \wedge \sigcloss \subseteq \gsigcloss \wedge \trust = \trusted) \vee \\
      \quad ([\baddr-1,\eaddr+1]\mathrel{\#} \ta \wedge \sigrets = \emptyset \wedge \trust =\untrusted) \wedge \\
      \mspad = [\baddr-1 \mapsto 0] \uplus [\eaddr + 1 \mapsto 0]\wedge\\
      \sigrets,\sigcloss,\ta \vdash_{\mathrm{comp-code}} \code \wedge\\
      \forall a \in \dom(\code)\ldotp\\
      \quad\npair{(\code(a),\code(a))} \in \lrvg{\trust}(\purePart{\xi(\hat{W})})
    \end{array}
  \right\}
\end{multline*}
The code region is a lot more restrictive that the standard region.
It basically only allows one memory segment, namely $\code$ padded with zeroes to make sure that two capabilities cannot be spliced to cause unintended control-flow.
We will use the relation to reason about trusted components (well-formed and reasonable) as well as untrusted components (well-formed).
The assumptions we can make on the code depends on whether it is part of a trusted or untrusted component.
This is captured by requiring the contents of the code memory to be in the trusted or untrusted value relation depending on the trustworthiness of the code.
This is, if all the code memory addresses are in the trusted address space and the seals are from the global seals, then it is trusted.
On the other hand, if the code memory addresses are disjoint from the trusted addresses and there are no return seals, then it is untrusted.
In either case, the words should be in the value relation with respect to the $\purePart{}$ of the world which means that the code memory cannot contain linear capabilities.
% TODO promote $\purePart{}$ from appendix to paper - used a few times.

\stktokens{} rely on proper seal usage to guarantee well-bracketed control-flow and local state encapsulation.
This means that components must use return and closure seals for their intended purpose.
The code region has a seal invariant $H^\mathrm{code,\square}_\sigma$ to guarantee that the return and closure seals of the region are used correctly.
The seal invariant is displayed in Figure~\ref{fig:code-reg-seal-inv}.
The return seals $\sigrets$ in a code region should only be used to seal return pointers.
That is on \srccm{} they should only be used to seal $\retptrc{}$ and $\retptrd{}$.
\begin{figure}
  \centering
  \begin{multline*}
  H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \code \;
  (\ta,\stkb,\_,\gsigrets) \; \sigma \; \hat{W} \defeq \\
  \begin{array}[t]{l}
\left\{
    \begin{array}{l}
\left. \npair{\arraycolsep=0pt\left(\array{l}\retptrc(\baddr,\eaddr,\aaddr'+\calllen),\\((\rx,\normal),\baddr,\eaddr,\aaddr)\endarray\right)} \middle| \right. \\
      \begin{array}{l}
        \sigrets \subseteq \gsigrets \tand \\
        \dom(\code) \subseteq \ta \tand\\
        \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
        \aaddr = \aaddr' + \retoffset \tand \\
        \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets \tand\\
        \lbrack \aaddr',\aaddr' + \calllen -1 \rbrack \subseteq \lbrack \baddr, \eaddr \rbrack
      \end{array}
    \end{array}
      \right\} \cup \\
\left\{
    \begin{array}{l}
\left. \npair{\arraycolsep=0pt\left(\array{l}\retptrd(\baddr,\eaddr),\\((\rw,\linear),\baddr,\eaddr,\baddr-1)\endarray\right)} \middle| \right. \\
      \begin{array}{l}
        \sigrets \subseteq \gsigrets \tand \\
        \dom(\code) \subseteq \ta \tand\\
        \exists r \in \addressable{\linear,\pwpriv[\xi(\hat{W})]} \ldotp \\
        \quad\pwpriv[\xi(\hat{W})](r).H \nequal (\stareg[(\ms_S,\ms_T),(\ta,\stkb)]{\spao,\square}, \aaddr'+\calllen) \tand \\
        \quad \dom(\ms_S) = \dom(\ms_T) = [\baddr,\eaddr] \tand\\
        \quad \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
        \quad \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets
      \end{array}
    \end{array}
    \right\} \\
  \end{array}\\
    \text{ for } \sigma \in \sigrets
\end{multline*}
\begin{multline*}
  H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \code \;
  (\ta,\stkb,\gsigcloss,\gsigrets) \; \sigma \; \hat{W} \defeq \\
  \left\{
    \begin{array}{l}
\left. \npair{(\vsc, \vsc' )} \middle| \right. \\
      \begin{array}{l}
        (\dom(\code) \mathrel{\#} \ta \tand \npair{(\vsc,\vsc')} \in \lrv \; \xi(\hat{W})) \tor\\
        (\dom(\code) \subseteq \ta \tand \sigcloss \subseteq \gsigcloss \tand \sigrets \subseteq \gsigrets \tand \\
         \quad((\exec{\vsc} \wedge \npair{(\vsc,\vsc')} \in \lrvtrusted \; \xi(\hat{W})) \vee\\
         \quad\ (\nonExec{\vsc} \wedge\npair{(\vsc,\vsc')} \in \lrv \; \xi(\hat{W}))))
      \end{array}
    \end{array}
  \right\}\\
  \text{ for } \sigma \in \sigcloss
\end{multline*}

\caption{The seal invariant for code regions.}
\label{fig:code-reg-seal-inv}
\end{figure}
% Code return pointer
If we allowed any $\retptrc$ to be sealed, then we could not be sure that it comes from a call even though it should only be possible to get a return pointer from a call.
For this reason, we require that the \srccm{} return pointer actually points to the first address after a call.
For a \trgcm{} capability related to a \srccm{} code return pointer, we do not require that it points to the first address after the call because it needs to execute the return instructions first.

% Data return pointer
For sealed data return pointers, we need to know that the world contains a region that governs the local stack frame.
That is, there should be a static region with the contents of the stack frame.
The fact that it is static means that the contents will remain the same.
The region that governs the stack frame must come from the private world which means that it is paired with a return address.
We require that the return address actually corresponds to a return address for a call in the code. 

% Closure seals
Unlike return seals, both trusted and untrusted components can have closure seals.
For untrusted components (components with their code address space disjoint from the trusted address space), we allow everything in the untrusted value relation to be sealed.
Intuitively, untrusted components are assumed to have access to words from the untrusted value relation, but we cannot know how the words are used, so we need to assume that they may be sealed.
% TODO trusted components
Trusted components only use closure seals for sealed capability pairs that represent actual closures.
The code capability for a closure must point to the code memory because it is the only part of memory that is executable.
It is not safe for untrusted components to have a capability for a trusted components code (it could be used to read return capabilities or start execution in the middle of a call), so capabilities for the code memory of a trusted component is in the trusted value relation.
While it is not safe to give a bare capability for a trusted components code memory, it can be perfectly safe to give a sealed capability for a trusted components code.
For this reason, the seal invariant allows executable capabilities from the trusted value relation to be sealed with a closure seal.
When it comes to the data capability of a closure, we just require that it comes from the untrusted value relation because the trusted value relation contains nothing that makes sense to seal as the data capability (we return to the specific contents of the two value relations in a later paragraph).

With the memory invariant and seal invariant in hand, we define the code region as follows:
\[
  \codereg{\sigrets,\sigcloss,\code,\gc} \defeq (\pure, H^\mathrm{code,\square} \; \sigrets \; \sigcloss \; \code \; \gc, H^\mathrm{code}_\sigma \; \sigrets \; \sigcloss \; \code \; \gc)
\]
The code region is $\pure$ because it needs to contain a seal invatiant and because we assume that code pointers are non-linear.

\paragraph{Permission based conditions}
\label{par:perm-cond}
% TODO add brief intro to paragraph

The world can be seen as an authority specification which means that it dictates what kind of capabilities can address a certain part of memory.
Specifically, linear capabilities can only address memory governed by a $\spatialo$ region, and non-linear capabilities can only address memory governed by a $\pure$ region.
All the permission based condition we define project the regions that the capability may address from the world.
The following $\addressable$ function takes care of the projection:
\[
  \addressable{\lin,W} \defeq
  \begin{cases}
    \{ r \mid W(r) = (\pure,\_) \} & \text{if $\lin = \normal$} \\
    \{ r \mid W(r) = (\spatialo,\_) \}  & \text{otherwise (i.e. $\lin = \linear$)} \\
  \end{cases}
\]

% TODO introduce read condition
We capture the essence of what it means for a capability with read permission to be safe in the condition $\readCond{}$.
% each of the regions upper bounded by std region
The main purpose of $\readCond{}$ is to make sure that only safe words can be read from the memory the read capability governs.
This is done by putting an upper bound on what requirements a region can impose on the memory segments governed by the capability.
In particular a region that governs the memory a read capability has access to can at most allow safe values to be read.
Without this requirement, a read capability could potentially be used to break memory invariants if were used to read capabilities that has the authority to break memory invariants.
The condition is defined as follows
\[
  \readCond{\lin,W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\lin, \pwheap} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \ldotp\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge\\
      \qquad (\lin = \linear \Rightarrow \forall r \in S \ldotp |R(r)|  = 1) \wedge\\
      \qquad \forall r \in S \ldotp \pwheap(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H
    \end{array}
  \right\}
\]
% splicing and what part of the range each region governs
The $\readCond{}$ is compatible with all the operations that can be performed on capabilities.
This means that if two capabilities, for which $\readCond{}$ holds, are spliced together, we should be able to establish that $\readCond{}$ holds for the resulting capability.
To support this, we require the presence of a set of regions $S$ that governs the addresses the capability has authority over rather than just a single region.
If we need to establish the $\readCond{}$ after a splice, we can simply use union of the regions that witnessed the $\readCond{}$ of the two individual capabilities.
We also need to support splitting which is no problem for non-linear capabilities as the same $\pure$ region can be used to establish the $\readCond{}$ for multiple non-linear capabilities.
On the other hand, a $\spatialo$ region can only be used to establish the $\readCond{}$ for one linear capability because the ownership of a spatial region can only go to one world when splitting the ownership.
None the less, we need to support arbitrary splitting of linear capabilities, which means that $\readCond{}$ must make sure that the necessary regions are in the world to argue that the result of a split preserves $\readCond{}$.
This is why, $\readCond{}$ requires all regions to only govern one address when the capability is linear.
This means that after a split, the authority of the regions for the bottom half of the split result can go to one capability and the rest can go to the top half.

The upper bound on requirements that can be imposed on the memory the read capability has access to is specified on all of the regions that govern the memory.
The upper-bound is specified in terms of the standard region $\stdreg{R(r),\gc}{\pur}$.
That is, the memory segments permitted by the region should be an $n$-subset (a subset that only takes into account elements with an index up to, but not including, $n$).
This means that everything the region permits must at the very least be safe.

% TODO is there a point to be made about limited write for reading of linear capabilities?
% When a linear capability is read from memory, the source address must be cleared.
% This means that a linear capability with read permission also has a very limited form of write authority which only permits it to write zeroes.

Similarly to $\readCond{}$, we define a condition that captures the essence of what it means for a capability with writer permission to be safe.
We call this condition $\writeCond{}$.
A capability with write permission can be used to write to memory.
The question is, what can we safely allow to be written to memory without any memory invariants being broken.
It may come as a surprise that the answer to this is anything - even words that are unsafe.
The intuition behind this is that if you managed to write something that can break memory invariants, it would not be possible to read it back again as you need read permission for that, and if the capability had read permission, then $\readCond{}$ would make sure that the word would have to be safe\footnote{It should not be possible to obtain a capability that can be used to break invariants, after all if one was obtained, memory invariants could be broken. However, the $\writeCond{}$ tries to capture the essence of safety and in principle it is safe to write an unsafe capability that cannot be read back.}.
We do, however, impose a bound on what should be permitted to be written and that is a lower bound because it should at least be allowed to write anything that is safe.

Before we get to the definition of $\writeCond{}$, we need to introduce one auxiliary definition.
When a write capability makes a change to memory, the change must be permitted by the regions that govern the memory it has authority over for it to be safe.
Given a write capability it should be possible to transform the memory from one allowed by the region to another also allowed by the region.
However, only one memory address can be updated at a time, so in order to make such a transformation one has to update one address at a time.
This should not break any memory invariants, so we require all the memories that we could go through to make the transformation to also be permitted by the region.
This is captured by address stratification.
\begin{definition}
  \label{def:address-stratified}
  We say that a region $\iota = (\_,H,\_)$ is address stratified iff
  \[
    \begin{array}{l}
      \forall n, \src{\ms_S},\ms_T,\src{\ms_S'},\ms_T',s,\hat{W}\ldotp \\
      \quad \npair{\stpair{\ms}{\ms}}, \npair{\stpair[.]{\ms_S'}{\ms_T'}} \in H \; \hat{W} \wedge \\
      \quad \dom(\src{\ms_S}) = \dom(\ms_T) = \dom(\src{\ms_S'}) = \dom(\ms_T') \\
      \quad \Rightarrow \\
      \qquad \forall \aaddr \in \dom(\ms_S) \ldotp \npair{(\src{\ms_S}\update{\aaddr}{\src{\ms_S'}(\aaddr)},\ms_T\update{\aaddr}{\ms_T'(\aaddr)})} \in H \; \hat{W}
    \end{array}
  \]
\end{definition}
We define $\writeCond{}$ as follows
\[
  \writeCond{\lin,W} \defeq \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\lin, \pwheap} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats}\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge\\
      \qquad (\lin = \linear \Rightarrow \forall r \in S \ldotp |R(r)|  = 1) \wedge\\
      \qquad \forall r \in S \ldotp \pwheap(r).H \nsupeq \stdreg{R(r),\gc}{\pur}.H \wedge\\
      \qquad \quad \pwheap(r) \text{ is address-stratified}
    \end{array}
  \right\}
\]
The definition of $\writeCond{}$ is very similar to $\readCond{}$.
Support for split and splice is done in the same way, and the bound is defined in terms of the standard region.

The $\readCond{}$ and $\writeCond{}$ specifically uses the heap sub-world which means that it can only be used for heap capabilities.
This means that we cannot use it for stack capabilities.
To take care of stack capabilities, we define two more conditions a $\stackReadCond{}$ and $\stackWriteCond{}$.
The two new condition are essentially the same as the $\readCond{}$ and $\writeCond{}$ except that they use the free stack sub-world and assume that the capability is linear as all stack capabilities are linear.
Note that we do not have any condition that talks about the stack-frames sub world because we should never have a capability that allows us to directly read or write from that part of memory.
\[
  \stackReadCond{W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\linear, \pwfree} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \ldotp\\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge \\
      \qquad \forall r \in S \ldotp |R(r)| = 1\\
      \qquad \forall r \in S \ldotp \pwfree(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H
    \end{array}
  \right\}
\]
\[
  \stackWriteCond{W} = \left\{ \npair{A}) \middle| 
    \begin{array}{l}
      \exists S \subseteq \addressable{\linear, \pwfree} \ldotp \\
      \quad \exists R : S \fun \powerset{\nats} \\
      \qquad \biguplus_{r\in S} R(r) \supseteq A \wedge \\
      \qquad \forall r \in S \ldotp |R(r)| = 1 \wedge \\
      \qquad \forall r \in S \ldotp \pwfree(r).H \nsupeq \stdreg{R(r),\gc}{\pur}.H \wedge\\
      \qquad \quad \pwfree(r) \text{ is address-stratified}
    \end{array}
  \right\}
\]
The final permission, we define conditions for is the execute permission.
We define two conditions $\execCond{}$ and $\xReadCond{}$.
The $\execCond{}$ captures what operations an execute-capability can be used for, i.e.\ execution.
The $\xReadCond{}$ captures some additional read assumptions we can make on a capability when we know the capability is executable.

The $\execCond{}$ intuitively says that an execute capability is safe when any capability that can be derived from it is safe as a program counter now and in the future.
We later define the $\lre$-relation which captures what it means for a word to be safe as a program counter, but for now it suffices to think of it as a program counter that causes an execution that does not break memory invariants.
An executable capability can have its range of authority shrunk or its current address changed which changes what it does and thus potentially whether it keeps memory invariants.
For this reason, the condition requires that any capability with a derived range of authority and a current address that range is safe to use for execution.
The $\execCond{}$ is quantified over all future worlds of the $\purePart{}$ of $W$. The $\purePart{}$ function strips the world of all spatial ownership.
This means that the capability cannot depend on linear capabilities, and when we define the logical relation, we even require the executable capability to not be linear.
It is not clear whether a linear executable capability would even be useful because there is no way to move it out of the $\pcreg$-register without crashing the execution.
This may sound like an ideal option for constructing something that can be executed once, however, most programs rely on loading other capabilities or seal sets for the program counter which is not possible.
\begin{align*}
  \execCond{W} &=
  \left\{ \npair{A} \middle|
    \begin{array}{l}
      \forall n' < n, W' \future \purePart{W}\ldotp \forall b',e'\ldotp \forall \aaddr \in [b',e'] \subseteq A \ldotp\\
      \quad \npair[n']{\stpair[.]{((\rx,\normal),\baddr',\eaddr',\aaddr)}{((\rx,\normal),\baddr',\eaddr',\aaddr)}} \in \lre(W')
    \end{array}
    \right\}
\end{align*}
The $\readCond{}$ condition by itself allows many different regions and thus potentially many different memories.
However, when we have a read capability with execute permission, we know that the capability must point to a piece of this code memory.
For this reason, we define the $\xReadCond{}$ to capture the additional assumptions that we can make when a capability is executable.
\[
  \xReadCond{W} = \left\{ \npair{A} \middle| 
    \begin{array}{l}
      \exists r \in \addressable{\normal, \pwheap}, \code \ldotp \\
      \qquad \pwheap(r) \nequal \codereg{\_,\_,\code,\gc}\wedge\\
      \qquad \dom(\code) \supseteq A 
    \end{array}
  \right\}
\]
The $\xReadCond{}$ requires that the memory segment an executable capability has authority over is governed by a code region.
Note that we do not define $\execCond{}$ and $\xReadCond{}$ for the stack because the stack is not executable.
\paragraph{The untrusted value relation}
\label{par:untrusted-val-rel}
\[
  \lrv(W) =
  \begin{array}[t]{l}
    \left\{ \npair{\stpair[.]{i}{i}} \;\middle|\; i \in \ints \right\}\cup \\
%
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l}\src{\sealed{\sigma,\vsc_S}},\\ \sealed{\sigma,\vsc_T} \endarray\right)} \;\middle| \;
    \begin{array}{l}
      (\isLinear{\src{\vsc_S}} \text{ iff } \isLinear{\vsc_T}) \wedge\\
      \exists r \in \dom(\pwheap), \sigrets,\sigcloss,\mscode \ldotp \pwheap(r) = (\pure,\_,H_\sigma) \tand \\
      \quad H_\sigma \; \sigma \nequal H^\mathrm{code,\square}_\sigma \; \sigrets \; \sigcloss \; \mscode \; \gc \; \sigma \tand \\
      \quad \npair[n']{\stpair[.]{\vsc_S}{\vsc_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W) \text{ for all $n' < n$}\wedge\\
      \quad (\isLinear{\src{\vsc_S}} \Rightarrow \\
      \qquad\forall W' \future W, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      \qquad \quad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o)) \wedge \\
      \quad (\nonLinear{\src{\vsc_S}} \Rightarrow \\
      \qquad \forall W' \future \purePart{W}, W_o, n' < n, \npair[n']{\stpair[.]{\vsc_S'}{\vsc'_T}} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \\
      \qquad \quad \npair[n']{\src{\vsc_S},\src{\vsc_S'},\vsc_T,\vsc_T'} \in \lrexj(W'\oplus W_o))

      % This case was never used (?) so it is not necessary.
      % \wedge \\
      % \quad \npair[n']{\src{\vsc_S'},\src{\vsc_S},\vsc_T',\vsc_T} \in \lrexj(W' \oplus W_o)
    \end{array}
    \right\}\cup\\
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}},\\ \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \endarray \right)} 
    \; \middle| \;
    \begin{array}{l}
      [\sigma_\baddr,\sigma_\eaddr] \mathrel{\#} (\gsigrets \cup \gsigcloss) \tand\\
      \forall \sigma' \in [\sigma_\baddr,\sigma_\eaddr] \ldotp \exists r \in \dom(\pwheap) \ldotp \\
      \quad \pwheap(r) = (\pure,\_,H_\sigma) \tand H_\sigma \; \sigma' \nequal (\lrv \circ \xi)
    \end{array}
    \right\} \cup \\
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\stkptr{\perm,\baddr,\eaddr,\aaddr}},\\ ((\perm,\linear),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\;
    \begin{array}{l}
      \begin{array}{r l l}
        \perm \not\in \{\rx,\rwx\} \wedge\\
        % \perm = \noperm & \Rightarrow & \npair{(\linear,\baddr,\eaddr)} \in \lrp(W) \wedge \\
        \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \stackReadCond{W} \wedge \\
        \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \stackWriteCond{W}
      \end{array}
    \end{array}
    \right\} \cup \\
%
    \hspace{-2cm}\left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{((\perm,\lin),\baddr,\eaddr,\aaddr)},\\ ((\perm,\lin),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\; 
    \begin{array}{l}
      [b,e] \mathrel{\#} \ta \tand\\
      \begin{array}{r l l }
        % \perm = \noperm & \Rightarrow & \npair{(\lin,\baddr,\eaddr)} \in \lrp(W) \wedge \\
        \perm \in \readAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \readCond{\lin,W} \wedge\\
        \perm \in \writeAllowed{} &\Rightarrow& \npair{[\baddr,\eaddr]} \in \writeCond{\lin,W} \wedge\\
        % we are excluding rwx pointers.
        \perm \neq \rwx \wedge \\
        % \perm = \rwx &\Rightarrow& \array[t]{l}\npair{(\{\rwx,\rx\},\baddr,\eaddr)} \in \execCond{\lin,W} \wedge \\
        %                            \npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W} \endarray\\
        \perm = \rx &\Rightarrow& \array[t]{l}\npair{[\baddr,\eaddr]} \in \execCond{W} \wedge\\
        \npair{[\baddr,\eaddr]} \in \xReadCond{W} \wedge \\
                                  \lin = \normal \\ \endarray
      \end{array}
    \end{array}
    \right\}
  \end{array}
\]


\paragraph{The trusted value relation}
\label{par:trusted-val-rel}
\[
  \lrvtrusted[\square,\gc](W) =
  \begin{array}[t]{l}
    \lrv(W)\cup \\
%
    \left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{\seal{\sigma_\baddr,\sigma_\eaddr,\sigma}},\\ \seal{\sigma_\baddr,\sigma_\eaddr,\sigma} \endarray \right)} 
    \; \middle| \;
    \begin{array}{l}
      \gc = (\ta,\stkb,\gsigrets,\gsigcloss)  \wedge \\
      \exists r \in \dom(\pwheap) \ldotp \\
      \quad \pwheap(r) \nequal \codereg{\sigrets,\sigcloss,\code,(\ta,\stkb,\gsigrets,\gsigcloss)} \wedge\\
      \quad \dom(\code) \subseteq \ta \wedge [\sigma_\baddr,\sigma_\eaddr] \subseteq (\sigrets\cup\sigcloss) \wedge\\
      \quad \sigrets \subseteq \gsigrets \wedge \sigcloss \subseteq \gsigcloss
    \end{array}
    \right\} \cup \\
    \left\{ \npair{\left(\arraycolsep=0pt\array{l} \src{((\perm,\normal),\baddr,\eaddr,\aaddr)},\\ ((\perm,\normal),\baddr,\eaddr,\aaddr) \endarray \right)} \;\middle|\; 
    \begin{array}{l}
      \perm \sqsubseteq \rx \wedge \\
      \gc = (\ta,\stkb,\gsigrets,\gsigcloss)  \wedge \\
      {} [\baddr,\eaddr] \subseteq \ta \wedge\\
      \npair{[\baddr,\eaddr]} \in \xReadCond[\square,\gc]{W} 
    \end{array}
    \right\}
  \end{array}
\]

\subsubsection{Register file relation}
In Figure~\ref{fig:obs-rel}, we show sketches of the register file relation $\lrr$, the relation between $\tjmp{}$ targets $\lre(W)$ and the observation relation $\lro$.
The trusted/untrusted register file relation simply requires that all registers except $\pcreg$ are in the corresponding value relation (in a compatible world partition).
Two execution configurations are in the observation relation $\lro$ if one terminates whenever the other does\footnote{The actual definition in the \cite{technical_report} is complicated a bit by step-indexing and the fact that we actually use two separate observation relations for left- and right-approximation.}.
The $\lre(W)$ relation then includes any two words which can be plugged into related register files and memories (in compatible worlds), to obtain execution configurations in the observation relation.

\[
  \lrrg{\trust}(R)(W) = \left\{ \npair{\stpair{\reg}{\reg}} \middle|
    \begin{array}{l}
      \exists S : (\RegName \setminus (\{\pcreg \} \cup R))\fun \World \ldotp \\
      \quad W = \bigoplus_{r \in (\RegName\setminus (\{\pcreg,\rdata \} \cup R))} S(r) \wedge \\
      \quad \forall r \in \RegName \setminus (\{\pcreg \} \cup R)\ldotp\\
      \qquad\npair{\stpair[.]{\src{\reg_S(r)}}{\reg_T(r)}} \in \lrvg{\trust}(S(r))
    \end{array}
            \right\}
\]
We write $\lrr(W)$ to mean $\lrr(\emptyset)(W)$. That is, if we do not need to exclude extra registers, then we simply omit that argument.


\begin{lemma}[Untrusted is trusted]
  \label{lem:untrusted-supset-trust}
  \begin{itemize}
  \item $\lrvtrusted(W) \supseteq \lrv(W)$
  \item $\lrrtrusted(W) \supseteq \lrr(W)$
  \end{itemize}
\end{lemma}




\subsubsection{Expression relations}
% Two expression relations: one for sealed code-data pairs being jumped to and one for capabilities being jumped to in the regular way.
% The argument for having one relation relate pairs of pairs of capabilities and the other relate pairs of capabilities is that that is how xjump and regular jumps work: xjump takes pairs while regular jumps take single capabilities.
\begin{align*}
  \lrexj(W) &= \left\{ \npair{\stpair[.]{v_{c,S},v_{d,S}}{v_{c,T},v_{d,T}}} \middle| 
    \begin{array}{l}
      \forall n' \leq n, \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk} \ldotp\\
      \quad \forall W_\lrrs , W_\lrm \ldotp \\
      \qquad\npair[n']{\stpair{\reg}{\reg}} \in \lrr(\{\rdata\}) (W_\lrrs ) \wedge\\
      \qquad\memSat[n']{\stpair[.]{\ms_S,\stk,\ms_\stk}{\ms_T}}{W_\lrm} \wedge \\
      \qquad\Phi_S = \src{(\ms_S,\reg_S,\stk, \ms_\stk)}\wedge\\
      \qquad\Phi_T = (\ms_T,\reg_T) \wedge\\
      \qquad W \oplus W_\lrrs \oplus W_\lrm \text{ is defined }\\
      \qquad\Rightarrow \exists \Phi_S',\Phi_T'\ldotp\\
      \quad\qquad \Phi_S' = \xjumpResult{v_{c,S}}{v_{d,S}}{\Phi_S} \tand\\
      \quad\qquad\Phi_T' = \xjumpResult{v_{c,T}}{v_{d,T}}{\Phi_T}\tand\\
      \quad\qquad\npair[n']{\left(\Phi_S', \Phi_T' \right)}\in \lro
    \end{array}
    \right\}\\
  \lre(W) &= \left\{ \npair{\stpair[.]{v_{c,S}}{v_{c,T}}} \middle| 
    \begin{array}{l}
      \forall n' \leq n, \src{\reg_S}, \reg_T, \src{\ms_S}, \ms_T, \src{\ms_\stk}, \src{\stk} \ldotp\\
      \quad \forall W_\lrrs , W_\lrm \ldotp \\
      \qquad\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_\lrrs ) \wedge\\
      \qquad\memSat[n']{\stpair[.]{\ms_S,\stk,\ms_\stk}{\ms_T}}{W_\lrm} \\
      \qquad\Phi_S = \src{(\ms_S,\reg_S,\stk, \ms_\stk)}\\
      \qquad \Phi_S' = \Phi_S \updReg{\pcreg}{v_{c,S}}\\
      \qquad\Phi_T = (\ms_T,\reg_T)\\
      \qquad\Phi_T' = \Phi_T\updReg{\pcreg}{v_{c,T}}\\
      \qquad W \oplus W_\lrrs \oplus W_\lrm\\
      \qquad\Rightarrow\npair[n']{\left(\Phi_S', \Phi_T' \right)}\in \lro
    \end{array}
    \right\}
\end{align*}
\end{jversion}
\subsection{Fundamental Theorem}
An important lemma in our proof of full abstraction of the embedding of \srccm{} into \trgcm{}, is the fundamental theorem of logical relations (FTLR).
The name indicates that it is an instance of a general pattern in logical relations proofs, but is otherwise unimportant.
\begin{lemma}[FTLR (roughly)]
  \label{thm:ftlr}
  If $[\baddr,\eaddr] \subseteq \dom(\mscode)$ and $\pwheap(r) = \codereg{\sigrets,\sigcloss,\mscode}$, and either $[\baddr,\eaddr] \subseteq \ta$ and $\mscode$ behaves reasonably (see Section~\ref{sec:well-form-reas}) or
$[\baddr,\eaddr] \mathrel{\#} \ta$,
then 
  \[
    \npair{\left(\src{((\rx,\normal),\baddr,\eaddr,\aaddr)}, ((\rx,\normal),\baddr,\eaddr,\aaddr)\right)} \in \lre(W) \qedhere
  \]
\end{lemma}

Roughly speaking, this lemma says that under certain conditions, executing any executable capability under \srccm{} and \trgcm{} semantics will produce the same observable behavior.
The conditions require that the capability points to a memory region where code is loaded and that code must be either trusted and behave reasonably (i.e.\ respect the restrictions that \stktokens{} relies on, see Section~\ref{sec:well-form-reas}) or untrusted (in which case, it cannot have WBCF or LSE expectations, see Section~\ref{sec:well-form-reas}).

The proof of the lemma consists of a big induction where each possible instruction is proven to behave the same in source and target in related memories and register files.
After that first step, the induction hypothesis is used for the rest of the execution.

\subsection{Full Abstraction Proof Sketch}
\label{subsec:proof-sketch}
Using Lemma~\ref{thm:ftlr}, we can now proceed to proving Theorem~\ref{thm:full-abstraction} (full abstraction).
First, we extend the logical relation into an omitted relation on components $(\var{comp}_S,\var{comp}_T) \in \lrcomp(W)$.
% Essentially, it relates a component to itself if instantiating their imports with related values produces related exports and code memory satisfying the appropriate code region in the world.
% The component relation $\mathcal{C}(W)$ basically lifts the logical relation we have presented above to components.
% The component relation relates a component $(\mscode,\msdata,\overline{\mathrm{import}},\overline{\mathrm{export}},\sigrets,\sigcloss)$ to itself when two conditions are satisfied.
% First, when words that relate to them selves in the untrusted value relation are used to satisfy the imports, i.e.\ the words are placed on the import addresses in $\msdata$, and this data memory is combined with the code memory $\mscode$, then it forms a safe heap, i.e.\ it is in the $\mathcal{H}$ relation.
% Second, the exports should always be safe to use which means that they must be in the untrusted value relation in any future world.
% \begin{multline*}
%   \lrcomp(W) =\\
%   \left\{\begin{aligned}
%       &\npair{\var{comp},\var{comp}} \;\mid \;\\
%       &\qquad\var{comp} = (\mscode,\msdata,\overline{a_{\mathrm{import}} \mapsfrom s_{\mathrm{import}}},\overline{s_{\mathrm{export}} \mapsto w_{\mathrm{export}}},\sigrets,\sigcloss) \tand \\
%       &\qquad\text{For all } W' \future W \ldotp \\
%       &\qquad\quad\text{If } \overline{\npair[n']{(w_{\mathrm{import}},w_{\mathrm{import}})}} \in \lrv(\purePart{W'}) \text{ for all $n' < n$}\\
%       &\qquad\quad\text{and } \msdata' = \msdata{}[\overline{a_{\mathrm{import}} \mapsto w_{\mathrm{import}}}] \\
%       &\qquad\quad\text{then } \npair{(\sigrets\uplus\sigcloss,\mscode\uplus \msdata', \mscode\uplus\msdata')} \in \lrheap(\pwheap)(W') \tand\\
%       &\qquad\quad\overline{\npair{(w_{\mathrm{export}},w_{\mathrm{export}})}} \in \lrv(\purePart{W'})
%     \end{aligned}
%   \right\}\\
% \cup \left\{
%     \begin{multlined}
%       \npair{(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d}),(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})} \;\mid \;\\
%       \npair{(\var{comp}_0,\var{comp}_0)} \in \lrcomp(W) \tand
%       \{(\_ \mapsto c_{\mathrm{main},c}),(\_ \mapsto c_{\mathrm{main},d})\} \subseteq \overline{w_{\mathrm{export}}}
%     \end{multlined}
%   \right\} 
% \end{multline*}
%
Using Lemma~\ref{thm:ftlr} and the definitions of the logical relations, we can then prove the following two lemmas.
The first is a version of the FTLR for components, stating that all components are related to themselves if they are either (1) well-formed and untrusted or (2) well-formed, reasonable and trusted.
\begin{lemma}[FTLR for components]
  \label{lem:ftlr-comps}
  If $\comp$ is a well-formed component, i.e. $\wdjud{\comp}$ and either
    $\dom(\comp.\mscode) \subseteq \ta$ and $\src{\comp}$ is a reasonable component; or
    $\dom(\comp.\mscode) \mathrel{\#} \ta$,
  then there exists a $W$ such that
  $\npair{(\src{\comp},\comp)} \in \lrcomp(W)$.
\end{lemma}

Another lemma then relates the component relation and context plugging: plugging related components into related contexts produces related execution configurations.
\begin{lemma}
  \label{lem:adeq-context-plug}
  If $\npair{\stpair{\context}{\context}}\in\lrcomp(W_1)$ and $\npair{\stpair{\comp}{\comp}} \in \lrcomp(W_2)$ and $W_1\oplus W_2$ is defined, then
  $\plug{\src{\context_S}}{\src{\comp_S}}$ terminates iff $\plug{\context_T}{\comp_T}$ terminates.
\end{lemma}
% Finally, we have an adequacy lemma for the execution configuration relation.
% This lemma says that for related \srccm{} and \trgcm{} configurations, one terminates iff the other does.
% \begin{multline*}
%   \lrec[\square,\gc = (\ta,\stkb)](W) = \\
% \left\{
%   \begin{array}{l}
%      \npair{\left(
%     (\ms_S,\reg_S,\stk,\ms_\stk),
%     (\ms_T,\reg_T)\right)} \mid \\
%     \quad \exists W_M,W_R,W_\pcreg \ldotp W = W_M \oplus W_R \oplus W_\pcreg \tand\\
%     \qquad \npair{( (\reg_S(\pcreg),\reg_S(\rdata)), (\reg_T(\pcreg),\reg_T(\rdata)) )} \in \lrexj(W_\pcreg) \tand \\
%     \qquad \reg_S(\pcreg) \neq \retptrc(\_) \tand
%     \reg_S(\rdata) \neq \retptrd(\_) \tand \\
%     \qquad \nonExec{\reg_S(\rdata)} \tand  
%      \nonExec{\reg_T(\rdata)} \tand \\
%     \qquad \memSat{\ms_S,\ms_\stk,\stk,\ms_T}{W_M} \tand \npair{\stpair{\reg}{\reg}} \in \lrr(\{\rdata\})(W_R)
%   \end{array}
% \right\}
% \end{multline*}
% \begin{lemma}[Adequacy of execution configuration logical relation]
%   \label{lem:adequacy}
%   If $\npair{\stpair{\Phi}{\Phi}}\in\lrec(W)$ then $\src{\Phi_S} \sterm{}$ iff $\Phi_T\term$.
% \end{lemma}

Finally, we use these two lemmas to prove Theorem~\ref{thm:full-abstraction}.
\begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
  The proofs of both directions are similar, so we only show the right direction.
  To show the \trgcm{} contextual equivalence, assume w.l.o.g\ a well-formed context $\trg{\context}$ such that ${\plug{\trg{\context}}{\src{\comp_1}} \term[]{}}$.
  The proof is sketched in Figure~\ref{fig:fa-proof-sketch}.
  By the statement of Theorem~\ref{thm:full-abstraction}, we may assume that the trusted components $\src{\comp_1}$ and $\src{\comp_2}$ are well-formed and reasonable.
  We prove arrow (1) in the figure by using the mentioned assumptions about $\src{\comp_1}$ and $\trg{\context}$ along with Lemma~\ref{lem:ftlr-comps} and \ref{lem:adeq-context-plug}.
  Now we know that ${\plug{\trg{\context}}{\src{\comp_1}} \sterm[]{}{}}$, so by the assumption that $\src{\comp_1}$ and $\src{\comp_2}$ are contextually equivalent on \srccm{} we get ${\plug{\trg{\context}}{\src{\comp_2}} \sterm[]{}{}}$, i.e.\ arrow (2) in the figure.
  To prove arrow (3), we again apply Lemma~\ref{lem:ftlr-comps}, \ref{lem:adeq-context-plug}; but this time, we use the assumption that $\src{\comp_2}$ is well-formed and reasonable and that $\trg{\context}$ is well-formed.
\end{proof}

\renewcommand{\comp}{C}
\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=.9}]
    % \draw[help lines,yellow] (0,0) grid (10,7);
    \node at (5,4.7) { ${\src{\comp_1}\mathrel{\sconeq} \src{\comp_2}}$ };

    \node at (3.4,4) { ${\plug{\trg{\context}}{\src{\comp_1}} \sterm[]{\gc}{}}$ };
    \node at (5,4) { $\mathrel{\Rightarrow}$ };
    \node at (6.6,4) { ${\plug{\trg{\context}}{\src{\comp_2}} \sterm[]{\gc}{}}$ };

    \node at (4.35,2.8) { (1) };
    \node at (5,3.6) { (2) };
    \node at (5.65,2.8) { (3) };

    \draw[out=100,in=260,double,-implies,double equal sign distance] (4,2.6) to (4,3.4);

    \draw[out=280,in=80,double,-implies,double equal sign distance] (6,3.4) to (6,2.6);

    \node[align=center] at (8.2,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_2}} \cong {\src{\comp_2}}$};
    \node[align=center] at (1.8,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{\comp_1}} \cong {\src{\comp_1}}$};
    % \node at (9,2.7) { $e  {\src{C_1}} \cong \src{C_1}} : tau$ };
    % \node at (8.7,3.3) { $ {\trg{\context}} \cong \trg{\context} :{\emptyset},tau \ra e,{\cdots}$ };
    % \node at (.8,3) { $e  {\src{C_1}} \cong {\src{C_1}} : tau$ };

    \node at (3.4,2) { ${\plug{\trg{\context}}{\src{\comp_1}} \term[]{}}$ };
    \node at (5,2.1) { $\overset{?}{\Rightarrow}$ };
    \node at (6.6,2) { ${\plug{\trg{\context}}{\src{\comp_2}} \term[]{}}$ };

    \node at (5,1.3) { ${\src{\comp_1}}\mathrel{\overset{?}{\tconeq}}{\src{\comp_2}}$ };

    \draw[out=-90,in=90,double,-implies,double equal sign distance] (0,5) to node[sloped, yshift =.7em]{\Small Contextual equivalence preservation} (0,1);
  \end{tikzpicture}
  \caption{Proving one direction of fully abstract compilation (contextual equivalence preservation).}
  \label{fig:fa-proof-sketch}
\end{figure}


% \subsection{Proof sketch}
% \label{subsec:proof-sketch}
% \begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
  % \item Consider first the upward arrow.
  %   Assume $\src{\var{comp}_1} \tconeq \src{\var{comp}_2}$.

  %   Take a $\src{\context}$ such that $\vdash \src{\context}$, take $\src{\ta[,i]}
  %   = \src{\dom(\var{comp}_i.\mscode)}$, $\gsigrets_i = \var{comp}_i.\sigrets$ and
  %   $\gsigcloss_i = \var{comp}_i.\sigcloss$, $\gc_i = (\ta[,i],\stkb_i,\gsigrets_i,\gsigcloss_i)$ and we will prove that
  %   $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}} \Leftrightarrow
  %   \src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.

  %   By symmetry, we can assume w.l.o.g. that $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}}$ and prove that $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.
  %   Note that this implies that $\src{\context}$ is a valid context for both $\src{\var{comp}_1}$ and $\src{\var{comp}_2}$.

  %   First, we show that also $\plug{\context}{\var{comp}_1} \trg{\term}$.
  %   Take $n$ the amount of steps in the termination of $\src{\plug{\context}{\var{comp}_1} \sterm{\gc_1}}$.
  %   It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\var{comp}_1,\var{comp}_1)} \in \lrcomp[\preceq,\gc_1](W_1)$ for some $W_1$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
  %   It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\context,\context)} \in \lrcomp[\preceq,\gc_1](W_1')$ for some $W_1'$ that we can choose such that $W_1 \uplus W_1'$ is defined.
  %   Lemma~\ref{lem:compat-context-plug} then tells us that $\npair{(\plug{\context}{\var{comp}_1}, \plug{\context}{\var{comp}_1})} \in \lrec[\preceq,\gc_1](W_1\uplus W_1')$
  %   Together with $\src{\plug{\context}{\var{comp}_1} \sterm[n]{\gc_1}}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_1} \trg{\term}$.

  %   It follows from $\src{\var{comp}_1} \tconeq \src{\var{comp}_2}$ that also $\plug{\context}{\var{comp}_2} \trg{\term}$.

  %   It now remains to show that also $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$.
  %   Take $n'$ the amount of steps in the termination of $\plug{\context}{\var{comp}_2} \trg{\term}$.
  %   It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\var{comp}_2,\var{comp}_2)} \in \lrcomp[\succeq,\gc_2](W_2)$ for some $W_2$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
  %   It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\context,\context)} \in \lrcomp[\succeq,\gc_2](W_2')$ for some $W_2'$ that we can choose such that $W_2 \uplus W_2'$ is defined.
  %   Lemma~\ref{lem:compat-context-plug} then tells us that $\npair[n']{(\plug{\context}{\var{comp}_2}, \plug{\context}{\var{comp}_2})} \in \lrec[\succeq,\gc_2](W_2\uplus W_2')$
  %   Together with $\plug{\context}{\var{comp}_2} \trg{\term[n']}$, Lemma~\ref{lem:adequacy} then tells us that $\src{\plug{\context}{\var{comp}_2} \sterm{\gc_2}}$, concluding this direction of the proof.

%   First consider the right arrow:

%     Assume $\src{\var{comp}_1} \sconeq \src{\var{comp}_2}$. Take $\src{\ta[,i]} = \src{\dom(\var{comp}_i.\mscode)}$, $\gsigrets_i = \var{comp}_i.\sigrets$ and $\gsigcloss_i = \var{comp}_i.\sigcloss$, $\gc_i = (\ta[,i],\stkb_i,\gsigrets_i,\gsigcloss_i)$.
% %
%     Take a $\trg{\context}$ such that $\vdash \trg{\context}$ and we will prove that
%     $\trg{\plug{\context}{\var{comp}_1} \term} \Leftrightarrow
%     \trg{\plug{\context}{\var{comp}_2} \term}$.
% %
%     By symmetry, we can assume w.l.o.g. that $\trg{\plug{\context}{\var{comp}_1} \term}$ and prove that $\trg{\plug{\context}{\var{comp}_2} \term}$.
%     Note that this implies that $\trg{\context}$ is a valid context for both $\trg{\var{comp}_1}$ and $\trg{\var{comp}_2}$.
% %
%     First, we show that also $\plug{\context}{\var{comp}_1} \src{\sterm{\gc_1}}$.
%     Take $n$ the amount of steps in the termination of $\plug{\context}{\var{comp}_1} \trg{\term}$.
%     It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\var{comp}_1,\var{comp}_1)} \in \lrcomp[\succeq,\gc_1](W_1)$ for some $W_1$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
%     It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n+1]{(\context,\context)} \in \lrcomp[\succeq,\gc_1](W_1')$ for some $W_1'$ that we can choose such that $W_1 \uplus W_1'$ is defined.
%     Lemma~\ref{lem:compat-context-plug} then tells us that $\npair{(\plug{\context}{\var{comp}_1}, \plug{\context}{\var{comp}_1})} \in \lrec[\succeq,\gc_1](W_1\uplus W_1')$
%     Together with $\plug{\context}{\var{comp}_1} \trg{\term[n]}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_1} \src{\sterm{\gc_1}}$.
% %
%     It follows from $\src{\var{comp}_1} \sconeq \src{\var{comp}_2}$ that also $\plug{\context}{\var{comp}_2} \src{\sterm{\gc_2}}$.
% %
%     It now remains to show that also $\plug{\context}{\var{comp}_2} \trg{\term}$.
%     Take $n'$ the amount of steps in the termination of $\plug{\context}{\var{comp}_2} \src{\sterm{\gc_2}}$.
%     It follows from Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\var{comp}_2,\var{comp}_2)} \in \lrcomp[\preceq,\gc_2](W_2)$ for some $W_2$ with $\dom(\pwfree) = \dom(\pwpriv) = \emptyset$.
%     It also follows from the same Lemma~\ref{lem:ftlr-comps} that $\npair[n'+1]{(\context,\context)} \in \lrcomp[\preceq,\gc_2](W_2')$ for some $W_2'$ that we can choose such that $W_2 \uplus W_2'$ is defined.
%     Lemma~\ref{lem:compat-context-plug} then tells us that $\npair[n']{(\plug{\context}{\var{comp}_2}, \plug{\context}{\var{comp}_2})} \in \lrec[\preceq,\gc_2](W_2\uplus W_2')$
%     Together with $\plug{\context}{\var{comp}_2} \trg{\term[n']}$, Lemma~\ref{lem:adequacy} then tells us that $\plug{\context}{\var{comp}_2} \trg{\term}$, concluding the second direction of the proof.

%  The left arrow is proven in a similar manner.
% \end{proof}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End: