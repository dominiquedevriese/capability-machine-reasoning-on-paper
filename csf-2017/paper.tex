\documentclass[compsoc,conference,letterpaper,fleqn]{IEEEtran}
\usepackage{hyperref}

\usepackage{cite}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{comment}
\usepackage{amsmath}


\begin{document}

\title{Reasoning about a Capability Machine with Local Capabilities\\
 Provably Safe Stack and Return Pointer Management (without OS Support).}


\author{%
\IEEEauthorblockN{Lau Skorstengaard}
\IEEEauthorblockA{Aarhus University, Denmark\\
Email: lau@cs.au.dk} \and
\IEEEauthorblockN{Dominique~Devriese}
  \IEEEauthorblockA{iMinds-DistriNet, KU Leuven, Belgium\\
Email: dominique.devriese@cs.kuleuven.be} \and
\IEEEauthorblockN{Lars~Birkedal}\IEEEauthorblockA{Aarhus University, Denmark\\
Email: birkedal@cs.au.dk}}

\maketitle

\begin{abstract}
  abc
\end{abstract}

\section*{Terminology ?}

\emph{capability safe}: 
Our unary logical relation is a semantic \emph{definition}
of which values for the
pc / register-file / word are capability safe. 



\section{Introduction}
\label{sec:introduction}

\subsection{Introduce capability machines}
\subsection{Enforcing properties on a capability machine}

Privacy of local state using memory capabilities.
Encapsulation of private state using enter pointers or CHERI's ccall.
(mention in passing secure compilation, full abstraction)

\subsection{Well-bracketed control flow and encapsulation of stack frames}

Hard to enforce using standard capabilities:
\begin{itemize}
\item Well-bracketed control flow can be broken if the adversary stores return pointers.
(alternative: trusted stack)
\item Encapsulation of local stack frames can be broken if the adversary stores stack pointers.
\end{itemize}

\subsection{Local capabilities}

\begin{itemize}
\item Introduced by CHERI for this purpose.
\item Explain how they can be used for passing return pointers and stack pointers.
\item But this is not watertight.
\item Example attack:
\begin{itemize}
\item In a first invocation, adversary fills the entire unused part of the stack with copies of the current stack pointer
\item In a second invocation, adversary can load the old stack pointer of the stack
\item He now has access to private state that was pushed on the stack in between.
\end{itemize}
\item So:
\begin{itemize}
\item Can we make it (provably) watertight?
\item Is the trusted stack necessary? Why not just pass return pointers locally?
\item General question: How to reason about capability machines and
local capabilities?
\end{itemize}
\end{itemize}

\subsection{Contributions}

\begin{itemize}
\item Formal model of a simple but representative capability machine with local capabilities
\item Detailed study of how to do safe stack and return pointer management in this setting, taking into account:
\begin{itemize}
\item untrusted adversary
\item higher-order code: callbacks passed to and received from the adversary
\item efficient stack management
\item no OS support
\end{itemize}
\item Logical relation for reasoning about code in this capability machine
\item Fundamental theorem that expresses the guarantees offered by a capability machine for untrusted code
\item Technical contributions: reuse existing ideas in a new way:
\begin{itemize}
\item replace biorthogonal closure by a single orthogonal closure
because assembly languages remove the distinction between the
continuation and the arguments
\end{itemize}
\end{itemize}
LB: I think we should have some discussion of the flexibility /
  strength of our LR.  The LR defines which computations we think of
  as well-behaved.   
 We should give simple / trivial examples of
  code not in the LR. But we may also want to emphasize that the LR is 
  not too restricting, e.g., it does not enforce a certain calling
  scheme (examplied by Example \verb!f1! which
  does not use the stack and the following examples which do use the
  stack). This ties in to the discussion of biorthogonality, see the
  following paragraphs. 

LB: we need to relate this carefully to Hur-Dreyer, who used
      biorthogonality even though they also worked with an assembly
      language. (If I recall correctly, they assumed some properties
      of the low level language, which is why the biortho was the
      right ting, but we need to check.)

LS: It is my impression that they were interested in the relation
between high-level and low-level programs. They are therefore in
particular interested in low-level programs compiled from high-level
programs which means that the continuation is always invoked in the 
same way. Our realisation was that anything we pass as an argument 
in a "call" can be used as a continuation, so the continuation 
relation was redundant. Even though we do try to give our programs
some structure using the macros, our logical relation is strong enough
to handle unstructured programs as well.
\begin{itemize}
\item STSs with public/private transitions for dealing with local capabilities: play the same role as before, but in different places of the LR.
\end{itemize}
\begin{itemize}
\item Demonstrate all of this on several examples:
\begin{itemize}
\item security examples
\item the most challenging examples from existing literature on reasoning about well-bracketed control flow in lambda calculi
\item some compartmentalisation result?
\item whatever else we do..
\end{itemize}
\end{itemize}

\subsection{Outline}

\section{A capability machine with local capabilities}

Formalisation

Explain our model of linking

\section{Stack and return pointer management using local capabilities}

\begin{itemize}
\item Issues to consider:
\begin{itemize}
\item no global store-local capabilities
\item clearing the stack
\item clearing (some) registers
\item constructing return pointers
\item constructing callbacks
\item invoking the adversary's callbacks
\end{itemize}
\item Reusable macro-instructions for stack and return pointer management
\begin{itemize}
\item taking care of the stuff above
\end{itemize}
\end{itemize}

LB: maybe we can present the examples informally before the logical relation and then return to them after the logical relation (to present the formal properties) ?

\section{Logical relation}

\begin{itemize}
\item Intuition
\item Worlds
\item Logical relation
\item Fundamental theorem
\item Discussion/comparison with related Dreyer-Neis-Birkedal and with Hur-Dreyer
\end{itemize}

\section{Examples}
\begin{itemize}
\item Ticket dispenser
\item The awkward example and variants
\item A sandboxing example?

For example, an untrusted advertisement scenario with initialization code
that registers a redraw callback. The redraw callback gets temporary
read-write access to a framebuffer.

\item Some compartmentalisation result?
\end{itemize}

\section{Discussion, future work}
\begin{itemize}
\item A general well-bracketed control flow result?
\begin{itemize}
\item what would that result say?
\item possible idea: fully abstract compilation from an assembly language with
a trusted stack to one without
\item the LR and some of the lemmas already imply well-bracketed control flow, as seen in examples
\end{itemize}
\item Relation to local parameters in Scala, Algol/Pascal second-class function parameters?
\item Stack clearing realistic?
\item Non-modularity of heap allocation requirement for adversary callbacks
\end{itemize}

\section{Related work}

\begin{itemize}
\item Dreyer-Neis-Birkedal
\item CHERI papers
\item Akram's thesis
\item \url{http://2016.splashcon.org/event/splash-2016-oopsla-gentrification-gone-too-far-affordable-2nd-class-values-for-fun-and-co-effect}
\item other papers that enforce well-bracketed control flow at low level
(using a trusted stack manager)
\begin{itemize}
\item \url{http://ieeexplore.ieee.org/abstract/document/7536364/}
\item \url{http://ieeexplore.ieee.org/abstract/document/7536366/}
\item other stuff?
\end{itemize}
\end{itemize}

\section{Conclusion}


\section*{Acknowledgements}
\label{sec:acknowledgements}

This research was supported in part by the ModuRes Sapere Aude Advanced Grant from The Danish Council for Independent Research for the Natural Sciences (FNU).
Dominique Devriese holds a postdoctoral fellowship from the Research Foundation - Flanders (FWO).

\end{document}
