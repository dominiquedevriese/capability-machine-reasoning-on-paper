\documentclass[compsoc,conference,letterpaper,fleqn]{IEEEtran}
\usepackage{hyperref}

\usepackage{cite}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{comment}
\usepackage{amsmath}

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\begin{document}

\title{Reasoning about a Capability Machine with Local Capabilities\\
 Provably Safe Stack and Return Pointer Management (without OS Support).}


\author{%
\IEEEauthorblockN{Lau~Skorstengaard}
\IEEEauthorblockA{Aarhus University, Denmark\\
Email: lau@cs.au.dk} \and
\IEEEauthorblockN{Dominique~Devriese}
  \IEEEauthorblockA{iMinds-DistriNet, KU Leuven, Belgium\\
Email: dominique.devriese@cs.kuleuven.be} \and
\IEEEauthorblockN{Lars~Birkedal}\IEEEauthorblockA{Aarhus University, Denmark\\
Email: birkedal@cs.au.dk}}

\maketitle

\begin{abstract}
  abc
\end{abstract}

\section{Introduction}
\label{sec:introduction}
%%% a)
% Current low-level protection coarse grained memory protection or
% properties of high-level languages are not really enforced?

% Capability machines offer fine-grained memory protection
A capability machine is a low-level machine that offers fine-grained
memory protection.
% Capability machines and unforgeable tokens for memory access. 
This is done by introducing unforgeable tokens to
the machine. These tokens are called capabillities and grant a kind of
authority and a range of authority. We will refer to the capabilities
that grant a combination of read, write, or execute permission as memory
capabilities. Capabilities with the necessary permissions must be
presented every time an instruction that manipulates the memory is
executed.

Memory capabilities provide memory protection, but they do not provide
a way to set up security domains. When you jump to an untrusted piece
of code that is supposed to jump back to you, then you have to either
revoke all your capabilities or pass to the piece of code you do not
trust. This short coming can be overcome by adding something like the
enter capability from the M-Machine\todo{add reference}. The enter
capability is an opaque capability which can only be used for a
jump. When jumped to it grants read and execute permission which
allows the code that is now executing to read capabilities stored in
memory. 
The CHERI processor's ccall achieves a similar property\todo{Add reference}.

Capabilities are irrevocable, so when we pass a capability has to
an untrusted program, then we have to assume that the program keeps it
around indefenitely. This means that we cannot reuse the piece of
memory that the capability governs essentially creating a memory
leak. The CHERI processor has a special kind of capabilities called
\emph{local capabilities}\todo{reference?} that introduces a simple
kind of temporal information control which allows for a simple kind of
capability revocation. This is achieved by adding a tag to every
capability that marks it as either local or global. Local capabilities
can only be written through a capability with a new permission called
\emph{permit write local}.
% More about local capabilities.

With just memory capabilities, enter capabailities and local
capabilities, the capability machine becomes very expressive and can
enforce properties that high-level languages promisse. The memory
capabilities enforce the privacy of local state as it is impossible
for anyone to access your local state without the capability to do
so. When this is combined with the enter capability,  

%%% b)




% Examples of capability machines?


% Enter capabilities

% Local capabilities

% High-level languages often provide guarantees such as encapsulation of private state and well-bracketedness of calls - often not clear how well this is enforced. Just enforced when interacting with other programs written in the same high-level language or is it also guaranteed when interacting with assembly programs.

% High-level programs compiled to assembly can ensure these properties.

% 

\subsection{Introduce capability machines}
\subsection{Enforcing properties on a capability machine}

Privacy of local state using memory capabilities.
Encapsulation of private state using enter pointers or CHERI's ccall.
(mention in passing secure compilation, full abstraction)

\subsection{Well-bracketed control flow and encapsulation of stack frames}

Hard to enforce using standard capabilities:
\begin{itemize}
\item Well-bracketed control flow can be broken if the adversary stores return pointers.
(alternative: trusted stack)
\item Encapsulation of local stack frames can be broken if the adversary stores stack pointers.
\end{itemize}

\subsection{Local capabilities}

\begin{itemize}
\item Introduced by CHERI for this purpose.
\item Explain how they can be used for passing return pointers and stack pointers.
\item But this is not watertight.
\item Example attack:
\begin{itemize}
\item In a first invocation, adversary fills the entire unused part of the stack with copies of the current stack pointer
\item In a second invocation, adversary can load the old stack pointer of the stack
\item He now has access to private state that was pushed on the stack in between.
\end{itemize}
\item So:
\begin{itemize}
\item Can we make it (provably) watertight?
\item Is the trusted stack necessary? Why not just pass return pointers locally?
\item General question: How to reason about capability machines and
local capabilities?
\end{itemize}
\end{itemize}

\subsection{Contributions}

\begin{itemize}
\item Formal model of a simple but representative capability machine with local capabilities
\item Detailed study of how to do safe stack and return pointer management in this setting, taking into account:
\begin{itemize}
\item untrusted adversary
\item higher-order code: callbacks passed to and received from the adversary
\item efficient stack management
\item no OS support
\end{itemize}
\item Logical relation for reasoning about code in this capability machine
\item Fundamental theorem that expresses the guarantees offered by a capability machine for untrusted code
\item Technical contributions: reuse existing ideas in a new way:
\begin{itemize}
\item replace biorthogonal closure by a single orthogonal closure
because assembly languages remove the distinction between the
continuation and the arguments
\end{itemize}
\end{itemize}
LB: we need to relate this carefully to Hur-Dreyer, who used
      biorthogonality even though they also worked with an assembly
      language. (If I recall correctly, they assumed some properties
      of the low level language, which is why the biortho was the
      right ting, but we need to check.)
LS: It is my impression that they were interested in the relation
between high-level and low-level programs. They are therefore in
particular interested in low-level programs compiled from high-level
programs which means that the continuation is always invoked in the 
same way. Our realisation was that anything we pass as an argument 
in a "call" can be used as a continuation, so the continuation 
relation was redundant. Eventhough we do try to give our programs
some structure using the macros, our logical relation is strong enough
to handle unstructured programs as well.
\begin{itemize}
\item STSs with public/private transitions for dealing with local capabilities: play the same role as before, but in different places of the LR.
\end{itemize}
\begin{itemize}
\item Demonstrate all of this on several examples:
\begin{itemize}
\item security examples
\item the most challenging examples from existing literature on reasoning about well-bracketed control flow in lambda calculi
\item some compartmentalisation result?
\item whatever else we do..
\end{itemize}
\end{itemize}

\subsection{Outline}

\section{A capability machine with local capabilities}

Formalisation

Explain our model of linking

\section{Stack and return pointer management using local capabilities}

\begin{itemize}
\item Issues to consider:
\begin{itemize}
\item no global store-local capabilities
\item clearing the stack
\item clearing (some) registers
\item constructing return pointers
\item constructing callbacks
\item invoking the adversary's callbacks
\end{itemize}
\item Reusable macro-instructions for stack and return pointer management
\begin{itemize}
\item taking care of the stuff above
\end{itemize}
\end{itemize}

LB: maybe we can present the examples informally before the logical relation and then return to them after the logical relation (to present the formal properties) ?

\section{Logical relation}

\begin{itemize}
\item Intuition
\item Worlds
\item Logical relation
\item Fundamental theorem
\item Discussion/comparison with related Dreyer-Neis-Birkedal and with Hur-Dreyer
\end{itemize}

\section{Examples}
\begin{itemize}
\item Ticket dispenser
\item The awkward example and variants
\item A sandboxing example?

For example, an untrusted advertisement scenario with initialization code
that registers a redraw callback. The redraw callback gets temporary
read-write access to a framebuffer.

\item Some compartmentalisation result?
\end{itemize}

\section{Discussion, future work}
\begin{itemize}
\item A general well-bracketed control flow result?
\begin{itemize}
\item what would that result say?
\item possible idea: fully abstract compilation from an assembly language with
a trusted stack to one without
\item the LR and some of the lemmas already imply well-bracketed control flow, as seen in examples
\end{itemize}
\item Relation to local parameters in Scala, Algol/Pascal second-class function parameters?
\item Stack clearing realistic?
\item Non-modularity of heap allocation requirement for adversary callbacks
\end{itemize}

\section{Related work}

\begin{itemize}
\item Dreyer-Neis-Birkedal
\item CHERI papers
\item Akram's thesis
\item \url{http://2016.splashcon.org/event/splash-2016-oopsla-gentrification-gone-too-far-affordable-2nd-class-values-for-fun-and-co-effect}
\item other papers that enforce well-bracketed control flow at low level
(using a trusted stack manager)
\begin{itemize}
\item \url{http://ieeexplore.ieee.org/abstract/document/7536364/}
\item \url{http://ieeexplore.ieee.org/abstract/document/7536366/}
\item other stuff?
\end{itemize}
\end{itemize}

\section{Conclusion}

\section*{Acknowledgements}
\label{sec:acknowledgements}

This research was supported in part by the ModuRes Sapere Aude Advanced Grant from The Danish Council for Independent Research for the Natural Sciences (FNU).
Dominique Devriese holds a postdoctoral fellowship from the Research Foundation - Flanders (FWO).

\end{document}
\grid
