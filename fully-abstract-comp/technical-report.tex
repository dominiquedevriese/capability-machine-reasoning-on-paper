\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}

% Math packages
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{array}
\usepackage{cleveref}
\usepackage{stmaryrd}

% Command control packages
\usepackage{ifthen}
\usepackage{ifpdf}

% Listings
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  mathescape
}

% Rotate entire figures
\usepackage{rotating}

% Tikz
\usepackage{tikz}

%%% Comments
% Comments
\newcommand\lau[1]{{\color{purple} \sf \footnotesize {LS: #1}}\\}
\newcommand\dominique[1]{{\color{purple} \sf \footnotesize {DD: #1}}\\}
\newcommand\lars[1]{{\color{purple} \sf \footnotesize {LB: #1}}\\}


%%% Math notation
\newcommand{\defeq}{\stackrel{\textit{\tiny{def}}}{=}}
\newcommand{\defbnf}{::=}
\newcommand{\sem}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\ssem}[2][\Phi]{\sem{#2}_{\mathrm{src}}(#1)}
\newcommand{\tsem}[2][\Phi]{\sem{#2}_{\mathrm{trg}}(#1)}
\newcommand{\dom}{\mathrm{dom}}

% Function arrows
\newcommand{\fun}{\rightarrow}
\newcommand{\parfun}{\rightharpoonup}

% Text
\newcommand{\tand}{\text{ and }}
\newcommand{\tor}{\text{ or }}
\newcommand{\totherwise}{\text{otherwise }}


%%% Instruction formatting
\newcommand{\sourcecolortext}{blue}
\newcommand{\sourcecolor}{\color{blue}}
\newcommand{\src}[1]{{\sourcecolor #1}}
\newcommand{\targetcolortext}{black}
\newcommand{\targetcolor}[1]{\color{black}}
\newcommand{\trg}[1]{{\targetcolor{} #1}}

\newcommand{\zinstr}[1]{\texttt{#1}}
\newcommand{\oneinstr}[2]{
  \ifthenelse{\equal{#2}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2}
}
\newcommand{\twoinstr}[3]{
  \ifthenelse{\equal{#2#3}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3}
}
\newcommand{\threeinstr}[4]{
  \ifthenelse{\equal{#2#3#4}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3 \; #4}
}

\newcommand{\fourinstr}[5]{
  \ifthenelse{\equal{#2#3#4#5}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3 \; #4 \; #5}
}


%%% Source language
% No arguments
\newcommand{\sfail}{\zinstr{\src{fail}}}
\newcommand{\shalt}{\zinstr{\src{halt}}}
\newcommand{\sreturn}{\zinstr{\src{return}}}

% One argument
\newcommand{\sjmp}[1]{\oneinstr{\src{jmp}}{#1}}
\newcommand{\spush}[1]{\oneinstr{\src{push}}{#1}}
\newcommand{\spop}[1]{\oneinstr{\src{pop}}{#1}}

% Two arguments
\newcommand{\sjnz}[2]{\twoinstr{\src{jnz}}{#1}{#2}}
\newcommand{\sisptr}[2]{\twoinstr{\src{gettype}}{#1}{#2}}
\newcommand{\sgeta}[2]{\twoinstr{\src{geta}}{#1}{#2}}
\newcommand{\sgetb}[2]{\twoinstr{\src{getb}}{#1}{#2}}
\newcommand{\sgete}[2]{\twoinstr{\src{gete}}{#1}{#2}}
\newcommand{\sgetp}[2]{\twoinstr{\src{getp}}{#1}{#2}}
%\newcommand{\sgetloc}[2]{\twoinstr{\src{getloc}}{#1}{#2}}
\newcommand{\sgetlin}[2]{\twoinstr{\src{get}}{#1}{#2}}
\newcommand{\smove}[2]{\twoinstr{\src{move}}{#1}{#2}}
\newcommand{\sstore}[2]{\twoinstr{\src{store}}{#1}{#2}}
\newcommand{\sload}[2]{\twoinstr{\src{load}}{#1}{#2}}
\newcommand{\scca}[2]{\twoinstr{\src{cca}}{#1}{#2}}
\newcommand{\ssload}[2]{\twoinstr{\src{sload}}{#1}{#2}}
\newcommand{\scall}[2]{\twoinstr{\src{call}}{#1}{#2}}
\newcommand{\sxjmp}[2]{\twoinstr{\src{xjmp}}{#1}{#2}}
\newcommand{\ssetatob}[2]{\twoinstr{\src{seta2b}}{#1}{#2}}

% Three arguments
\newcommand{\srestrict}[3]{\threeinstr{\src{restrict}}{#1}{#2}{#3}}
\newcommand{\slt}[3]{\threeinstr{\src{lt}}{#1}{#2}{#3}}
\newcommand{\splus}[3]{\threeinstr{\src{plus}}{#1}{#2}{#3}}
\newcommand{\sminus}[3]{\threeinstr{\src{minus}}{#1}{#2}{#3}}
\newcommand{\scseal}[3]{\threeinstr{\src{cseal}}{#1}{#2}{#3}}
\newcommand{\ssplice}[3]{\threeinstr{\src{splice}}{#1}{#2}{#3}}


% Four arguments
%\newcommand{\ssubseg}[4]{\fourinstr{\src{subseg}}{#1}{#2}{#3}{#4}}
\newcommand{\ssplit}[4]{\fourinstr{\src{split}}{#1}{#2}{#3}{#4}}

%%% Target language
% No arguments
\newcommand{\tfail}{\zinstr{\trg{fail}}}
\newcommand{\thalt}{\zinstr{\trg{halt}}}

% One argument
\newcommand{\tjmp}[1]{\oneinstr{\trg{jmp}}{#1}}

% Two arguments
\newcommand{\tjnz}[2]{\twoinstr{\trg{jnz}}{#1}{#2}}
\newcommand{\tisptr}[2]{\twoinstr{\trg{gettype}}{#1}{#2}}
\newcommand{\tgeta}[2]{\twoinstr{\trg{geta}}{#1}{#2}}
\newcommand{\tgetb}[2]{\twoinstr{\trg{getb}}{#1}{#2}}
\newcommand{\tgete}[2]{\twoinstr{\trg{gete}}{#1}{#2}}
\newcommand{\tgetp}[2]{\twoinstr{\trg{getp}}{#1}{#2}}
%\newcommand{\tgetloc}[2]{\twoinstr{\trg{getloc}}{#1}{#2}}
\newcommand{\tgetlin}[2]{\twoinstr{\trg{getl}}{#1}{#2}}
\newcommand{\tmove}[2]{\twoinstr{\trg{move}}{#1}{#2}}
\newcommand{\tstore}[2]{\twoinstr{\trg{store}}{#1}{#2}}
\newcommand{\tload}[2]{\twoinstr{\trg{load}}{#1}{#2}}
\newcommand{\tcca}[2]{\twoinstr{\trg{cca}}{#1}{#2}}
\newcommand{\txjmp}[2]{\twoinstr{\trg{xjmp}}{#1}{#2}}
\newcommand{\tsetatob}[2]{\twoinstr{\trg{seta2b}}{#1}{#2}}

% Three arguments
\newcommand{\tsplice}[3]{\threeinstr{\trg{splice}}{#1}{#2}{#3}}
\newcommand{\trestrict}[3]{\threeinstr{\trg{restrict}}{#1}{#2}{#3}}
\newcommand{\tlt}[3]{\threeinstr{\trg{lt}}{#1}{#2}{#3}}
\newcommand{\tplus}[3]{\threeinstr{\trg{plus}}{#1}{#2}{#3}}
\newcommand{\tminus}[3]{\threeinstr{\trg{minus}}{#1}{#2}{#3}}
\newcommand{\tcseal}[3]{\threeinstr{\trg{cseal}}{#1}{#2}{#3}}

% Four arguments
%\newcommand{\tsubseg}[4]{\fourinstr{\trg{subseg}}{#1}{#2}{#3}{#4}}
\newcommand{\tsplit}[4]{\fourinstr{\trg{split}}{#1}{#2}{#3}{#4}}

%%% Domains
\newcommand{\plaindom}[1]{\mathrm{#1}}

\newcommand{\nats}{\mathbb{N}}
\newcommand{\ints}{\mathbb{Z}}

%%% Updates
\newcommand{\update}[2]{[#1 \mapsto #2]}
\newcommand{\updReg}[2]{\update{\reg.#1}{#2}}
\newcommand{\updPc}[1]{\Phi\updReg{\pcreg}{#1}}

%%% Source dom
\newcommand{\shareddom}[1]{\mathrm{#1}}
\newcommand{\RegName}{\shareddom{RegisterName}}
\newcommand{\Addr}{\shareddom{Addr}}
\newcommand{\Seal}{\shareddom{Seal}}
\newcommand{\Perm}{\shareddom{Perm}}
\newcommand{\Caps}{\shareddom{Cap}}
\newcommand{\SealableCaps}{\shareddom{SealableCap}}
\newcommand{\Word}{\shareddom{Word}}
\newcommand{\Mem}{\shareddom{Memory}}
\newcommand{\Reg}{\shareddom{RegisterFile}}
\newcommand{\Stk}{\shareddom{Stack}}
\newcommand{\Conf}{\shareddom{Conf}}
\newcommand{\ExecConf}{\shareddom{ExecConf}}
%\newcommand{\Global}{\shareddom{Global}}
\newcommand{\Linear}{\shareddom{Linear}}
\newcommand{\MemSeg}{\shareddom{MemorySegment}}
\newcommand{\StkFrame}{\shareddom{StackFrame}}
\newcommand{\Stack}{\shareddom{Stack}}

\newcommand{\scbnf}{\shareddom{sc}}
\newcommand{\cbnf}{\shareddom{c}}
\newcommand{\permbnf}{\shareddom{perm}}
\newcommand{\addrbnf}{\shareddom{a}}
\newcommand{\basebnf}{\shareddom{base}}
\newcommand{\aendbnf}{\shareddom{end}}
%\newcommand{\glbnf}{\shareddom{gl}}
\newcommand{\linbnf}{\shareddom{l}}
\newcommand{\sealbasebnf}{\sigma_\shareddom{base}}
\newcommand{\sealendbnf}{\sigma_\shareddom{end}}

\newcommand{\sstk}{\shareddom{stk}}
\newcommand{\smsstk}{\shareddom{ms_{stk}}}
\newcommand{\sstkframe}{\shareddom{frame}}
\newcommand{\sopc}{\shareddom{opc}}
\newcommand{\sastk}{\shareddom{a_{stk}}}
\newcommand{\perm}{\var{perm}}
%\newcommand{\gl}{\var{g}}
\newcommand{\lin}{\var{l}}
\newcommand{\base}{\shareddom{base}}
\newcommand{\aend}{\shareddom{end}}
\newcommand{\addr}{\shareddom{a}}
\newcommand{\scap}{\shareddom{c}}
\newcommand{\sms}{\shareddom{ms}}

\newcommand{\stkptr}[1]{\mathrm{stack\text{-}ptr}(#1)}
\newcommand{\retptr}{\mathrm{ret\text{-}ptr}}
\newcommand{\retptrd}{\mathrm{ret\text{-}ptr\text{-}data}}
\newcommand{\retptrc}{\mathrm{ret\text{-}ptr\text{-}code}}

\newcommand{\seal}[1]{\shareddom{seal}(#1)}
\newcommand{\sealed}[1]{\shareddom{sealed}(#1)}

\newcommand{\failed}{\mathrm{failed}}
% DOMI: defining a macro named ``undefined'' breaks many latex packages.
%       (this is just another way that LaTeX is broken as a programming language)
% \newcommand{\undefined}{\mathrm{undefined}}
\newcommand{\tundefined}{\mathrm{undefined}}
\newcommand{\halted}{\mathrm{halted}}

%%% Target domain
\newcommand{\targetdom}[1]{\mathrm{#1}}
\newcommand{\tRegName}{\targetdom{RegisterName}}

%%% Variables
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\rn}{\var{rn}}
\newcommand{\reg}{\var{reg}}
\newcommand{\mem}{\var{mem}}
\newcommand{\ms}{\var{ms}}
\newcommand{\pc}{\var{pc}}
\newcommand{\stk}{\var{stk}}
\newcommand{\stkf}{\stk_{\var{frame}}}
\newcommand{\ret}{\var{ret}}
\newcommand{\data}{\var{data}}
\newcommand{\code}{\var{code}}
\newcommand{\priv}{\var{priv}}
\newcommand{\opc}{\var{opc}}
\newcommand{\odata}{\var{odata}}
\newcommand{\vsc}{\var{sc}}
\newcommand{\cb}{\var{cb}}
\newcommand{\baddr}{\var{b}}
\newcommand{\eaddr}{\var{e}}
\newcommand{\aaddr}{\var{a}}
\newcommand{\stdrng}{[\baddr,\eaddr]}

%%% Constants
\newcommand{\constant}[1]{\mathrm{#1}}
\newcommand{\calllen}{\constant{call\_len}}

%%% Named registers
\newcommand{\pcreg}{\mathrm{pc}}
\newcommand{\rstk}{\mathrm{r}_\mathrm{stk}}
\newcommand{\rO}{\mathrm{r}_\mathrm{ret}}
\newcommand{\rret}{\rO}
\newcommand{\rretc}{\mathrm{r}_\mathrm{ret code}}
\newcommand{\rretd}{\mathrm{r}_\mathrm{ret data}}
\newcommand{\rdata}{\mathrm{r}_\mathrm{data}}

%%% locality
%\newcommand{\plainlocality}[1]{\mathrm{#1}}
%\newcommand{\glob}{\plainlocality{global}}
%\newcommand{\local}{\plainlocality{local}}

%%% linearity
\newcommand{\plainlinearity}[1]{\mathrm{#1}}
\newcommand{\linear}{\plainlinearity{linear}}
\newcommand{\normal}{\plainlinearity{normal}}


%%% Permissions
\newcommand{\plainperm}[1]{\textsc{#1}}
%\newcommand{\rwlx}{\plainperm{rwlx}}
\newcommand{\rwx}{\plainperm{rwx}}
\newcommand{\rx}{\plainperm{rx}}
%\newcommand{\rwlxo}{\plainperm{rwlxo}}
%\newcommand{\rwlo}{\plainperm{rwlo}}
%\newcommand{\rwl}{\plainperm{rwl}}
%\newcommand{\rwxo}{\plainperm{rwxo}}
%\newcommand{\rwo}{\plainperm{rwo}}
\newcommand{\rw}{\plainperm{rw}}
%\newcommand{\rxo}{\plainperm{rxo}}
%\newcommand{\ro}{\plainperm{ro}}
\newcommand{\readonly}{\plainperm{r}}
\newcommand{\noperm}{\plainperm{0}}
%\newcommand{\nopermo}{\plainperm{0o}}
\newcommand{\enter}{\plainperm{e}}
%\newcommand{\entero}{\plainperm{eo}}

%%% Braces
\newcommand{\comp}[1]{[#1]}

%%% Functions
\newcommand{\plainfun}[2]{
  \ifthenelse{\equal{#2}{}}
  {\mathit{#1}}
  {\mathit{#1}(#2)}
}

\newcommand{\encType}[1]{\plainfun{encodeType}{#1}}
\newcommand{\encPerm}[1]{\plainfun{encocePerm}{#1}}
\newcommand{\decPerm}[1]{\plainfun{decodePerm}{#1}}
\newcommand{\updPcAddr}[1]{\plainfun{updatePc}{#1}}
\newcommand{\updPcPerm}[1]{\plainfun{updatePcPerm}{#1}}
\newcommand{\nonExec}[1]{\plainfun{nonExecutable}{#1}}
%\newcommand{\opaquePerm}[1]{\plainfun{opaquePerm}{#1}}
\newcommand{\readAllowed}[1]{\plainfun{readAllowed}{#1}}
\newcommand{\writeAllowed}[1]{\plainfun{writeAllowed}{#1}}
%\newcommand{\writeLocalAllowed}[1]{\plainfun{writeLocalAllowed}{#1}}
%\newcommand{\nonLoc}[1]{\plainfun{nonLocal}{#1}}
\newcommand{\nonLinear}[1]{\plainfun{nonLinear}{#1}}
\newcommand{\linCons}[1]{\plainfun{linearityConstraint}{#1}}
%\newcommand{\isLoc}[1]{\plainfun{isLocal}{#1}}
\newcommand{\isLinear}[1]{\plainfun{isLinear}{#1}}
\newcommand{\noRetStkReg}[1]{\plainfun{noRetStk_{reg}}{#1}}
\newcommand{\noRetStkMs}[1]{\plainfun{noRetStk_{ms}}{#1}}
\newcommand{\withinBounds}[1]{\plainfun{withinBounds}{#1}}
\newcommand{\nonZero}[1]{\plainfun{nonZero}{#1}}


\begin{document}
\section{The two capability machines}
\subsection{Domains}
\label{sec:domains}

\dominique{7-9-2017: Should we keep local/global and linear/non-linear?  I was thinking just the latter would suffice...}
\lau{07-09-2017: The local/global mechanism still has some value as it now can be used for the purpose of arguments that cannot be stored by the receiver (if you are willing to ``pay'' the clearing cost). I do, however, not think that it is strictly necessary here to make things work.}
\lau{12-09-2017: I will remove the local capabilities today for the reasons we have discussed (they add to the complexity and they seem to be of little to no use without a clear memory instruction).}
Source language domains:
\[
  \begin{array}{rrcl}
   \addrbnf,\basebnf \in & \Addr & \defeq & \nats \\
    \sealbasebnf, \sigma \in & \Seal & \defeq & \nats \\
    &\Word & \defeq & \ints \uplus \SealableCaps\\
    \permbnf \in& \Perm & \defbnf & \dots \\
    &\linbnf & \defbnf & \linear \mid \normal \\
    &\aendbnf & \in & \Addr \uplus \{\infty \} \\
    &\sealendbnf & \in & \Seal \uplus \{\infty \} \\
    &\scbnf &\defbnf & ((\permbnf,\linbnf),\basebnf,\aendbnf,\addrbnf) \mid \seal{\linbnf,\sealbasebnf,\sealendbnf,\sigma}\\
    & & & {\sourcecolor{} \mid \stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}}\\ 
    &\cbnf & \defbnf &  \scbnf \mid \sealed{\scbnf,\sigma}{\sourcecolor{} \; \mid \retptrd(\sigma) \mid \retptrc(\sigma)}\\ 
    &\RegName & \defbnf &\pcreg \mid \rret \mid \rstk \mid \rdata \mid \dots \\
    &\Reg & \defeq & \RegName \fun \Word\\
    &\Mem & \defeq & \Addr \fun \Word \\
    &\MemSeg & \defeq & \Addr \parfun \Word \\
    {\sourcecolor \sstkframe \in} & {\sourcecolor \StkFrame} & {\sourcecolor \defeq} & {\sourcecolor \Caps \times \MemSeg \times \Addr}\\
    \src{\sstk \in}& \src{ \Stack} & \src{ \defeq} & \src{ \StkFrame^*} \\
    \Phi \in & \ExecConf & \defeq & \Mem \times \Reg {\sourcecolor{} \; \times \; \Stack \times \MemSeg }\\
    &\Conf & \defeq & \ExecConf \uplus \{\failed\} \uplus (\{\halted\} \times \Mem)
  \end{array}
\]
\lau{06-09-2017: Should seals also have the option to be linear?}
\lau{13-09-2017: For now I have added linearity to the seals.}
The target language domains are all the non blue parts in the above. The source language domains are the black and blue parts in the above. Further
\begin{itemize}
\item $\linbnf$ defines domain $\Linear$
\item $\scbnf$ defines domain $\SealableCaps$
\item $\cbnf$ defines domain $\Caps$
\item $\Perm$ is defined as the set of permissions in Figure~\ref{fig:perm-hier}.
\end{itemize}

In the source language, $\src{\Stack}$ is a call stack that contains the data for each call. The call stack consists of a number of $\src{\StkFrame}$'s that contains 1) the old pc, 2) caller's private stack, and 3) the address of the old stack pointer. 

More convenient definitions
\[
  \begin{array}{rcl}
    \Phi(r) & \defeq & \Phi.\reg(r)
  \end{array}
\]
where $r\in \RegName$.

\subsection{Syntax}
\label{sec:syntax}
The target machine is a simple capability machine with memory capabilities and sealed capabilities\footnote{In previous work, we used enter capabilities but for this the complexity introduced by mixing writable and executable memory is difficult to handle.} (inspired by CHERI). The syntax of the instructions of the target machine is defined as follows:
\[
\begin{array}{rcl}
n &\in & \nats \\
\trg{r} &\in &  \tRegName \\
\trg{\rn} &\defbnf &  \trg{r} \mid n \\
\trg{i} &\defbnf & \tfail \mid \thalt \mid \tjmp{\trg{r}} \mid \tjnz{\trg{r}}{\trg{\rn}} \mid \tisptr{\trg{r}}{\trg{r}} \mid \tgeta{\trg{r}}{\trg{r}} \mid \tgetb{\trg{r}}{\trg{r}} \mid \\
      & &  \tgete{\trg{r}}{\trg{r}}\mid \tgetp{\trg{r}}{\trg{r}} \mid \tgetlin{\trg{r}}{\trg{r}} \mid \tmove{\trg{r}}{\trg{\rn}} \mid \tstore{\trg{r}}{\trg{r}} \mid\\
      & &  \tload{\trg{r}}{\trg{r}} \mid \tcca{\trg{r}}{\trg{\rn}} \mid \trestrict{\trg{r}}{\trg{r}}{\trg{\rn}} \mid \tlt{\trg{r}}{\trg{r}}{\trg{r}} \mid \\
  & & \tplus{\trg{r}}{\trg{\rn}}{\trg{\rn}} \mid \tminus{\trg{r}}{\trg{\rn}}{\trg{\rn}} \mid \tsetatob{\trg{r}}{\trg{r}} \mid \txjmp{\trg{r}}{\trg{r}} \mid \tcseal{\trg{r}}{\trg{r}}{\trg{r}} \mid \\ 
      & &   \tsplit{\trg{r}}{\trg{r}}{\trg{r}} \mid\tsplice{\trg{r}}{\trg{r}}{\trg{r}} 
\end{array}
\]

The source machine is also a capability machine with memory capabilities and sealed capabilities. Unlike the target machine, the source machine is going to have a built in stack along with special stack and return capabilities. The syntax of the source machine language is as follows:
\[
  \begin{array}{rcl}
    n & \in & \nats \\
    \src{r} &\in &  \RegName \setminus \{\rstk\}\\
    \src{\rn} &\defbnf & \src{r} \mid n \\
    \src{i} & \defbnf &  \trg{i} \mid \scall{\src{r}}{\src{r}}
  \end{array}
\]
\lau{30-08-2017: We had $\rret$ as not being one of the registers on the source machine. I could not recall why we had this, so I removed it. (I think it may have been from when we had call and return instructions?)}
There is one syntactic difference between the source language and the target language, namely the target language has an extra instruction in the $\scall{}{}$ instruction.

\subsection{Permissions}
\lau{23-03-2017: I am not sure we need the opaque capabilities anymore.} % I am not sure why I did not think the opaque capabilities where necessary, but I have a feeling we talked about this in Leuven and came to the conclusion that they were necessary.
\begin{figure}[!h]
  \centering
  \begin{tikzpicture}[main node/.style={}]
    \node[main node] (rwx) {$\rwx$};
    \node[main node] (rx) [below of=rwx] {$\rx$};
    \node[main node] (e) [below of=rx] {$\enter$};


    \node[main node] (rw) [below left of=rwx,xshift=-0.5cm,yshift=-0.3cm] {$\rw$};
    \node[main node] (r) [below of=rw] {$\readonly$};
    \node[main node] (0) [below of=r] {$\noperm$};

    \path[every node/.style={font=\sffamily\small}]

    (rw) edge (r)
    (r) edge (0)


    (rwx) edge (rx)
    (rx) edge (e)


    (rw) edge (rwx)
    (r) edge (rx)
    (0) edge (e);
  \end{tikzpicture}

  \caption{Permission hierarchy}
  \label{fig:perm-hier}
\end{figure}
\lau{01-09-2017: For now, I will add the linear capabilities such that a linear capability stays linear. It does, however, seem like it would be okay to have linear capabilities become non-linear (I at least don't see anything that would break down completely). One draw back would be that one could ``ruin'' the stack capability by making it non-linear.}
\dominique{7-9-2017: Err... you mean that we could allow non-linear capabilities to be made linear, right?  We definitely do not want to allow the stack or return capability to be made non-linear, as we want to prevent it from being aliased.}
\lau{07-09-2017: I actually did mean linear to non-linear (non-linear to linear does not make sense because the non-linear capability may have aliases). The operation that makes a linear capability non-linear would have to clear said capability. If a linear capability has been made non-linear, then someone who expects a linear capability can observe this difference and behave accordingly, i.e., fail the execution. It will, however, remain an invariant that there are no aliases for linear capabilities.}
\lau{07-09-2017: I had forgotten that return capabilities probably need to be linear. This would call for a ``load from offset'' operation to be able to load an in code stored seal (see the figure I drew about linking/seals).}
\lau{13-09-2017: Note that most of the above discussion is now captured in Section~\ref{sec:linear-cap}}

We assume functions $\decPerm{}$ and $\encPerm{}$.
\lau{15-09-2017: TOOD, write more about these. Should be like in the local cap setting.}

\subsection{Operational Semantics}
\subsubsection{Notes}
Genrally:
\begin{itemize}
%\item Opaque capabilities: Only allow locality and permission to be inspected (i.e., no addresses disclosed).
\item Linear capabilities are cleared when they move around in memory.
\end{itemize}

Source language:
\begin{itemize}
\item Variable length instructions that match the length of the compiled instructions
  \begin{itemize}
%  \item Opaque capabilities do not hide the length of a program (especially an issue if we ever hope to have error recovery).
  \item This is needed for correctness. See subsection~\ref{subsec:capability-opacity} for an example it helps prevent.
  \end{itemize}
\item Programs have undefined behavior when passing ret/stk pointers.
\end{itemize}

Target language:
\begin{itemize}
\item 
\end{itemize}

\subsubsection{Helpful functions and sets}


\[
  \updPcAddr{c} \defeq \dots
\]

\[
  \updPcPerm{c} \defeq
  \begin{cases}
    ((\rx,\lin),\baddr,\eaddr,\aaddr) & c = ((\enter,\lin),\baddr,\eaddr,\aaddr)\\
    c & \totherwise
  \end{cases}
\]

\[
  \readAllowed{} \defeq \dots
\]

\[
  \writeAllowed{} \defeq \dots
\]

\[
  \isLinear{\cb} \defeq
  \begin{cases}
    \top & 
    \arraycolsep=0pt
    \begin{array}[t]{l}
      \cb = ((\_,\linear),\_,\_,\_) \tor\\
      \cb = \seal{\linear,\_,\_,\_} \tor\\
      \cb = \sealed{\cb',\_} \tand \isLinear{\cb'} 
    \end{array}\\
    \src{\top} & 
    \sourcecolor\left.
    \arraycolsep=0pt
    \begin{array}[t]{l}
      \cb = \stkptr{\_,\_,\_,\_}\\
      \cb = \retptrd(\_)
    \end{array}\right.\\
    \bot & \totherwise
  \end{cases}
\]

\[
  \nonLinear{\cb} \defeq \neg \isLinear{\cb}
\]

\[
  \linCons{w} \defeq
  \begin{cases}
    0 & \isLinear{w} \\
    w & \totherwise
  \end{cases}
\]

\[
  \nonExec{\cb} \defeq \dots
\]

\[
  \withinBounds{c} \defeq \dots
\]

\[
  \nonZero{w} \defeq
  \begin{cases}
    \bot & w \in \ints \tand w = 0 \\
    \top & \totherwise
  \end{cases}
\]

\subsubsection{Instruction Interpretation}
We have unified the two languages in the below definitions. Everything written in black is common for both source and target language. Everything written in \src{blue} is specific to the source language.

\noindent\textbf{fail and halt}\\
\begin{align*}
  \sem{\tfail}(\Phi) = & \; \failed \\
  \sem{\thalt}(\Phi) = & \; (\halted, \Phi.\mem)
\end{align*}

\noindent\textbf{jmp and jnz}\\
\begin{align*}
  \sem{\tjmp{r}}(\Phi) = &  
                     \begin{cases}
                       \Phi\updReg{r}{w}\updReg{\pcreg}{\updPcPerm{\Phi(r)}} & w = \linCons{\Phi(r)}
                     \end{cases}
\end{align*}

\begin{align*}
  \sem{\tjnz{r_1}{r_2}}(\Phi) = &       
                             \begin{cases}
                               \arraycolsep=0pt
                               \begin{array}[t]{rl}
                                 \Phi&\updReg{r_1}{w}\\
                                     &\updReg{\pcreg}{\Phi(r_1)}
                               \end{array}
                                               & w = \linCons{\Phi(r_1)} \tand \nonZero{\Phi(r_2)}\\
                               \updPcAddr{\Phi} & \totherwise
                             \end{cases}
\end{align*}

\noindent\textbf{gettype}\\
In the definitions of the semantics below, we use a function $\encType{} : \Word \rightarrow \ints$. This is an encoding function for which the specific implementation does not matter. As the words of the two machines differ, we really need two functions which we call $\encType{}_{\var{src}}$ and $\encType{}_{\var{trg}}$. These two functions need to be related in the following way:
\lau{14-09-2017: Insert the relation. My impression is that the the words specific to the source machine should have the same "type" as their implementaion at the source level (I am not sure this is the case - maybe it is okay to just relate the values returned by the special words to the ones returned when used with the implementation). }
\begin{align*}
  \sem{\tisptr{r_1}{r_2}}(\Phi) = & \; \updPcAddr{}(\Phi\updReg{r_1}{\encType{\Phi(r_2)}})
\end{align*}


\noindent\textbf{geta, getb, gete, getp, and getl}\\
We assume function to encode and decode permissions as well as a function to encode and decode linearity. The functions are used implicitely when a permission or linearity is used in a place where they need to be a word.
\lau{14-09-2017: Write more about this (types and assumptions)}
\begin{align*}
  \sem{\tgeta{r_1}{r_2}}(\Phi) = & 
                                   \begin{cases}
                                     \updPcAddr{\Phi\updReg{r_1}{\aaddr}} & 
                                     \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_2) = ((\_,\_),\_,\_,\aaddr) \\
                                       \quad \tor \Phi(r_2) = \seal{\_,\_,\_,\aaddr} \\
                                       \quad \src{\tor \Phi(r_2) = \stkptr{\_,\_,\_,\aaddr} } \\
                                     \end{array} \\
                                     \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                                   \end{cases}
\end{align*}

\begin{align*}
  \sem{\tgetb{r_1}{r_2}}(\Phi) = & 
                                   \begin{cases}
                                     \updPcAddr{\Phi\updReg{r_1}{\baddr}} & 
                                     \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_2) = ((\_,\_),\baddr,\_,\_) \\
                                       \quad \tor \Phi(r_2) = \seal{\_,\baddr,\_,\_} \\
                                       \quad \src{\tor \Phi(r_2) = \stkptr{\_,\baddr,\_,\_} } \\
                                     \end{array} \\
                                     \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                                   \end{cases}
\end{align*}

\begin{align*}
  \sem{\tgete{r_1}{r_2}}(\Phi) = & 
                                   \begin{cases}
                                     \updPcAddr{\Phi\updReg{r_1}{\eaddr}} & 
                                     \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_2) = ((\_,\_),\_,\eaddr,\_) \\
                                       \quad \tor \Phi(r_2) = \seal{\_,\_,\eaddr,\_} \\
                                       \quad \src{\tor \Phi(r_2) = \stkptr{\_,\_,\eaddr,\_} } \\
                                     \end{array} \\
                                     \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                                   \end{cases}
\end{align*}
\lau{15-09-2017: Should gete and getb do something for seals?}

\begin{align*}
  \sem{\tgetp{r_1}{r_2}}(\Phi) = & 
                                   \begin{cases}
                                     \updPcAddr{\Phi\updReg{r_1}{\perm}} & 
                                     \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_2) = ((\perm,\_),\_,\_,\_) \\
                                       \quad \src{\tor \Phi(r_2) = \stkptr{\perm,\_,\_,\_} } \\
                                     \end{array} \\
                                     \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                                   \end{cases}
\end{align*}

\begin{align*}
  \sem{\tgetlin{r_1}{r_2}}(\Phi) = & 
                                   \begin{cases}
                                     \updPcAddr{\Phi\updReg{r_1}{\lin}} & 
                                     \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_2) = ((\_,\lin),\_,\_,\_) \\
                                       \quad \tor \Phi(r_2) = \seal{\lin,\_,\_,\_} \\
                                       \quad \src{\tor \Phi(r_2) = \stkptr{\_,\_,\_,\_} \tand l = \linear}\\
                                     \end{array} \\
                                     \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                                   \end{cases}
\end{align*}
\lau{15-09-2017: Should getl do something for seals?}
\lau{15-09-2017: Do we want to allow getl and getp to work on sealed capabilities?}

\noindent\textbf{move}\\
\begin{align*}
  \sem{\tmove{r_1}{r_2}}(\Phi) = & 
                              \begin{cases}
                                \updPcAddr{\Phi\updReg{r_1}{r_2}} & r_2 \in \ints \\
                                \updPcAddr{\Phi\updReg{r_1}{\Phi(r_2)}} & \nonLinear{\Phi(r_2)}\\
                                \updPcAddr{\Phi\updReg{r_2}{0}\updReg{r_1}{\Phi(r_2)}} & \totherwise 
                              \end{cases}
\end{align*}
Notice that in the case where we are moving a linear capability and $r_1 = r_2$ the order of the updates matter.

\noindent\textbf{store}\\
\begin{align*}
  \sem{\tstore{r_1}{r_2}}(\Phi) = &
                                    \begin{cases}
                                      \updPcAddr{}\left(
                                        \arraycolsep=0pt
                                        \begin{array}{rl}
                                          \Phi&\updReg{r_2}{w_2}\\
                                              &\update{\mem.a}{w}
                                        \end{array}
\right) & 
                                      \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        \Phi(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                        \perm \in \writeAllowed{} \tand\\
                                        \withinBounds{\Phi(r_1)} \tand \\
                                        w = \Phi(r_2) \tand \\
                                        w_2 = \linCons{w}
                                      \end{array}
                                      \\
                                      \sourcecolor\left.
                                      \updPcAddr{}\left(
                                      \arraycolsep=0pt
                                      \begin{array}{rl}
                                        \Phi&\update{\mem_\stk.a}{w}\\
                                            &\updReg{r_2}{w_2}
                                      \end{array}
                                      \right) \right.& 
                                      \sourcecolor\left.
                                      \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        \Phi(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                        \perm \in \writeAllowed{} \tand \\
                                        \withinBounds{\Phi(r_1)} \tand \\
                                        a \in \dom(\Phi.\ms_\stk) \tand \\
                                        w = \Phi(r_2) \\
                                        w_2 = \linCons{w}
                                      \end{array}\right.\\
                                      \failed & \totherwise
                                    \end{cases}
\end{align*}

\noindent\textbf{load}\\
\begin{align*}
  \sem{\tload{r_1}{r_2}}(\Phi) = & 
                                  \begin{cases}
                                    \updPcAddr{}\left(
                                      \arraycolsep=0pt
                                      \begin{array}{rl}
                                        \Phi&\updReg{r_1}{w}\\
                                            &\update{\mem.a}{w_2}
                                      \end{array}\right)& 
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                      \perm \in \readAllowed{} \tand\\
                                      \withinBounds{\Phi(r_2)} \tand \\
                                      w = \Phi.\mem(a) \tand \\
                                      w_2 = \linCons{w}
                                    \end{array}
                                    \\
                                    \sourcecolor\left.
                                    \updPcAddr{}\left(
                                      \arraycolsep=0pt
                                      \begin{array}{rl}
                                        \Phi&\updReg{r_1}{w}\\
                                            & \update{\mem_\stk.a}{w_2}
                                      \end{array}\right)\right.
                                    & 
                                    \sourcecolor\left.
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                      \perm \in \readAllowed{} \tand \\
                                      \withinBounds{\Phi(r_2)} \tand \\
                                      \aaddr \in \dom(\Phi.\ms_\stk) \tand \\
                                      w = \Phi.\ms_\stk(a) \tand \\
                                      w_2 = \linCons{w}
                                    \end{array}\right.
                                    \\
                                    \failed & \totherwise                                    
                                  \end{cases}
\end{align*} 

\noindent\textbf{cca}\\
\emph{Change Current Address}
\lau{15-09-2017: This is the old lea. I changed the name, so it actually reflects what the instruction does. We might also want to add a real lea at some point.}
\begin{align*}
  \sem{\tcca{r_1}{r_2}}(\Phi) = & 
                                  \begin{cases}
                                    \updPcAddr{\Phi\updReg{r_1}{c}} &  
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \text{either $n = r_2$ or $n = \Phi.\reg(r_2)$}\\
                                      \quad\text{ and in either case $n \in \ints$ and} \\
                                      \Phi(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                      \perm \neq \enter \tand \\
                                      c = ((\perm,\lin),\baddr,\eaddr,\aaddr + n)
                                    \end{array}
                                    \\
                                    \updPcAddr{\Phi\updReg{r_1}{c}} &  
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \text{either $n = r_2$ or $n = \Phi.\reg(r_2)$}\\
                                      \quad\text{ and in either case $n \in \ints$ and} \\
                                      \Phi(r_1) = \seal{\lin,\sigma_\baddr,\sigma_\eaddr,\sigma} \tand \\
                                      c = \seal{\lin,\sigma_\baddr,\sigma_\eaddr,\sigma + n}
                                    \end{array}
                                    \\
                                    \src{\updPcAddr{\Phi\updReg{r_1}{c}}} &  
                                    \sourcecolor\left.
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \text{either $n = r_2$ or $n = \Phi(r_2)$}\\
                                      \quad\text{ and in either case $n \in \ints$ and} \\
                                      \Phi(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                      \perm \neq \enter \tand \\
                                      c = \stkptr{\perm,\baddr,\eaddr,\aaddr + n}
                                    \end{array}\right.
                                    \\
                                    \failed & \totherwise
                                  \end{cases}
\end{align*}

\noindent\textbf{restrict}\\
This instruction uses the $\decPerm{}$ function.
\begin{align*}
  \sem{\trestrict{r_1}{r_2}{r_3}} = &
                                      \begin{cases}
                                        \updPcAddr{}\left(
                                          \arraycolsep=0pt
                                          \begin{array}{rl}
                                          \Phi&\updReg{r_2}{w_2}\\
                                              &\updReg{r_1}{c}
                                          \end{array} \right)
&
                                        \arraycolsep=0pt
                                        \begin{array}[t]{l}
                                          \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                          \text{either $n = r_2$ or $n = \Phi.\reg(r_2)$}\\
                                          \quad\text{and in either case $n \in \ints$ and} \\
                                          \decPerm{n} \sqsubseteq \perm \tand \\
                                          c = ((\decPerm{n},\lin),\baddr,\eaddr,\aaddr) \tand \\
                                          w_2 = \linCons{\Phi(r_2)}
                                        \end{array}
                                        \\
                                        \sourcecolor\left.
                                        \updPcAddr{}\left(
                                          \arraycolsep=0pt
                                          \begin{array}{rl}
                                          \Phi&\updReg{r_2}{0}\\
                                                    &\updReg{r_1}{c}
                                          \end{array}\right)\right.
                                        &
                                        \sourcecolor\left.
                                        \arraycolsep=0pt
                                        \begin{array}[t]{l}
                                          \Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                          \text{either $n = r_2$ or $n = \Phi.\reg(r_2)$}\\
                                          \quad\text{and in either case $n \in \ints$ and} \\
                                          \decPerm{n} \sqsubseteq \perm \tand \\
                                          c = \stkptr{\decPerm{n},\baddr,\eaddr,\aaddr}
                                        \end{array}\right.
                                        \\
                                        \failed & \totherwise
                                      \end{cases}
\end{align*}

\noindent\textbf{lt}\\
\begin{align*}
  \sem{\tlt{r_0}{r_1}{r_2}}(\Phi) = &
                                                  \begin{cases}
                                                    \updPcAddr{\Phi\updReg{r_0}{1}} &
                                                    \arraycolsep=0pt
                                                    \begin{array}[t]{l}
                                                      \text{if for $i \in \{1,2\}$}\\
                                                      \quad\text{$n_i = r_i$ or $n_i = \Phi(r_i)$}\\
                                                      \quad\text{and in either case $n_i \in \ints$}\\
                                                      \quad\text{and $n_1 < n_2$}\\        
                                                    \end{array}\\
                                                    \updPcAddr{\Phi\updReg{r_0}{0}} &
                                                    \arraycolsep=0pt
                                                    \begin{array}[t]{l}
                                                      \text{if for $i \in \{1,2\}$}\\
                                                      \quad\text{$n_i = r_i$ or $n_i = \Phi(r_i)$}\\
                                                      \quad\text{and in either case $n_i \in \ints$}\\
                                                      \quad\text{and $n_1 \not< n_2$}\\        
                                                    \end{array}\\
                                                    \failed & \text{otherwise}
                                                  \end{cases}  
\end{align*}

\noindent\textbf{plus and minus}\\
\begin{align*}
  \sem{\tplus{r_0}{r_1}{r_2}}(\Phi) = &
                                                  \begin{cases}
                                                    \updPcAddr{\Phi\updReg{r_0}{n_1+n_2}} &
                                                    \arraycolsep=0pt
                                                    \begin{array}[t]{l}
                                                      \text{if for $i \in \{1,2\}$}\\
                                                      \quad\text{$n_i = r_i$ or $n_i = \Phi(r_i)$}\\
                                                      \quad\text{and in either case $n_i \in \ints$}\\
                                                    \end{array}\\
                                                    \failed & \text{otherwise}
                                                  \end{cases}  
\end{align*}

\begin{align*}
  \sem{\tminus{r_0}{r_1}{r_2}}(\Phi) = &
                                                  \begin{cases}
                                                    \updPcAddr{\Phi\updReg{r_0}{n_1-n_2}} &
                                                    \arraycolsep=0pt
                                                    \begin{array}[t]{l}
                                                      \text{if for $i \in \{1,2\}$}\\
                                                      \quad\text{$n_i = r_i$ or $n_i = \Phi(r_i)$}\\
                                                      \quad\text{and in either case $n_i \in \ints$}\\
                                                    \end{array}\\
                                                    \failed & \text{otherwise}
                                                  \end{cases}  
\end{align*}

\noindent\textbf{seta2b}\\
\begin{align*}
  \sem{\tsetatob{r_1}{r_2}}(\Phi) = & 
                                \begin{cases}
                                  \updPcAddr{}\left(
                                    \arraycolsep=0pt
                                    \begin{array}{rl}
                                    \Phi&\updReg{r_2}{w_2}\\
                                        &\updReg{r_1}{c}
                                    \end{array} \right)
&
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\_) \tand \\
                                      \perm \neq \enter \tand \\
                                      w_2 = \linCons{\Phi(r_2)}\\
                                      c = ((\perm,\lin),\baddr,\eaddr,\baddr)
                                    \end{array} \\
                                  \updPcAddr{}\left(
                                    \arraycolsep=0pt
                                    \begin{array}{rl}
                                    \Phi&\updReg{r_2}{w_2}\\
                                        &\updReg{r_1}{c}
                                    \end{array} \right)
&
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \Phi(r_2) = \seal{\lin,\sigma_\baddr,\sigma_\eaddr,\_} \tand \\
                                      w_2 = \linCons{\Phi(r_2)}\\
                                      c = \seal{\lin,\sigma_\baddr,\sigma_\eaddr,\sigma_\baddr}
                                    \end{array} \\
                                    \failed & \totherwise
                                \end{cases}
\end{align*}

\noindent\textbf{xjmp}\\
\lau{22-09-2017: Can we allow the callee to return any stack pointer? At the moment, it is not possible to create an empty stack pointer which may be a saving grace. If we at some point change this, so you can split capabilities into empty ones, then we need to consider whether it is safe for callees to return empty stacks (I think it is okay as long as we always have some stack usage).}
\begin{align*}
  \sem{\txjmp{r_1}{r_2}}(\Phi) = &
                                   \begin{cases}
                                     \arraycolsep=0pt
                                     \begin{array}[t]{rl}
                                       \Phi & \updReg{r_1}{w_1}\\
                                            & \updReg{r_2}{w_2}\\
                                            & \updReg{\pcreg}{c_\code}\\
                                            & \updReg{\rdata}{c_\data}
                                     \end{array} &
                                     \begin{array}[t]{l}
                                       \Phi(r_1) = \sealed{c_\code,\sigma} \tand \\
                                       \Phi(r_2) = \sealed{c_\data,\sigma} \tand \\
                                       \nonExec{c_\data} \tand \\
                                       w_1 = \linCons{\Phi(r_1)} \tand \\
                                       w_2 = \linCons{\Phi(r_2)}
                                     \end{array}
                                     \\&\\
                                     \sourcecolor\left.
                                       \arraycolsep=0pt
                                       \begin{array}[t]{rl}
                                         \Phi' & \updReg{r_2}{0} \\
                                               & \updReg{\pcreg}{\opc}\\
                                               & \updReg{\rdata}{0}\\
                                               & \updReg{\rstk}{c_\stk}
                                       \end{array}\right.& 
                                     \sourcecolor\left.
                                       \begin{array}[t]{l}
                                         \Phi(r_1) = \retptrc(\sigma) \tand \\
                                         \Phi(r_2) = \retptrd(\sigma) \tand \\
                                         \Phi(\rstk) = \stkptr{\rw,\baddr_\stk,\eaddr_\stk,\_} \tand \\
                                         \Phi = (\mem,\reg,\stkf::\stk,\ms_\stk) \tand \\
                                         \stkf = (\opc,\ms_{\stk,\priv},\aaddr_\stk) \tand \\
                                         c_\stk = \stkptr{\rw,\baddr_{\stk,\priv},\eaddr_\stk,\aaddr_\stk} \tand\\
                                         \dom(\ms_{\stk,\priv}) = [\baddr_{\stk,\priv},\baddr_\stk - 1] \tand\\
                                         \Phi' = (\mem,\reg,\stk,\ms_{\stk,\priv} \uplus \ms_\stk) 
                                       \end{array}\right.
                                     \\
                                     \failed & \totherwise
                                   \end{cases}
\end{align*}

\noindent\textbf{cseal}\\
\begin{align*}
  \sem{\tcseal{r_1}{r_2}{r_3}}(\Phi) = &
                                  \begin{cases}
                                    \Phi\updReg{r_1}{\vsc} &
                                    \arraycolsep=0pt
                                    \begin{array}[t]{l}
                                      \Phi(r_2) \in \SealableCaps \tand \\
                                      \Phi(r_3) = \seal{\lin, \sigma_\baddr, \sigma_\eaddr,\sigma} \tand \\
                                      \sigma_\baddr \leq \sigma \leq \sigma_\eaddr \tand \\ 
                                      \vsc = \sealed{\Phi(r_2),\sigma}
                                    \end{array}
                                    \\
                                    \failed & \totherwise
                                  \end{cases}
\end{align*}

\noindent\textbf{split and splice}\\
We would like splice and split to have the following properties
\begin{enumerate}
\item No authority amplification - splitting or splicing capabilities should give you no more authority than you already had.
\item Split should be dual to splice in the sence that a split on a capability followed by a splice of the two resulting capabilities should yield the same capability.
\item Take the addresses governed by a linear capability to be a multiset. If this capability is split, then the union of the two multisets of addresses governed by the resulting capabilities should be the same as the first multiset. In other words, splice and split should not break linearity.
\end{enumerate}
Split cannot create ``empty capabilities'' (a capability that governs no segment of the memory, i.e.\ a capability where the base address is greater than the end address). We partly do not allow this out of convenience as it makes the implementation of call simpler. We do not need empty capabilities as they have no semantic value in the sense that they allow you to do no more than a piece of data.
\begin{align*}
  \tsem{\tsplit{r_1}{r_2}{r_3}{r_4}} = &
                               \begin{cases}
                                 \updPcAddr{}\left(
                                   \arraycolsep=0pt
                                   \begin{array}{rl}
                                     \Phi&\updReg{r_3}{w}\\
                                         &\updReg{r_1}{c_1}\\
                                         &\updReg{r_2}{c_2}
                                   \end{array}\right)
&
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_3) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                   \perm \neq \enter \tand \\
                                   \Phi(r_4) = n \tor r_4 = n \\
                                   \quad\text{ and in either case } n \in \nats \\
                                   \baddr \leq n \tand n < \eaddr \tand \\
                                   c_1 = ((\perm,\lin),\baddr,n,\aaddr) \tand \\
                                   c_2 = ((\perm,\lin),n+1,\eaddr,\aaddr) \tand \\
                                   w = \linCons{\Phi(r_3)}
                                 \end{array}\\
                                 \updPcAddr{} \left(
                                 \arraycolsep=0pt
                                 \begin{array}{rl}
                                   \Phi&\updReg{r_3}{w}\\
                                       &\updReg{r_1}{c_1}\\
                                       &\updReg{r_2}{c_2}
                                 \end{array} \right)
&
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_3) = \seal{\lin,\sigma_\baddr,\sigma_\eaddr,\sigma} \tand \\
                                   \Phi(r_4) = n \tor r_4 = n \\
                                   \quad\text{ and in either case } n \in \nats \\
                                   \sigma_\baddr \leq n \tand n < \sigma_\eaddr \tand \\
                                   c_1 = \seal{\lin,\sigma_\baddr,n,\sigma} \tand \\
                                   c_2 = \seal{\lin,n+1,\sigma_\eaddr,\sigma} \tand \\
                                   w = \linCons{\Phi(r_3)}
                                 \end{array}\\
                                   \sourcecolor\left.
                                   \updPcAddr{}\left(
                                   \arraycolsep=0pt
                                   \begin{array}{rl}
                                     \Phi&\updReg{r_3}{0}\\
                                               &\updReg{r_1}{c_1}\\
                                               &\updReg{r_2}{c_2}
                                   \end{array} \right)\right.
&
                                 \sourcecolor\left.
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_3) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                   \perm \neq \enter \\
                                   \Phi(r_4) = n \tor r_4 = n \\
                                   \quad\text{ and in either case } n \in \nats \\
                                   \baddr \leq n \tand n < \eaddr \tand \\
                                   c_1 = \stkptr{\perm,\baddr,n,\aaddr} \tand \\
                                   c_2 = \stkptr{\perm,n+1,\eaddr,\aaddr} 
                                 \end{array} \right.\\
                                 \failed & \totherwise
                               \end{cases}
\end{align*}

\lau{19-09-2017: Two important points about $\tsplice{}{}{}$ related to the calling convention: (1) Splice fails if two capabilities are not adjacent. This means that if a caller tries to use a return pointer with a stack that is not immediately adjacent to the private stack, then it fails. (2) Splice prohibit splicing with an empty capability! This means that a callee cannot return an empty stack (this also means that it is impossible to make a call when all of the stack is used - this may indeed be undesirable, but without this restriction we need to handle other things).}
\lau{19-09-2017: Because $\tsplice{}{}{}$ does not allow empty stacks, it is not ``left inverse'' to $\tsplit{}{}{}{}$ (because of the empty case). Intuitively, it is weird that a $\tsplit{}{}{}{}$ followed by a $\tsplice{}{}{}$ does not yeild the same capability.}
\begin{align*}
  \sem{\tsplice{r_1}{r_2}{r_3}} = &
                              \begin{cases}
                                \updPcAddr{}\left(
                                \arraycolsep=0pt
                                \begin{array}{r l}
                                  \Phi&\updReg{r_2}{w_2}\\
                                      &\updReg{r_3}{w_3}\\
                                      &\updReg{r_1}{c}
                                \end{array}\right)
&
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\lin),\baddr_2,\eaddr_2,\aaddr_2) \tand \\
                                  \Phi(r_3) = ((\perm,\lin),\baddr_3,\eaddr_3,\_) \tand \\
                                  \perm \neq \enter \tand \\
                                  \eaddr_2 + 1 = \baddr_3 \tand \baddr_2 \leq \eaddr_2 \tand \baddr_3 \leq \eaddr_3 \tand \\
                                  c = ((\perm,\lin),\baddr_2,\eaddr_3,\aaddr_2) \tand\\
                                  w_2 = \linCons{\Phi(r_2)} \tand \\
                                  w_3 = \linCons{\Phi(r_3)} \\
                                \end{array}\\
                                \updPcAddr{}\left(
                                \arraycolsep=0pt
                                \begin{array}{r l}
                                  \Phi&\updReg{r_2}{w_2}\\
                                      &\updReg{r_3}{w_3}\\
                                      &\updReg{r_1}{c}
                                \end{array}\right)
&
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = \seal{\lin,\sigma_{\baddr,2},\sigma_{\eaddr,2},\sigma} \tand \\
                                  \Phi(r_3) = \seal{\lin,\sigma_{\baddr,3},\sigma_{\eaddr,3},\_} \tand \\
                                  \sigma_{\eaddr,2}+1 = \sigma_{\baddr,3} \tand \sigma_{\baddr,2} \leq \sigma_{\eaddr,2} \tand\\
                                  \sigma_{\baddr,3} \leq \sigma_{\eaddr,3} \tand \\
                                  c = \seal{\lin,\sigma_{\baddr,2},\sigma_{\eaddr,3},\sigma} \tand \\
                                  w_2 = \linCons{\Phi(r_2)} \tand \\
                                  w_3 = \linCons{\Phi(r_3)} \\
                                \end{array}\\
                                \sourcecolor\left.
                                \updPcAddr{}\left(
                                \arraycolsep=0pt
                                \begin{array}{r l}
                                  \Phi&\updReg{r_2}{0}\\
                                      &\updReg{r_3}{0}\\
                                      &\updReg{r_1}{c}
                                \end{array}\right)\right.
&
                                \sourcecolor
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = \stkptr{\perm,\baddr_2,\eaddr_2,\aaddr_2} \tand \\
                                  \Phi(r_3) = \stkptr{\perm,\baddr_3,\eaddr_3,\aaddr_3} \tand \\
                                  \perm \neq \enter \tand \\
                                  \eaddr_2 + 1 = \baddr_3 \tand \baddr_2 \leq \eaddr_2 \tand \baddr_3 \leq \eaddr_3 \tand \\
                                  c = \stkptr{\perm,\baddr_2,\eaddr_3,\aaddr_2} \\
                                \end{array}\\
                                \failed & \totherwise
                              \end{cases}
\end{align*}

\noindent\textbf{call}\\
\lau{19-09-2017: How do we get the $\sigma_?$ for the return pointers? It should be in memory somewhere.}
\lau{19-09-2017: In which cases do we have undefined here?}
\begin{align*}
  \sem{\scall{\src{r_1}}{\src{r_2}}}(\Phi) = & 
                                               \begin{cases}
                                                 \Phi'
                                                 \arraycolsep=0pt
                                                 \begin{array}[t]{rl}
                                                   &\updReg{r_1}{w_1} \\
                                                        &\updReg{r_2}{w_2} \\
                                                        &\updReg{\pcreg}{c_1}\\
                                                        &\updReg{\rdata}{c_2}\\
                                                        &\updReg{\rstk}{c_\stk}\\
                                                        &\updReg{r_{\var{ret,c}}}{\retptrc(\sigma_?)}\\
                                                        &\updReg{r_{\var{ret,d}}}{\retptrd(\sigma_?)}
                                                 \end{array}
                                                 & 
                                                 \arraycolsep=0pt
                                                 \begin{array}[t]{l}
                                                   \Phi(r_1) = \sealed{c_1,\sigma_1} \tand \\
                                                   \Phi(r_2) = \sealed{c_2,\sigma_1} \tand \\
                                                   \sigma_1 = \sigma_2 \tand \\
                                                   \nonExec{c_2} \tand\\
                                                   \Phi(\rstk) = \stkptr{\rw,\baddr_\stk,\eaddr_\stk,\aaddr_\stk} \tand \\
                                                   \Phi = (\mem,\reg,\stk,\ms_\stk) \tand\\
                                                   \baddr_\stk \leq \aaddr_\stk \leq \eaddr_\stk \tand \\
                                                   \dom(\ms_\stk) = [\baddr_\stk,\eaddr_\stk] \tand\\
                                                   \ms_{\stk,\priv} = \ms_\stk |_{[\baddr_\stk,\aaddr_\stk]}\update{\aaddr_\stk}{\eaddr_\stk} \tand\\
                                                   \ms_{\stk,\var{rest}} = \ms_\stk|_{[\aaddr_\stk + 1,\eaddr_\stk]} \tand\\
                                                   \Phi(\pcreg) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                                   \opc = ((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen) \tand \\
                                                   c_\stk = \stkptr{\aaddr_\stk+1,\eaddr_\stk,\aaddr_\stk+1} \tand \\
                                                   \stk' = (\opc,\ms_{\stk,\priv},\aaddr_\stk)\tand\\
                                                   \Phi' = (\mem,\reg,\stk',\ms_{\stk,\var{rest}})\tand\\
                                                   w_1 = \linCons{\Phi(r_1)} \tand \\
                                                   w_2 = \linCons{\Phi(r_2)}
                                                 \end{array}
                                               \end{cases}
\end{align*}


\subsection{Program layout and linking}
A target-level program needs a number of things available in order to be able to execute securely. In the following, we list what it needs followed by a description of how they are made available.

A program needs access to the following:
\begin{description}
\item[Code] The instructions of a program should of course be available so they can be executed.
\item[Program seals] Each call/return point of the program needs a unique seal in order to enforce well-bracketedness. This seal needs to be unique on the entire machine.
\item[Stack] A program stores the value of local variables on the stack. 
\item[Persistent data storage] A program may also need to use "global variables" these are stored in a piece of memory seperate from the stack.
\item[Linking table] A progam may need to call other programs. Other programs are made available in a linking table.
\end{description}

In the following, we describe the setup in detail. Figure~\ref{fig:trg-prog-link} illustrates the setup.

The \emph{code}, \emph{program seals}, and \emph{linking table} are available through a normal read-execute capability in the $\pc$ register. The program seals are found on the first address governed by this capability. The second address governe by the capability contains a normal read capability that governs the linking table and points to the first address. The remaining addresses governed by the capability in the $\pc$ register contain the instructions of the program.

The \emph{linking table} contains pairs of sealed code and data capabilities. So the first two addresses of the linking table contains the first pair, the two next contains the next pair and so on.

The \emph{program seals} contain at least a seal for each of the ``call/return points'' in the program.\lau{it is not clear what this means for a target level program that does not contain the call instruction.} The seals are globally unique in the sense that no other program has access to this range of seals.

The \emph{stack} is available through a capability in the register $r_\stk$. The stack pointer is a linear read write capability. There are three ways of receiving a stack: (1) the first program executing has a stack pointer in the $r_\stk$ register, (2) call backs and programs can expect to be called with a stack pointer as an argument in the $r_\stk$ register, and (3) when returning from a call, part of the stack is unsealed as the data part of a return pointer the other part is returned from the callee (the callee is allowed to keep part of the stack, but the callee must at least return a non-empty part of the stack adjacent to the part of the stack that was unsealed by returning).

The \emph{peristent data storage} is expected to be accisble through a normal read-write capability in $r_\data$ during normal execution (during a return the stack capability will initially be in the $r_\data$ register, but it should be spliced with the returned stack and moved to the $r_\stk$ register). There are two ways for a program to get this data capability: (1) the data part of the code/data part should be the sealed data capability. (2) During a call, the data capability should be stored on the stack, so it can be retrieved afterwards.
\begin{figure}
  \centering
  \includegraphics[angle=90,width=\textwidth]{img/linking.pdf}
  \caption{Linking and program layout.}
  \label{fig:trg-prog-link}
\end{figure}

\subsection{Compiler}
\[
\comp{\cdot} : \src{i}^* \fun \trg{i}^*
\]

\[
  \comp{\scall{r_1}{r_2}} = 
  \begin{array}[t]{l}
    % Make the stack capability into the return capability and seal it:
    %   Push r_data to the stack (should this be made the responsibility of the programmer? If it happens here, then it should probably also be part of the call semantics. Especially, the call semantics should "eat" another piece of memory on the stack to make sure there is no discrepancy.)
    %   Seal the stack capability (with what? where does the seal come from? I think we talked about this, and it is something that should be handled like linking (a fresh seal is available in the beginning of a programs code along with a capability for a linking table)).
    % restrict the stack capability to the unused part (and clear this part).
    % make return capability and ceal it:
    %   Move a copy of pc to a different register.
    %   Adjust the pc copy to point to the return address.
    %   Seal it with the seal.
    % remove all data from temp registers (that is at least the seal).
    % jmpx to r1 and r2
    % restore code:
    %   move the stack pointer to the proper register
    %   pop the data capability
  \end{array}
\]

\clearpage
\section{Examples}
\subsection{Capability Opacity}
\label{subsec:capability-opacity}
This example was introduced when we envisioned a capability machine with $\spush{}$, $\spop{}$, $\ssload{}{}$, $\scall{}{}$ and $\sreturn$ instructions. The below example is a motivation for having variable length instructions in the source language because if we have enough memory to ``do the same'' in the target language as in the source language, then the below example does not work.

The following pseudo program demonstrates the need of opaque capabilities. If we assume a system with no opaque capabilities, then the following programs break compiler correctness
\begin{lstlisting}[basicstyle=\sourcecolor{}\ttfamily] 
p1 ::= if r1 is length 2 then
         call r1 with the following callback in r5:
           {put $\textit{\texttt{diverging}}$ closure in r2;
            return};
         halt
       else diverge

p2 ::= if r1 is length 2 then
         call r1 with the following callback in r5:
           {put $\textit{\texttt{terminating}}$ closure in r2;
            return};
         halt
       else diverge
\end{lstlisting}
The diverging closure could just contain $\sjmp{\pcreg}$, which diverges. The terminating closure could just be $\sreturn$.

The context with $r1$ as an executable capability pointing to:
\begin{lstlisting}[basicstyle=\sourcecolor{}\ttfamily] 
$\scall{r5}{0}$
$\sjmp{r5}$
\end{lstlisting}
\footnote{At this time $\scall{}{}$ did argument spilling and it only takes one argument because we were considering enter capabilities.}distinguishes the two contexts, but two instructions are not enough to do the same at the target level. We would not have enough instructions to set up a proper return pointer for the compiled return to use.

\clearpage
\section{Back translation}
The back translation is an embedding of source language into .

\section{Notes}
\subsection{Leuven stay conclusions}
\begin{enumerate}
\item Enter capabilities replaces by sealed code/data pairs \label{item:first-point}
  \begin{itemize}
  \item To allow us to forbid dynamic code generation
  \end{itemize}
\item Conditional full-abstraction
  \begin{itemize}
  \item No undefined behaviour by \emph{trusted code} in any context implies full-abstraction. (Blame idea: undefined as undef of current pc, so current pc can be checked for whether it was the trusted code).
  \item Avoids dynamic checks to protect trusted code against itself.
  \item Possible due to point \ref{item:first-point}.
  \end{itemize}
\item replace push/pull/call/ret/sload by symbolic return pointer (pair) and stack pointer.
  \begin{itemize}
  \item Allows backtranslation to be embedding into source language.
    \begin{itemize}
    \item Interpreter for backtranslation is not able to accurately replicate code length.
    \end{itemize}
  \end{itemize}
\item Worlds similar to CSF paper, but invariants on seals as well.
  \begin{itemize}
  \item Invariants says what can be sealed with a certain seals.
  \end{itemize}
\item Linker: resolves symbols
  \begin{itemize}
  \item Export refs (Question: do we allow other things than sealed code/data pairs to be exported?)
  \item Import refs
  \item Fresh seal requirement
  \end{itemize}
\item Components are memory segments and symbols.
\item Variable instruction length in the source to avoid leaking information through code size that cannot be matched after compilation (breaks compiler correctness, se example in subsection~\ref{subsec:capability-opacity}).
  \begin{itemize}
  \item Notice x86 allows instructions of up to infinite length, so this is not weird.
  \end{itemize}
\item Have opaque capabilities.
  \begin{itemize}
  \item Without opaque capabilities, stack consumption could be inferred through stack pointer index etc.
  \end{itemize}
\item Considered PORs for transition systems to: ($a \rightarrow b \Rightarrow a = a \text{ and } b = b$)
  \begin{itemize}
  \item Define one region that governs the stack
  \item Make the regions more general
  \item For now, we have not done this: instead we stick with the transition systems we have and have to regions governing the stack reflecting the CSF work.
  \end{itemize}
\end{enumerate}

\subsection{Some explanation}
\subsubsection{The source language}
The whole idea of this paper is to show that we enforce well-bracketed control flow correctly by taking a source language with a native stack and native call and return instructions and well-bracketedness enforced by the operational semantics.
We then prove that we can compile this source language to a regular assembly target language (without a native stack) in a fully abstract way using our stack and return pointer discipline.
So the design goals for our source language were precisely these: it should be an intermediate language that stays as close as possible to our target language, can be fully abstractly compiled to the target and feature a native well-behaved stack.
This source language can then be used as the second-to-last language in the compilation chain of a fully abstract compiler.
By compiling in a fully abstract way to our source language and then composing with our compiler, fully abstract compilation to our target language follows easily.

These design goals drove us to the current definition of our source language and some special design choices.
Particularly, contrary to what one might expect in a language with a native stack, we do not use call/return and push/pop instructions.
The reason is that we are working in a language where the length of code blocks can be observable.
Imagine two trusted blocks of code that looks as follows:
\begin{lstlisting}[basicstyle=\sourcecolor{}\ttfamily] 
p1:       <assert that r1 contains an executable capability to a block of 
           instr_length (push) + instr_length(jmp)>
          <load return capability to p1-ret1 in r2>
          <load value 0 in r3>
          <jump to r1>
p1-ret1:  <assert that 0 is loaded in the next free stack position>
          <repeat the above with value 1 in r3>
          ...
p1-ret2:  <assert that 1 is loaded in the next free stack position>
          <repeat the above with value 2 in r3>
          ...
p1-ret3:  <assert that 2 is loaded in the next free stack position>
          halt

p2:       <assert that r1 contains an executable capability to a block of 
           instr_length (push) + instr_length(jmp)>
          <load return capability to p2-ret1 in r2>
          <load value 1 in r3>
          <jump to r1>
p2-ret1:  <assert that 1 is loaded in the next free stack position>
          <repeat the above with value 2 in r3>
          ...
p2-ret2:  <assert that 2 is loaded in the next free stack position>
          halt
\end{lstlisting}

p1 and p2 each accept an (unprotected) closure from the context whose lenght is restricted.
Together with the checks performed by p1 and p2, there is only one possible implementation of the closure that will not fail, namely
\begin{lstlisting}[basicstyle=\sourcecolor{}\ttfamily] 
closure: push r3
         jmp r2
\end{lstlisting}

However, this is no longer true in the target language.
Assume that $\mathtt{push r3}$ is implemented as a store to $\rstk$ followed by an increment of $\rstk$.
The adversary can now construct a closure that does not use the standard implementation of push, but instead does this:
\begin{lstlisting}[basicstyle=\targetcolor{}\ttfamily] 
evil-closure: jnz r3 r2
              store $\rstk$ r3
              jmp r2
\end{lstlisting}
If we now assume that the instructions in evil-closure (jnz+store+jmp) are the same length as the original closure(store+increment+jmp), then the adversary can now construct a closure that discriminates $\mathtt{p1}$ and $\mathtt{p2}$ above.
The essential point here is that an assumption in the source language that relies on facts about instruction length (``a closure restricted to the instruction-size of push+ret that modifies the stack and returns can only be implemented in one way'') is no longer valid, because there are now more low-level ways of interacting with the stack.

To remedy this, we decided to modify our source language to use a different way of interacting with the stack.
This alternative approach stays even closer to the target language.
The problem is not actually that we shouldn't offer push/pop and call/return instructions, but rather that our language should also offer an equivalent for the more low-level interactions with the stack that are possible in the target language.
As such, we introduce special token values that play the role of the stack pointer/return pointer and we allow all interactions with them that are possible using instructions like \sstore{}{}, \smove{}{} etc.
Specifically, as shown in \cref{sec:domains}, there are new token capabilities $\stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}$, $\retptrd$ and $\retptrc$ which represent a copy of the stack pointer, and the code and data parts of the sealed return closure.
Rather than invoking \spush{} or \spop{}, one can store into the $\stkptr{}$ and modify its current address and as we can see in \cref{sec:source-language}, this has the semantic effect that one would expect.
Similarly, rather than invoking \sreturn{}, one would ccall the $\retptrd$ and $\retptrc$ sealed code/data pair.

We do not offer primitive \sreturn{}, \spush{} and \spop{} instructions, even though there is nothing keeping us from doing that, either as an additional primitive instruction or as a macro on top of the primitive token values mentioned above.
We do offer a primitive \scall{}{} instruction, and it offers the only way to create a new stack frame.
It is the only instruction that does not have a target language counterpart.
However, there is a counterpart to \sxjmp{}{}, the instruction that would be used for jumping in the code that \scall{}{} compiles to.
We will discuss later that this means that if we backtranslate an adversary piece of code (in the full abstraction proof), then it will be backtranslated (under our trivial back-translation) to equivalent code that \emph{never} does an actual call, but always just jumps to where it wants to go.
In other words, the back-translated code never uses call to protect its own stack frame from the code that it passes control to.
This means that the back-translated code is quite insecure, but we don't need it to be: it just needs to be behaviorally equivalent to the target language code that it represents.

% Finally, rather than invoking call, \dominique{7-9-2017: err, what's the reason we don't follow the same pattern for call?}.
% \lau{07-09-2017: One would use $\scall{}{}$ with a pair of sealed capabilities to securely jump to this pair - that is to have this pair executed in a new stack frame. The return would happen just by using $\sxjmp{}{}$ with the $\retptrd$ and $\retptrc$. However, this would work with the local capabilities as the real implementation of $\retptrd$ would be a sealed version of the entire stack pointer. In other words, upon jumping back no extra work would have to be done. Now, however, the old stack pointer should be spliced (using the new $\ssplice{}{}$ instruction) with the stack pointer we sent away in order to regain the old stack pointer. In other words, we need something to recognise when a return happens.}
% \lau{07-09-2017: On second thought, when compiled all the code necessary for the call will be generated based on the $\scall{}{}$ instruction. The real implementation of the $\retptrc$ will simply point to a piece of clean up code that splices together the old/private stack pointer with the one we got from the untrusted party. This may, however, give some issues when we want to reason about it because there will be a disconnect between where the clean up job is done in the operational semantics of the source language (namely as part of the $\sxjmp{}{}$), but in a translated program, the code that does the clean up origins with the $\scall{}{}$ instruction. }

Note that the token values representing the stack and return pointer in our source language are essentially just a weird alternative syntax for something we would otherwise write using call/return and push/pop.
However, it does remove the problem described above of relying on facts that follow from code length, because we can now write exactly the same code in source and target and it will do exactly the same thing if it is well-behaved.
The code would look exactly the same in source and target, it would just be working with token values in the source versus real stack and return pointers in the target.
That the problem is really gone should follow from being able to write a full-abstraction proof.
However, our approach should also simplify that proof.
The reason is that back-translating should become essentially trivial: rather than performing some form of emulation or a real back-translation (which would inevitably make code size larger), it should be sufficient to just use unmodified target instructions as source instructions that will just be working with different types of values.


\subsubsection{Conditional full abstraction}
\label{sec:conditional-full-abstraction}

Another novelty in this work is the fact that we do not want to prove general full abstraction (i.e. two source programs are behaviorally equivalent if and only if they are compiled to behaviorally equivalent target programs).
The reason is that we only want to prove a result about programs that respect the calling convention, i.e.\ that do not do anything stupid.
For example, in the old setup with global/local capabilities, when trusted code performs an \scall{}{}, it should make sure that it does not store a copy of its stack pointer in a place that is accessible to the callee (e.g.\ in a register or in the callee's part of the stack).
Such sanity conditions are necessary (we cannot guarantee anything for code that does such stupid things) but we do not want to spend computation time on checking them.
Instead, we expect a reasonable compiler to guarantee in some way that its generated code never does such stupid things and then our guarantees should apply.

Note that in the new setup with linear capabilities instead of local/global ones, there seems to be less opportunity for the trusted code to do stupid things, so it may be that we no lnoger need these sanity conditions, but this is not clear yet.

Assuming that we need sanity conditions on the source code, the question is how we formulate them in our full abstraction.
Our idea is to formulate a notion of conditional full abstraction: ``if source programs t1 and t2 never perform stupid things under any possible source interaction, then they are source-equivalent iff their compilations are target-equivalent.''.
However, the question remains how we formalise the condition ``if source programs t1 and t2 never perform stupid things under any possible source interaction''.

Two possible approaches:
\begin{itemize}
\item \emph{Blame}: the idea here would be that we introduce a notion of ``undefined behavior'' in the operational semantics.
  ``Doing stupid things'' like leaving copies of the stack pointer around on a call, would cause the system to enter an undefined state.
  We would then like to express the above mentioned sanity condition as ``t1 and t2 never evaluate to undefined when plugged into an arbitrary program context''.
  However, that doesn't work, because it does not discriminate between undefined behavior caused by t1 or t2 (on the one hand) and the program context (on the other hand).
  To remedy this, we intended to use a notion of blame assignment: the undefined state would contain the address of the pc that was active at the moment it went wrong.
  We would then express the above mentioned sanity condition as ``t1 and t2 never evaluate to undefined(pc) where pc is within the trusted code's assigned code memory when plugged into an arbitrary program context''.

  The problem with this approach is that it does not combine well with dynamically generated code (solution: exclude code-generation?) and that it adds a lot of complexity.

\item \emph{A logical relation}: An alternative approach (suggested by Lars to Lau) might be to define a logical relation to express the sanity condition ``t1 and t2 never evaluate to undefined when plugged into an arbitrary program context''.
  This remains to be thought through in more detail, but it might be simpler and/or be easier to combine with dynamic code generation.
\end{itemize}

\subsection{Linear Capabilities}
\label{sec:linear-cap}
The idea with linear capabilities is to limit aliasing of a capability. We specifically wanted a linear capability for the stack pointer, to not have to erase large pieces of memory, which we have to when we use local capabilities. With linear capabilities, we would just need to find the one linear capability to be sure we have the only capability under our control.

There are multiple ways that linear capabilities could work (we choose the third one):
\begin{enumerate}
\item A linear capability comes with a system wide guarantee that no \emph{linear} alias exists for this capability (or any part of the memory it has authority over). In other words, the linear capability is the only \emph{linear} capability for this piece of memory.  However, non-linear aliases may exist.

In order for this to work, the memory must initially be partitioned into two parts. One controlled by a non-linear capability and one controled by a linear capability. The semantics of the machine would now have to make sure that the linear capability is never aliased. For instance, moving a linear capability from one register would cause the source register to be cleared (similar to destructive reads in the ownership types literature). 

In this scheme, it would be okay to permit linear capabilities to become non-linear (which would consume the linear capability). The reasoning would be that it is okay to remove the aliasing restriction and thus make the part of memory with the no-aliasing guarantee smaller. If some program depends on a certain capability received from an adversary to be linear, then they would simple have to check whether it is in fact linear. As the linear capability is consumed when making it non-linear, it would have no way to regain the linear capability.

\item A linear capability can be created from a non-linear capability. The linear capability has no guarantee that it is not aliased, but no aliases can be made from the linear capability. The linear capability can now be passed to an adversary and if the adversary gives back the linear capability when they return, then we know that they have no alias for it (provided we did not give them one and they did not have one in the first place), because the linear capability does not permit them to create an alias.

In this scheme, the system would initially have one non-linear capability for all of the memory. The linear capabilities would then be generated as they are needed.
\item A linear capability is ``born'' with the guarantee that it is not aliased, either by linear or non-linear capabilities. This guarantee is maintained by the semantics. Linear capabilties cannot be converted to another kind of capability (in other words, this is option one but where linear capabilities cannot be made non-linear).

Note that in this scheme, it would be good if malloc provided a way to initially obtain a linear capability in this model.
Otherwise, there would never be any linear capabilities other than stack pointers, which seems a waste.
\end{enumerate}
Notice that the two first schemes are incompatible as they would undermine eachother.

We chose to use the second scheme for the following reasons:
\begin{itemize}
\item While the stack pointer was the motivation for the linear capabilities, we believe they can also be used for other things such as return pointers. When used for return pointers, we know that the return pointer used to return to us was the only one available. However, if we used the first scheme, then all of the code would have to be in the linear part of memory. This would be undesirable if we want to provide several entities access to the same program. 
\end{itemize}
We later abandoned the second option for the following reason:
\begin{itemize}
\item The initial idea with linear capabilities was to use them for stack pointers, because there would only ever be one capability for a any part of the stack. However, when normal capabilities can become linear, then it is only the creator of the linear capability that can be sure that no alias is created from the linear capability. Someone who receives a linear capability would not be able to trust the linear capability as it might have come about as a normal capability that has been aliased and later turned linear.

In other words, we needed a system-wide guarantee to be able to put some trust in linear capabilities from an untrusted source.
\end{itemize}

\subsubsection{Write-linear capabilities}

At the time is writing, it is unclear whether write-linear (in the style of write-local permission\footnote{Here it would mean that linear capabilities can only be written through capabilities with write-linear permission and all capabilities with write-linear permission must themselves be linear.}) is necessary. One might think that it is necessary to prevent ``indirect aliasing'', which here would mean that a linear capability would be stored in a piece of memory for which there are multiple non-linear capabilities. This does, however, not seem to be a problem as the aliasing invariants are never broken. The memory the linear capability governs is still not aliased and if anyone needs to use the capability, they would have to load it to a register which would remove it from memory.

One thing write-linear capabilities may be useful for is to make sure that return capabilities are used in the correct order, i.e., ensuring well-bracketedness. 
\lau{08-09-2017: I have not thought the above completely through} 
\lau{13-09-2017: Dominique wrote something about this in an e-mail. The splicing necessary for each call would be what is needed to make the write-linear obsolete. The splicing would fail in the cases where someone try to use the wrong data-capability. Further something like write-linear would have the same issue as write-local. We would rely on the fact that the write-linear permission limits the space where we might need to look for linear capabilties. In order to remove the desired linear capability, we would still need to search through all the places it could be which would be infeasible (like the clear memory segment instruction).}

We have also considered removing local capabilities as these no longer seem necessary and only add complexity. However, they may be relevant to ensure the well-bracketed control flow (this will need further consideration).

\dominique{14-9-2017: Currently, we have removed local capabilities and we believe write-linear will (a) not work (because it would require memory clearing like write-local) and (b) not be needed (because of the splicing discussed above).}


\subsection{Opaque capabilities}
At some point, we contemplated having opaque capabilities. Opaque capabilities would hide the addresses of the capability, i.e, a getter on the base, end or address would yield nothing. It would still be possible to manipulate opaque capabilities. To this end, it would be necessary to have operations that work relatively to the capabilities addresses. These could be: 
\begin{enumerate}
\item reset current address of capability to its base address
\item return difference between current address and base address of a capability
\item increase/decrease current address of a capability by a set amount
\end{enumerate}
(Linear capabilities may still call for some of these to be added for practical purposes. (like when the executing capability is linear, then it cannot be moved from the pc register).)

At the moment of writing this, I am not sure why we introduced them, but it was related to hiding program lengths (and stack height).
At this juncture, it does, however, not seem necessary to have opaque because sealed capabilities can do their job.

\end{document}