\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}

% Math packages
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{array}
\usepackage{cleveref}
\usepackage{stmaryrd}

% Command control packages
\usepackage{ifthen}
\usepackage{ifpdf}

% Listings
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  mathescape
}

% Tikz
\usepackage{tikz}

%%% Comments
% Comments
\newcommand\lau[1]{{\color{purple} \sf \footnotesize {LS: #1}}\\}
\newcommand\dominique[1]{{\color{purple} \sf \footnotesize {DD: #1}}\\}
\newcommand\lars[1]{{\color{purple} \sf \footnotesize {LB: #1}}\\}


%%% Math notation
\newcommand{\defeq}{\stackrel{\textit{\tiny{def}}}{=}}
\newcommand{\defbnf}{::=}
\newcommand{\sem}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\ssem}[2][\Phi]{\sem{#2}_{\mathrm{src}}(#1)}
\newcommand{\tsem}[2][\Phi]{\sem{#2}_{\mathrm{trg}}(#1)}
\newcommand{\dom}{\mathrm{dom}}

% Function arrows
\newcommand{\fun}{\rightarrow}
\newcommand{\parfun}{\rightharpoonup}

% Text
\newcommand{\tand}{\text{ and }}
\newcommand{\totherwise}{\text{otherwise }}


%%% Instruction formatting
\newcommand{\sourcecolortext}{blue}
\newcommand{\sourcecolor}[1]{\color{blue}}
\newcommand{\src}[1]{{\sourcecolor{} #1}}
\newcommand{\targetcolortext}{black}
\newcommand{\targetcolor}[1]{\color{black}}
\newcommand{\trg}[1]{{\targetcolor{} #1}}

\newcommand{\zinstr}[1]{#1}
\newcommand{\oneinstr}[2]{
  \ifthenelse{\equal{#2}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2}
}
\newcommand{\twoinstr}[3]{
  \ifthenelse{\equal{#2#3}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3}
}
\newcommand{\threeinstr}[4]{
  \ifthenelse{\equal{#2#3#4}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3 \; #4}
}

\newcommand{\fourinstr}[5]{
  \ifthenelse{\equal{#2#3#4#5}{}}
  {\zinstr{#1}}
  {\zinstr{#1} \; #2 \; #3 \; #4 \; #5}
}


%%% Source language
% No arguments
\newcommand{\sfail}{\zinstr{\src{fail}}}
\newcommand{\shalt}{\zinstr{\src{halt}}}
\newcommand{\sreturn}{\zinstr{\src{return}}}

% One argument
\newcommand{\sjmp}[1]{\oneinstr{\src{jmp}}{#1}}
\newcommand{\spush}[1]{\oneinstr{\src{push}}{#1}}
\newcommand{\spop}[1]{\oneinstr{\src{pop}}{#1}}

% Two arguments
\newcommand{\sjnz}[2]{\twoinstr{\src{jnz}}{#1}{#2}}
\newcommand{\sisptr}[2]{\twoinstr{\src{gettype}}{#1}{#2}}
\newcommand{\sgeta}[2]{\twoinstr{\src{geta}}{#1}{#2}}
\newcommand{\sgetb}[2]{\twoinstr{\src{getb}}{#1}{#2}}
\newcommand{\sgete}[2]{\twoinstr{\src{gete}}{#1}{#2}}
\newcommand{\sgetp}[2]{\twoinstr{\src{getp}}{#1}{#2}}
%\newcommand{\sgetloc}[2]{\twoinstr{\src{getloc}}{#1}{#2}}
\newcommand{\sgetlin}[2]{\twoinstr{\src{get}}{#1}{#2}}
\newcommand{\smove}[2]{\twoinstr{\src{move}}{#1}{#2}}
\newcommand{\sstore}[2]{\twoinstr{\src{store}}{#1}{#2}}
\newcommand{\sload}[2]{\twoinstr{\src{load}}{#1}{#2}}
\newcommand{\slea}[2]{\twoinstr{\src{lea}}{#1}{#2}}
\newcommand{\ssload}[2]{\twoinstr{\src{sload}}{#1}{#2}}
\newcommand{\scall}[2]{\twoinstr{\src{call}}{#1}{#2}}
\newcommand{\sxjmp}[2]{\twoinstr{\trg{xjmp}}{#1}{#2}}
\newcommand{\ssetatob}[2]{\twoinstr{\src{seta2b}}{#1}{#2}}
\newcommand{\ssplice}[2]{\twoinstr{\src{splice}}{#1}{#2}}
\newcommand{\ssplit}[2]{\twoinstr{\src{split}}{#1}{#2}}

% Three arguments
\newcommand{\srestrict}[3]{\threeinstr{\src{restrict}}{#1}{#2}{#3}}
\newcommand{\slt}[3]{\threeinstr{\src{lt}}{#1}{#2}{#3}}
\newcommand{\splus}[3]{\threeinstr{\src{plus}}{#1}{#2}{#3}}
\newcommand{\sminus}[3]{\threeinstr{\src{minus}}{#1}{#2}{#3}}
\newcommand{\scseal}[3]{\threeinstr{\src{cseal}}{#1}{#2}{#3}}

% Four arguments
\newcommand{\ssubseg}[4]{\fourinstr{\src{subseg}}{#1}{#2}{#3}{#4}}

%%% Target language
% No arguments
\newcommand{\tfail}{\zinstr{\trg{fail}}}
\newcommand{\thalt}{\zinstr{\trg{halt}}}

% One argument
\newcommand{\tjmp}[1]{\oneinstr{\trg{jmp}}{#1}}

% Two arguments
\newcommand{\tjnz}[2]{\twoinstr{\trg{jnz}}{#1}{#2}}
\newcommand{\tisptr}[2]{\twoinstr{\trg{gettype}}{#1}{#2}}
\newcommand{\tgeta}[2]{\twoinstr{\trg{geta}}{#1}{#2}}
\newcommand{\tgetb}[2]{\twoinstr{\trg{getb}}{#1}{#2}}
\newcommand{\tgete}[2]{\twoinstr{\trg{gete}}{#1}{#2}}
\newcommand{\tgetp}[2]{\twoinstr{\trg{getp}}{#1}{#2}}
%\newcommand{\tgetloc}[2]{\twoinstr{\trg{getloc}}{#1}{#2}}
\newcommand{\tgetlin}[2]{\twoinstr{\trg{getl}}{#1}{#2}}
\newcommand{\tmove}[2]{\twoinstr{\trg{move}}{#1}{#2}}
\newcommand{\tstore}[2]{\twoinstr{\trg{store}}{#1}{#2}}
\newcommand{\tload}[2]{\twoinstr{\trg{load}}{#1}{#2}}
\newcommand{\tlea}[2]{\twoinstr{\trg{lea}}{#1}{#2}}
\newcommand{\txjmp}[2]{\twoinstr{\trg{xjmp}}{#1}{#2}}
\newcommand{\tsetatob}[2]{\twoinstr{\trg{seta2b}}{#1}{#2}}
\newcommand{\tsplice}[2]{\twoinstr{\trg{splice}}{#1}{#2}}
\newcommand{\tsplit}[2]{\twoinstr{\trg{split}}{#1}{#2}}

% Three arguments
\newcommand{\trestrict}[3]{\threeinstr{\trg{restrict}}{#1}{#2}{#3}}
\newcommand{\tlt}[3]{\threeinstr{\trg{lt}}{#1}{#2}{#3}}
\newcommand{\tplus}[3]{\threeinstr{\trg{plus}}{#1}{#2}{#3}}
\newcommand{\tminus}[3]{\threeinstr{\trg{minus}}{#1}{#2}{#3}}
\newcommand{\tcseal}[3]{\threeinstr{\trg{cseal}}{#1}{#2}{#3}}



% Four arguments
\newcommand{\tsubseg}[4]{\fourinstr{\trg{subseg}}{#1}{#2}{#3}{#4}}


%%% Domains
\newcommand{\plaindom}[1]{\mathrm{#1}}

\newcommand{\nats}{\mathbb{N}}
\newcommand{\ints}{\mathbb{Z}}

%%% Updates
\newcommand{\update}[2]{[#1 \mapsto #2]}
\newcommand{\updReg}[2]{\update{\reg.#1}{#2}}
\newcommand{\updPc}[1]{\Phi\updReg{\pcreg}{#1}}

%%% Source dom
\newcommand{\shareddom}[1]{\mathrm{#1}}
\newcommand{\RegName}{\shareddom{RegisterName}}
\newcommand{\Addr}{\shareddom{Addr}}
\newcommand{\Seal}{\shareddom{Seal}}
\newcommand{\Perm}{\shareddom{Perm}}
\newcommand{\Caps}{\shareddom{Cap}}
\newcommand{\SealableCaps}{\shareddom{SealableCap}}
\newcommand{\Word}{\shareddom{Word}}
\newcommand{\Mem}{\shareddom{Memory}}
\newcommand{\Reg}{\shareddom{RegisterFile}}
\newcommand{\Stk}{\shareddom{Stack}}
\newcommand{\Conf}{\shareddom{Conf}}
\newcommand{\ExecConf}{\shareddom{ExecConf}}
%\newcommand{\Global}{\shareddom{Global}}
\newcommand{\Linear}{\shareddom{Linear}}
\newcommand{\MemSeg}{\shareddom{MemorySegment}}
\newcommand{\StkFrame}{\shareddom{StackFrame}}
\newcommand{\Stack}{\shareddom{Stack}}

\newcommand{\scbnf}{\shareddom{sc}}
\newcommand{\cbnf}{\shareddom{c}}
\newcommand{\permbnf}{\shareddom{perm}}
\newcommand{\addrbnf}{\shareddom{a}}
\newcommand{\basebnf}{\shareddom{base}}
\newcommand{\aendbnf}{\shareddom{end}}
%\newcommand{\glbnf}{\shareddom{gl}}
\newcommand{\linbnf}{\shareddom{l}}
\newcommand{\sealbasebnf}{\sigma_\shareddom{base}}
\newcommand{\sealendbnf}{\sigma_\shareddom{end}}

\newcommand{\sstk}{\shareddom{stk}}
\newcommand{\smsstk}{\shareddom{ms_{stk}}}
\newcommand{\sstkframe}{\shareddom{frame}}
\newcommand{\sopc}{\shareddom{opc}}
\newcommand{\sastk}{\shareddom{a_{stk}}}
\newcommand{\perm}{\var{perm}}
%\newcommand{\gl}{\var{g}}
\newcommand{\lin}{\var{l}}
\newcommand{\base}{\shareddom{base}}
\newcommand{\aend}{\shareddom{end}}
\newcommand{\addr}{\shareddom{a}}
\newcommand{\scap}{\shareddom{c}}
\newcommand{\sms}{\shareddom{ms}}

\newcommand{\stkptr}[1]{\mathrm{stack\text{-}ptr}(#1)}
\newcommand{\retptr}{\mathrm{ret\text{-}ptr}}
\newcommand{\retptrd}{\mathrm{ret\text{-}ptr\text{-}data}}
\newcommand{\retptrc}{\mathrm{ret\text{-}ptr\text{-}code}}

\newcommand{\seal}[1]{\shareddom{seal}(#1)}
\newcommand{\sealed}[1]{\shareddom{sealed}(#1)}

\newcommand{\failed}{\mathrm{failed}}
% DOMI: defining a macro named ``undefined'' breaks many latex packages.
%       (this is just another way that LaTeX is broken as a programming language)
% \newcommand{\undefined}{\mathrm{undefined}}
\newcommand{\tundefined}{\mathrm{undefined}}
\newcommand{\halted}{\mathrm{halted}}

%%% Target domain
\newcommand{\targetdom}[1]{\mathrm{#1}}
\newcommand{\tRegName}{\targetdom{RegisterName}}

%%% Variables
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\rn}{\var{rn}}
\newcommand{\reg}{\var{reg}}
\newcommand{\mem}{\var{mem}}
\newcommand{\ms}{\var{ms}}
\newcommand{\pc}{\var{pc}}
\newcommand{\stk}{\var{stk}}
\newcommand{\ret}{\var{ret}}
\newcommand{\data}{\var{data}}
\newcommand{\priv}{\var{priv}}
\newcommand{\opc}{\var{opc}}
\newcommand{\odata}{\var{odata}}
\newcommand{\vsc}{\var{sc}}
\newcommand{\cb}{\var{cb}}
\newcommand{\baddr}{\var{b}}
\newcommand{\eaddr}{\var{e}}
\newcommand{\aaddr}{\var{a}}
\newcommand{\stdrng}{[\baddr,\eaddr]}

%%% Constants
\newcommand{\constant}[1]{\mathrm{#1}}
\newcommand{\calllen}{\constant{call\_len}}

%%% Named registers
\newcommand{\pcreg}{\mathrm{pc}}
\newcommand{\rstk}{\mathrm{r}_\mathrm{stk}}
\newcommand{\rO}{\mathrm{r}_\mathrm{ret}}
\newcommand{\rret}{\rO}
\newcommand{\rretc}{\mathrm{r}_\mathrm{ret code}}
\newcommand{\rretd}{\mathrm{r}_\mathrm{ret data}}
\newcommand{\rdata}{\mathrm{r}_\mathrm{data}}

%%% locality
%\newcommand{\plainlocality}[1]{\mathrm{#1}}
%\newcommand{\glob}{\plainlocality{global}}
%\newcommand{\local}{\plainlocality{local}}

%%% linearity
\newcommand{\plainlinearity}[1]{\mathrm{#1}}
\newcommand{\linear}{\plainlinearity{linear}}
\newcommand{\normal}{\plainlinearity{normal}}


%%% Permissions
\newcommand{\plainperm}[1]{\mathrm{#1}}
\newcommand{\rwlx}{\plainperm{rwlx}}
\newcommand{\rwx}{\plainperm{rwx}}
\newcommand{\rx}{\plainperm{rx}}
\newcommand{\rwlxo}{\plainperm{rwlxo}}
\newcommand{\rwlo}{\plainperm{rwlo}}
\newcommand{\rwl}{\plainperm{rwl}}
\newcommand{\rwxo}{\plainperm{rwxo}}
\newcommand{\rwo}{\plainperm{rwo}}
\newcommand{\rw}{\plainperm{rw}}
\newcommand{\rxo}{\plainperm{rxo}}
\newcommand{\ro}{\plainperm{ro}}
\newcommand{\readonly}{\plainperm{r}}
\newcommand{\noperm}{\plainperm{0}}
\newcommand{\nopermo}{\plainperm{0o}}
\newcommand{\enter}{\plainperm{e}}
\newcommand{\entero}{\plainperm{eo}}

%%% Braces
\newcommand{\comp}[1]{[#1]}

%%% Functions
\newcommand{\plainfun}[2]{
  \ifthenelse{\equal{#2}{}}
  {\mathit{#1}}
  {\mathit{#1}(#2)}
}

\newcommand{\encType}[1]{\plainfun{encodeType}{#1}}
\newcommand{\encPerm}[1]{\plainfun{encocePermission}{#1}}
\newcommand{\updPcAddr}[1]{\plainfun{updatePc}{#1}}
\newcommand{\updPcPerm}[1]{\plainfun{updatePcPerm}{#1}}
\newcommand{\nonExec}[1]{\plainfun{nonExecutable}{#1}}
\newcommand{\opaquePerm}[1]{\plainfun{opaquePerm}{#1}}
\newcommand{\readAllowed}[1]{\plainfun{readAllowed}{#1}}
\newcommand{\writeAllowed}[1]{\plainfun{writeAllowed}{#1}}
%\newcommand{\writeLocalAllowed}[1]{\plainfun{writeLocalAllowed}{#1}}
%\newcommand{\nonLoc}[1]{\plainfun{nonLocal}{#1}}
\newcommand{\nonLinear}[1]{\plainfun{nonLinear}{#1}}
%\newcommand{\isLoc}[1]{\plainfun{isLocal}{#1}}
\newcommand{\isLinear}[1]{\plainfun{isLinear}{#1}}
\newcommand{\noRetStkReg}[1]{\plainfun{noRetStk_{reg}}{#1}}
\newcommand{\noRetStkMs}[1]{\plainfun{noRetStk_{ms}}{#1}}
\newcommand{\withinBounds}[1]{\plainfun{withinBounds}{#1}}
\newcommand{\nonZero}[1]{\plainfun{nonZero}{#1}}


\begin{document}
\section{The two capability machines}
\subsection{Domains}
\label{sec:domains}

\dominique{7-9-2017: Should we keep local/global and linear/non-linear?  I was thinking just the latter would suffice...}
\lau{07-09-2017: The local/global mechanism still has some value as it now can be used for the purpose of arguments that cannot be stored by the receiver (if you are willing to ``pay'' the clearing cost). I do, however, not think that it is strictly necessary here to make things work.}
\lau{12-09-2017: I will remove the local capabilities today for the reasons we have discussed (they add to the complexity and they seem to be of little to no use without a clear memory instruction).}
Source language domains:
\[
  \begin{array}{rrcl}
   \addrbnf,\basebnf \in & \Addr & \defeq & \nats \\
    \sealbasebnf, \sigma \in & \Seal & \defeq & \nats \\
    &\Word & \defeq & \ints \uplus \SealableCaps\\
    \permbnf \in& \Perm & \defbnf & \dots \\
    &\linbnf & \defbnf & \linear \mid \normal \\
    &\aendbnf & \in & \Addr \uplus \{\infty \} \\
    &\sealendbnf & \in & \Seal \uplus \{\infty \} \\
    &\scbnf &\defbnf & ((\permbnf,\linbnf),\basebnf,\aendbnf,\addrbnf) \mid \seal{\linbnf,\sealbasebnf,\sealendbnf}\\
    & & & {\sourcecolor{} \mid \stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}}\\ 
    &\cbnf & \defbnf &  \scbnf \mid \sealed{\scbnf,\sigma}{\sourcecolor{} \; \mid \retptrd \mid \retptrc}\\ 
    &\RegName & \defbnf &\pcreg \mid \rret \mid \rstk \mid \rdata \mid \dots \\
    &\Reg & \defeq & \RegName \fun \Word\\
    &\Mem & \defeq & \Addr \fun \Word \\
    &\MemSeg & \defeq & \Addr \parfun \Word \\
    {\sourcecolor{} \sstkframe \in} & {\sourcecolor{} \StkFrame} & {\sourcecolor{} \defeq} & {\sourcecolor{} \Caps \times \MemSeg \times \Addr}\\
    \src{\sstk \in}& \src{ \Stack} & \src{ \defeq} & \src{ \StkFrame^*} \\
    \Phi \in & \ExecConf & \defeq & \Mem \times \Reg {\sourcecolor{} \; \times \; \Stack \times \MemSeg }\\
    &\Conf & \defeq & \ExecConf \uplus \{\failed\} \uplus (\{\halted\} \times \Mem)
  \end{array}
\]
\lau{06-09-2017: Should seals also have the option to be linear?}
\lau{13-09-2017: For now I have added linearity to the seals.}
The target language domains are all the non blue parts in the above. The source language domains are the black and blue parts in the above. Further
\begin{itemize}
\item $\linbnf$ defines domain $\Linear$
\item $\scbnf$ defines domain $\SealableCaps$
\item $\cbnf$ defines domain $\Caps$
\item $\Perm$ is defined as the set of permissions in Figure~\ref{fig:perm-hier}.
\end{itemize}

In the source language, $\src{\Stack}$ is a call stack that contains the data for each call. The call stack consists of a number of $\src{\StkFrame}$'s that contains 1) the old pc, 2) caller's private stack, and 3) the address of the old stack pointer.

More convenient definitions
\[
  \begin{array}{rcl}
    \Phi(r) & \defeq & \Phi.\reg(r)
  \end{array}
\]
where $r\in \RegName$.

\subsection{Syntax}
\label{sec:syntax}
The target machine is a simple capability machine with memory capabilities, local capabilities and sealed capabilities\footnote{In previous work, we used enter capabilities but for this the complexity introduced by mixing writable and executable memory is difficult to handle.} (inspired by CHERI). The syntax of the instructions of the target machine is defined as follows:
\[
\begin{array}{rcl}
n &\in & \nats \\
\trg{r} &\in &  \tRegName \\
\trg{\rn} &\defbnf &  \trg{r} \mid n \\
\trg{i} &\defbnf & \tfail \mid \thalt \mid \tjmp{\trg{r}} \mid \tjnz{\trg{r}}{\trg{\rn}} \mid \tisptr{\trg{r}}{\trg{r}} \mid \tgeta{\trg{r}}{\trg{r}} \mid \tgetb{\trg{r}}{\trg{r}} \mid \\
      & &  \tgete{\trg{r}}{\trg{r}}\mid \tgetp{\trg{r}}{\trg{r}} \mid \tgetlin{\trg{r}}{\trg{r}} \mid \tmove{\trg{r}}{\trg{\rn}} \mid \tstore{\trg{r}}{\trg{r}} \mid\\
      & &  \tload{\trg{r}}{\trg{r}} \mid \tlea{\trg{r}}{\trg{\rn}} \mid \trestrict{\trg{r}}{\trg{r}}{\trg{\rn}} \mid \tsubseg{\trg{r}}{\trg{r}}{\trg{\rn}}{\trg{\rn}} \mid \tlt{\trg{r}}{\trg{r}}{\trg{r}} \mid \\
      & & \tplus{\trg{r}}{\trg{\rn}}{\trg{\rn}} \mid \tminus{\trg{r}}{\trg{\rn}}{\trg{\rn}} \mid \tsetatob{\trg{r}}{\trg{r}} \mid \txjmp{\trg{r}}{\trg{r}} \mid \tcseal{\trg{r}}{\trg{r}}{\trg{r}} \\
      & & \tsplice{\trg{r}}{\trg{r}} \mid  \tsplit{\trg{r}}{\trg{r}}
\end{array}
\]

The source machine is also a capability machine with memory capabilities, local capabilities and sealed capabilities. Unlike the target machine, the source machine is going to have a built in stack along with special stack and return capabilities. The syntax of the source machine language is as follows:
\[
  \begin{array}{rcl}
    n & \in & \nats \\
    \src{r} &\in &  \RegName \setminus \{\rstk\}\\
    \src{\rn} &\defbnf & \src{r} \mid n \\
    \src{i} & \defbnf &  \trg{i} \mid \scall{\src{r}}{\src{r}}
  \end{array}
\]
\lau{30-08-2017: We had $\rret$ as not being one of the registers on the source machine. I could not recall why we had this, so I removed it. (I think it may have been from when we had call and return instructions?)}
There is one syntactic difference between the source language and the target language, namely the target language has an extra instruction in the $\scall{}{}$ instruction.

\subsection{Permissions}
\lau{23-03-2017: I am not sure we need the opaque capabilities anymore.} % I am not sure why I did not think the opaque capabilities where necessary, but I have a feeling we talked about this in Leuven and came to the conclusion that they were necessary.
\begin{figure}[!h]
  \centering
  \begin{tikzpicture}[main node/.style={}]
    \node[main node] (rwlx) {$\rwlx$};
    \node[main node] (rwx) [below of=rwlx] {$\rwx$};
    \node[main node] (rx) [below of=rwx] {$\rx$};
    \node[main node] (e) [below of=rx] {$\enter$};


    \node[main node] (rwlxo) [below right of=rwlx,yshift=-0.1cm] {$\rwlxo$};
    \node[main node] (rwxo) [below of=rwlxo] {$\rwxo$};
    \node[main node] (rxo) [below of=rwxo] {$\rxo$};
    \node[main node] (eo) [below of=rxo] {$\entero$};

    \node[main node] (rwl) [below left of=rwlx,xshift=-0.5cm,yshift=-0.3cm] {$\rwl$};
    \node[main node] (rw) [below of=rwl] {$\rw$};
    \node[main node] (r) [below of=rw] {$\readonly$};
    \node[main node] (0) [below of=r] {$\noperm$};

    \node[main node] (rwlo) [below right of=rwl,yshift=-0.1cm] {$\rwlo$};
    \node[main node] (rwo) [below of=rwlo] {$\rwo$};
    \node[main node] (ro) [below of=rwo] {$\ro$};
    \node[main node] (0o) [below of=ro] {$\nopermo$};


    \path[every node/.style={font=\sffamily\small}]
    (rwlxo) edge (rwxo)
    (rwxo) edge (rxo)
    (rxo) edge (eo)

    (rwl) edge (rw)
    (rw) edge (r)
    (r) edge (0)

    (rwlo) edge (rwo)
    (rwo) edge (ro)
    (ro) edge (0o)

    (rwlx) edge[dashed] (rwx)
    (rwx) edge[dashed] (rx)
    (rx) edge[dashed] (e)

    (rwlo) edge (rwlxo)
    (rwo) edge (rwxo)
    (ro) edge (rxo)
    (0o) edge (eo)

    (rwlo) edge (rwl)
    (rwo) edge (rw)
    (ro) edge (r)
    (0o) edge (0)

    (rwl) edge (rwlx)
    (rw) edge[dashed] (rwx)
    (r) edge[dashed] (rx)
    (0) edge[dashed] (e)

    (rwlxo) edge (rwlx)
    (rwxo) edge[dashed] (rwx)
    (rxo) edge[dashed] (rx)
    (eo) edge[dashed] (e);
  \end{tikzpicture}

  \caption{Permission hierarchy}
  \label{fig:perm-hier}
\end{figure}
\lau{01-09-2017: For now, I will add the linear capabilities such that a linear capability stays linear. It does, however, seem like it would be okay to have linear capabilities become non-linear (I at least don't see anything that would break down completely). One draw back would be that one could ``ruin'' the stack capability by making it non-linear.}
\dominique{7-9-2017: Err... you mean that we could allow non-linear capabilities to be made linear, right?  We definitely do not want to allow the stack or return capability to be made non-linear, as we want to prevent it from being aliased.}
\lau{07-09-2017: I actually did mean linear to non-linear (non-linear to linear does not make sense because the non-linear capability may have aliases). The operation that makes a linear capability non-linear would have to clear said capability. If a linear capability has been made non-linear, then someone who expects a linear capability can observe this difference and behave accordingly, i.e., fail the execution. It will, however, remain an invariant that there are no aliases for linear capabilities.}
\lau{07-09-2017: I had forgotten that return capabilities probably need to be linear. This would call for a ``load from offset'' operation to be able to load an in code stored seal (see the figure I drew about linking/seals).}
\lau{13-09-2017: Note that most of the above discussion is now captured in Section~\ref{sec:linear-cap}}

\subsection{Operational Semantics}
\subsubsection{Notes}
Genrally:
\begin{itemize}
\item Opaque capabilities: Only allow locality and permission to be inspected (i.e., no addresses disclosed).
\item Linear capabilities are cleared when they move around in memory.
\end{itemize}

Source language:
\begin{itemize}
\item Variable length instructions that match the length of the compiled instructions
  \begin{itemize}
  \item Opaque capabilities do not hide the length of a program (especially an issue if we ever hope to have error recovery).
  \item This is needed for correctness. See subsection~\ref{subsec:capability-opacity} for an example it helps prevent.
  \end{itemize}
\item Programs have undefined behavior when passing ret/stk pointers.
\end{itemize}

Target language:
\begin{itemize}
\item 
\end{itemize}

\subsubsection{Helpful functions and sets}


\[
  \updPcAddr{c} \defeq \dots
\]

\[
  \updPcPerm{c} \defeq \dots
\]

\[
  \readAllowed{} \defeq \dots
\]

\[
  \writeAllowed{} \defeq \dots
\]

\[
  \isLinear{\cb} \defeq \dots
\]

\[
  \nonLinear{\cb} \defeq \dots
\]

\[
  \nonExec{\cb} \defeq \dots
\]

\[
  \opaquePerm{} \defeq \dots
\]

\[
  \noRetStkReg{\reg} \defeq \forall r \in \reg \setminus \{ \pcreg, \rstk, \rret, \rdata \} \ldotp \reg(r) \neq \stkptr{\_}
\]

\[
  \noRetStkMs{\ms} \defeq \forall \aaddr \in \dom(\ms) \ldotp \ms(\aaddr) \neq \stkptr{\_}
\]

\[
  \withinBounds{c} \defeq \dots
\]

\[
  \nonZero{c} \defeq \dots
\]


\subsubsection{Source Language}
\label{sec:source-language}
\lau{23-03-2017: $\sjmp{}$ and $\scall{}{}$ needs an update. Update: they have been updated (It was $\sxjmp{}{}$ that needed an update.}

\textbf{Call}\\
Call has three cases, a successful call, undefined and failed. For a call to be successful, it needs two sealed capabilities - a data and a code capability. The code capability must be non-executable and the stack register must contain a stack pointer.
\lau{30-08-2017: Add more description here.}

For the call to be undefined, the conditions necessary for a legal call must be met and there must be an attempt at passing the stack pointer to the callee,
\dominique{7-9-2017: We declare the call to be undefined if the caller is doing something ``stupid'' that would break security but which we do not want to check for.  This includes: leaving a copy of the stack pointer or the old return pointer in a place accessible to the callee, invoking local callbacks (see discussion in POPL2018 submission of why this is bad).  The condition that $\cb_2 \neq \stkptr{\_,\_,\_,\_}$ is weird because this would not be the caller's fault, but the callee's.  Further thought needed regarding correct blame assignment for this case.}

If we are not in one of the two cases above, then the execution fails.
\begin{align*}
  \ssem{\scall{r_1}{r_2}} = & 
    \begin{cases}
      (\mem,\reg',\stk',\ms_\stk') & \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        % "red conditions" (in reference to blackboard picture)
                                        \Phi = (\mem,\reg,\stk,\ms_\stk) \text{ and } \\
                                        \Phi(r_1) = \sealed{\cb_1,\sigma} \text{ and } \\
                                        \Phi(r_2) = \sealed{\cb_2,\sigma} \text{ and } \\
                                        \nonExec{cb_2} \text{ and } \\
                                        \Phi(\rstk) = \stkptr{\perm, \stdrng, \aaddr} \text{ and } \\
                                        % "yellow conditions"
                                        \cb_2 \neq \stkptr{\_,\_,\_,\_} \text{ and } \\
                                        \noRetStkReg{\reg} \text{ and } \\
                                        \noRetStkMs{\ms_\stk'} \text{ and } \\
                                        \reg' = \reg
                                        \begin{array}[t]{l}
                                        \update{\pcreg}{\cb_1}\update{\rdata}{\cb_2}\\
                                        \update{\rretc}{\retptr}\\
                                        \update{\rstk}{\stkptr{\perm,[\aaddr,\eaddr],\aaddr}} \text{ and }
                                        \end{array}
\\                                        \text{ for $i \in \{1,2\}$ if $\isLinear{\Phi(r_i)}$, then $\reg''(r_i) = 0$ and} \\
                                        \opc = \Phi(\pcreg)\update{a}{\Phi(\pcreg).a+\calllen} \text{ and } \\
                                        \ms_\priv = \ms_\stk \setminus [\aaddr,\eaddr] \text{ and } \\
                                        \stk' = (\opc,\ms_\priv,\perm,\stdrng,\aaddr) :: \stk \text{ and } \\
                                        \ms_\stk' = \ms_\stk |_{[\baddr,\eaddr]}
                                      \end{array}\\
                                      & \\
      \tundefined & \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        % "red conditions" (reference to blackboard picture)
                                        \Phi = (\mem,\reg,\stk,\ms_\stk) \text{ and } \\
                                        \Phi(r_1) = \sealed{\cb_1,\sigma} \text{ and } \\
                                        \Phi(r_2) = \sealed{\cb_2,\sigma} \text{ and } \\
                                        \nonExec{cb_2} \text{ and } \\
                                        \Phi(\rstk) = \stkptr{\perm, \stdrng, \aaddr} \text{ and } \\
                                        % "yellow conditions"
                                        \text{not } \arraycolsep=0pt
                                        \left(\begin{array}{l}
                                          \cb_2 \neq \stkptr{\_,\_,\_,\_} \text{ and } \\
                                          \noRetStkReg{\reg} \text{ and } \\
                                          \noRetStkMs{\ms_\stk'}
                                        \end{array} \right)
                                      \end{array}\\
                                      & \\
      \failed & \text{otherwise}
    \end{cases}
\end{align*}

The $\scseal{}{}{}$ instruction seals a sealable capability with a seal. The base of the seal is used for the seal. The used seal only works if it still grants authority to seal (that is the base of the seal is smaller than or equal to the end).
\begin{align*}
  \ssem{\scseal{r_1}{r_2}{r_3}} = & 
                                    \begin{cases}
                                      \Phi\updReg{r_1}{\vsc} & 
                                      \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        \Phi(r_2) = c \in \SealableCaps \text{ and } \\
                                        \Phi(r_3) = \seal{\lin,\sigma,\_} \text{ and } \\
                                        \vsc = \sealed{c,\sigma}
                                      \end{array}\\
                                      & \\
                                      \failed & \text{otherwise}
                                    \end{cases}
\end{align*}

Unlike CHERI, we want sealed capabilies to be useable in a somewhat normal jump as well as the $\scall{}{}$. We cannot just use $\sjmp{}$ because it only takes one argument and we need to be able to jump to a code/data pair. To this end we introduce $\sxjmp{}{}$:
\begin{align*}
  \ssem{\sxjmp{r_1}{r_2}} = & 
                              \begin{cases}
                                \Phi'
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  [\reg.\pcreg \mapsto c_1] \\
                                  [\reg.\rdata \mapsto c_2]
                                \end{array} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_1) = \sealed{c_1,\sigma} \text{ and } \\
                                  \Phi(r_2) = \sealed{c_2,\sigma} \text{ and } \\
                                  \text{ for $i \in \{1,2\}$ if $\isLinear{c_i}$, then $\Phi'(r_i) = 0$} \\
                                  \text{ otherwise $\Phi'(r_i) = \Phi(r_i)$ and} \\
                                  \text{ $ \Phi(r) = \Phi'(r) \text{ for } r\in \tRegName \setminus \{r_1,r_2\}$ and} \\
                                  \nonExec{c_2}
                                \end{array}\\\\
%
                                (\mem,\reg',\stk',\ms_\stk') &
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_1) = \retptrc \text{ and } \\
                                  \Phi(r_2) = \retptrd \text{ and } \\
                                  \Phi = (\mem, \reg, \stk, \ms_\stk) \text{ and } \\
                                  \stk = (\opc,\ms_\priv,\aaddr_\stk) :: \stk' \text{ and } \\
                                  \reg \arraycolsep=0pt
                                  \begin{array}[t]{l}
                                    \update{\pcreg}{\opc}\update{\rstk}{\stkptr{\dots,\aaddr_\stk}}\update{r_2}{0}\\
                                  \end{array}
                                \end{array}\\\\
%
                                \failed & \text{otherwise}
                              \end{cases}
\end{align*}
\lau{30-08-2017: questions: what do we allow to be left in the registers? Everything? Only global capabilities? Whatever we do should be matched in the compilation to the target.}

Notice, $\rdata$ serves the same function as the IDC register in CHERI, i.e.\ this is where the data capability is put. In the interpretation of $\sxjmp{}{}$, we require $c_2$ to be non-executable because CHERI does it. We are, however, not certain whether this requirement is strictly necessary (maybe it is dangerous to $\sxjmp{r}{r}$ where $r$ points to the same capability? Maybe it can be use to unseal a code capability by first sealing another code capability with the seal, $\sxjmp{}{}$ with the newly sealed and the old sealed capability. Now both capabilities are unsealed). CHERI also checks whether $c_1$ is executable and in range, but we do this on every step of the operational semantics, so we do not repeat that check.

\textbf{jmp}\\
\begin{align*}
  \ssem{\sjmp{r}} = & 
\end{align*}


\lau{01-09-2017: how should the interaction between read-only memory and linear capabilities be? That is, if a linear capability resides in read-only memory and you attempt to load it what happens? Do the load succeed with the memory cell being cleared or do the load fail (because we need to clear the cell, but we do not have the necessary permissions)? }
\begin{align*}
  \ssem{\sload{r_1}{r_2}} = & 
                              \begin{cases}
                                \updPcAddr{\update{\reg.r_1}{\var{w}}} &
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi = (\mem, \_, \_, \_) \tand \\
                                  \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) = \var{c} \tand\\
                                  \perm \in \readAllowed{} \tand \withinBounds{\var{c}} \tand \\
                                  \var{w} = \mem(\aaddr) \tand \\
                                  \nonLinear{\var{w}}
                                \end{array}\\
                                \updPcAddr{\update{\reg.r_1}{\var{w}}\update{\mem(\aaddr)}{0}} &
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi = (\mem, \_, \_, \_) \tand \\
                                  \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) = \var{c} \tand\\
                                  \perm \in \readAllowed{} \cup \writeAllowed{} \\
                                  \tand \withinBounds{\var{c}} \tand \\
                                  \var{w} = \mem(\aaddr) \tand \\
                                  \isLinear{\var{w}}
                                \end{array}\\
                                \updPcAddr{\Phi\update{\reg.r_1}{\var{w}}\update{\ms_\stk(\aaddr)}{0}} & 
                                % linear capability
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \begin{array}[t]{l}
                                  \Phi = (\_, \_, \_, \ms_\stk) \tand \\
                                  \Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                  \perm \in \readAllowed{} \cup \writeAllowed{} \tand \\
                                  \baddr \leq \aaddr \leq \eaddr \tand \var{w} = \ms_\stk(\aaddr) \tand \\
                                  \isLinear{\var{w}}
                                \end{array}
                                \\
                                \end{array}
                                \\
                                \updPcAddr{\Phi\update{\reg.r_1}{\var{w}}} &
                                \arraycolsep=0pt
                                % non-linear capability
                                \begin{array}[t]{l}
                                  \Phi = (\_, \_, \_, \ms_\stk) \tand \\
                                  \Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                  \perm \in \readAllowed{} \tand \baddr \leq \aaddr \leq \eaddr \tand\\
                                  \var{w} = \ms_\stk(\aaddr) \tand \\
                                  \nonLinear{\var{w}}
                                \end{array}\\
                                \failed & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \ssem{\sstore{r_1}{r_2}} = & 
                               \begin{cases}
                                 \updPcAddr{\Phi\update{\ms.a}{w}}\update{\reg.r_2}{0} &
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr) = \var{c} \tand\\
                                   \perm \in \writeAllowed{} \tand \withinBounds{\var{c}} \tand \\
                                   \var{w} = \Phi(r_2) \tand \\
                                   \isLinear{\var{w}}
                                 \end{array} \\
                                 \updPcAddr{\Phi\update{\ms.a}{w}} &
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr) = \var{c} \tand\\
                                   \perm \in \writeAllowed{} \tand \withinBounds{\var{c}} \tand \\
                                   \var{w} = \Phi(r_2) \tand \\
                                   \nonLinear{\var{w}}
                                 \end{array} \\
%
                                 \updPcAddr{\Phi\update{\ms_\stk.a}{w}}\update{reg.r_2}{0} & 
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi = (\_, \_, \_, \ms_\stk) \tand \\
                                   \Phi(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                   \perm \in \writeAllowed{} \tand \baddr \leq \aaddr \leq \eaddr \tand \\
                                   \aaddr \in \dom(\ms_\stk) \tand \\
                                   \var{w} = \Phi(r_2) \tand \\
                                   \isLinear{w} 
                                 \end{array} \\
                                 \updPcAddr{\Phi\update{\ms_\stk.a}{w}} & 
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi = (\_, \_, \_, \ms_\stk) \tand \\
                                   \Phi(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr} \tand \\
                                   \perm \in \writeAllowed{} \tand \baddr \leq \aaddr \leq \eaddr \tand \\
                                   \aaddr \in \dom(\ms_\stk) \tand \\
                                   \var{w} = \Phi(r_2) \tand \\
                                   \nonLinear{w}
                                 \end{array} \\
                                 \failed & \totherwise
                               \end{cases}
\end{align*}

\textbf{Getters: geta, getb, gete, getp, getl}

\begin{align*}
  \tsem{\tgeta{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\aaddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\_,\_,\aaddr) \text{ or } \\
                                  \quad \Phi(r_2) = \stkptr{\perm,\_,\_,\aaddr} \tand\\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\sgetb{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\baddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\baddr,\_,\_) \text{ or } \\
                                  \quad \Phi(r_2) = \stkptr{\perm,\baddr,\_,\_} \tand\\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\sgete{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\eaddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\_,\eaddr,\_) \text{ or } \\
                                  \quad \Phi(r_2) = \stkptr{\perm,\_,\eaddr,\_} \tand\\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\lau{01-09-2017: Notice, the opacity do not hide ``semantic properties'' such as permission and linearity (this could be changed if it is an issue)}

\begin{align*}
  \tsem{\sgetp{r_1}{r_2}} = & 
                              \begin{cases}
                                \updPcAddr{}(\Phi\update{\reg.r_1}{\encPerm{\perm}}) & \Phi(r_2) = ((\perm,\_),\_,\_,\_) \text{ or } \Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr}\\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\sgetlin{r_1}{r_2}} = &                              
                              \begin{cases}
                                \updPcAddr{}(\Phi\update{\reg.r_1}{\lin}) & \Phi(r_2) = ((\_,\lin),\_,\_,\_) \\
                                \updPcAddr{\Phi\updReg{r_1}{\linear}} & \Phi(r_2) = \stkptr{\_,\_,\_,\_}\\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\textbf{gettype}\\
\lau{06-09-2017: I changed \textbf{isptr} to an instruction that can tell what kind of word is located in a register (as we now have more kinds than integers and capabilities).}
We assume a function $\encType{} : \Word \rightarrow \ints$ that encode the different types of words (that is integers, capabilities, seals and so on) as an integer.
\lau{TODO: 06-09-2017: Write out what $\encType{}$ should satisfy}
\begin{align*}
  \tsem{\sisptr{r_1}{r_2}} = & 
                               \begin{cases}
                                 \updPcAddr{}(\Phi\updReg{r_1}{\encType{\Phi(r_2)}})
                               \end{cases}
\end{align*}


\begin{itemize}
\item $\scall{}{}$ does not do argument spilling anymore. We leave it to the caller to push the arguments for spilling to the stack and update the stack pointer accordingly.
\end{itemize}

\subsubsection{Target Language}
\dominique{7-9-2017: It would be nice if we could share definitions for both languages.  Can we factor them in a way that allows this?}
\lau{07-09-2017: I agree. I will first write out the two languages and then I will look at where they agree (and possibly find some way of unifying the definitions eventhough they don't agree entirely).}

\begin{align*}
  \tsem{\tfail} = & \failed
\end{align*}

\begin{align*}
  \tsem{\thalt} = & \halted
\end{align*}

\textbf{jmp and jnz}\\
Notice that the order of the updates of the configuration actually matters here. As it is below, a successful jump to $\pcreg$ results in a loop, but if the order of the updates to the configuration had been reversed, then the execution would fail as the $\pcreg$ register would contain 0.
\begin{align*}
  \tsem{\tjmp{r}} = & 
                      \begin{cases}
                        \Phi\updReg{r}{0}\updReg{\pcreg}{\Phi(r_r)}
                             & \nonLinear{\Phi(r)} \\
                        \Phi\updReg{\pcreg}{\Phi(r)} & \totherwise
                      \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tjnz{r_1}{r_2}} = &       
                             \begin{cases}
                               \Phi\updReg{\pcreg}{r_1} & \text{if $\nonLinear{\Phi(r_1)}$ and $\nonZero{\Phi(r_2)}$} \\
                               \Phi\updReg{r}{0}\updReg{\pcreg}{\Phi(r_1)}
                                               & \arraycolsep=0pt                               
                                               \begin{array}[t]{l}
                                                 \isLinear{\Phi(r)} \tand
                                                 \nonZero{\Phi{r_2}}
                                               \end{array}
\\
                               \updPcAddr{\Phi} & \totherwise
                             \end{cases}
\end{align*}

\textbf{Getters: geta, getb, gete, getp, and getl}
Notice the difference between the getters in the target languages and their equivalents in the source language is that these do not have a case for the stack pointer as it does not exist in the language.
\begin{align*}
  \tsem{\tgeta{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\aaddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\_,\_,\aaddr) \tand \\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tgetb{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\baddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\baddr,\_,\_) \tand \\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tgete{r_1}{r_2}} = &
                              \begin{cases}
                                \updPcAddr{\Phi\update{\reg.r_1}{\eaddr}} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\_),\_,\eaddr,\_) \tand \\
                                  \perm \not\in \opaquePerm{}
                                \end{array} \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\lau{01-09-2017: Notice, the opacity do not hide ``semantic properties'' such as permission and linearity (this could be changed if it is an issue)}

\begin{align*}
  \tsem{\tgetp{r_1}{r_2}} = & 
                              \begin{cases}
                                \updPcAddr{}(\Phi\update{\reg.r_1}{\encPerm{\perm}}) & \Phi(r_2) = ((\perm,\_),\_,\_,\_)\\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tgetlin{r_1}{r_2}} = &                              
                              \begin{cases}
                                \updPcAddr{}(\Phi\update{\reg.r_1}{\lin}) & \Phi(r_2) = ((\_,\lin),\_,\_,\_) \\
                                \updPcAddr{\Phi\updReg{r_1}{-1}} & \totherwise
                              \end{cases}
\end{align*}

\textbf{gettype}\\
\lau{06-09-2017: I changed \textbf{isptr} to an instruction that can tell what kind of word is located in a register (as we now have more kinds than integers and capabilities).}
We assume a function $\encType{} : \Word \rightarrow \ints$ that encode the different types of words (that is integers, capabilities, seals and so on) as an integer.
\lau{TODO: 06-09-2017: Write out what $\encType{}$ should satisfy}
\begin{align*}
  \tsem{\tisptr{r_1}{r_2}} = & 
                               \begin{cases}
                                 \updPcAddr{}(\Phi\updReg{r_1}{\encType{\Phi(r_2)}})
                               \end{cases}
\end{align*}

\textbf{move}\\
\lau{06-09-2017: Like previously, the order of updates in the second case matters for the case where $r_1 = r_2$.}
\begin{align*}
  \tsem{\tmove{r_1}{r_2}} = & 
                              \begin{cases}
                                \updPcAddr{\Phi\updReg{r_1}{\Phi(r_2)}} & \nonLinear{\Phi(r_2)}\\
                                \updPcAddr{\Phi\updReg{r_2}{0}\updReg{r_1}{\Phi(r_2)}} & \totherwise 
                              \end{cases}
\end{align*}
\dominique{7-9-2017: add the condition that $r_1 \neq r_2$ for sanity?}
\lau{07-09-2017: I would find it odd if the machine had to special case on that (what would it even do? Fail?). As it is now, it follows the invariant that a linear capability is never aliased.}

\begin{align*}
  \tsem{\tstore{r_1}{r_2}} = & 
                               \begin{cases}
                                 \Phi\updReg{r_2}{w_2}
                                     \update{\mem.a}{\Phi(r_2)} & \arraycolsep=0pt
                                     \begin{array}[t]{l}
                                       \Phi(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                       \perm \in \writeAllowed{} \tand \\
                                       \baddr \leq \aaddr \leq \eaddr \tand \\
                                       \isLinear{\Phi(r_2)} \Rightarrow w_2 = 0 \tand \\
                                       \nonLinear{\Phi(r_2)} \Rightarrow w_2 = \Phi(r_2)
                                     \end{array} \\
                                  \failed & \totherwise
                               \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tload{r_1}{r_2}} = & 
                              \begin{cases}
                                \Phi\update{\mem.a}{w_2}\updReg{r_1}{w} &
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                  \perm \in \readAllowed{} \tand \\
                                  \baddr \leq \aaddr \leq \eaddr \tand \\
                                  w = \Phi.\mem(a) \tand \\
                                  \isLinear{w} \Rightarrow w_2 = 0 \tand \\
                                  \nonLinear{w} \Rightarrow w_2 = \Phi.\mem(a)
                                \end{array} \\
                                \failed & \totherwise
                              \end{cases}
\end{align*}

\begin{align*}
  \tsem{\tlea{r_1}{r_2}} = & \dots
\end{align*}

\begin{align*}
  \tsem{\trestrict{r_1}{r_2}{r_3}} = & \dots
\end{align*}

\begin{align*}
  \tsem{\tsubseg{r_1}{r_2}{r_3}{r_4}} = &
                                     \begin{cases}
                                       \updPcAddr{\Phi\update{r_1}{\var{c}}} &
                                       \arraycolsep=0pt
                                       \begin{array}[t]{l}
                                         \Phi(r_2) = ((\perm,\lin),\baddr, \eaddr, \aaddr) \tand \\
                                         \text{for $i \in \{3,4\}$ and} \\
                                         \quad n_i = r_i \text{ or } n_i = \Phi(r_i) \tand \\
                                         \quad \text{in either case $n_i \in \ints$ and} \\
                                         \quad \baddr \leq n_3 \tand \\
                                         \quad n_4 \leq \eaddr \text{ or } n_4 = \infty \tand \\
                                         \quad \perm \neq \enter \tand \\
                                         \quad c = ((\perm,\lin),n_3,n_4,\aaddr)
                                       \end{array} \\
                                       \updPcAddr{\Phi\update{r_1}{\var{s}}} &
                                       \arraycolsep=0pt
                                       \begin{array}[t]{l}
                                         \Phi(r_2) = \seal{\lin,\phi_{\var{base}},\phi_{\var{end}}} \tand \\
                                         \text{for $i \in \{3,4\}$ and} \\
                                         \quad n_i = r_i \text{ or } n_i = \Phi(r_i) \tand \\
                                         \quad \text{in either case $n_i \in \ints$ and} \\
                                         \quad \phi_{\var{base}} \leq n_3 \tand \\
                                         \quad n_4 \leq \phi_{\var{end}} \text{ or } n_4 = \infty \tand \\
                                         \quad \perm \neq \enter \tand \\
                                         \quad c = \seal{\lin, n_3,n_4}
                                       \end{array} \\
                                       \failed & \totherwise
                                     \end{cases}
\end{align*}
\dominique{31-8-2017: Why do we allow applying subseg to a sealed capability?}
\lau{6-9-2017: We do not. We allow subseg on the seals that are used to seal capabilities.}

\begin{align*}
  \tsem{\tlt{r_1}{r_2}{r_3}} = & \dots
\end{align*}

\begin{align*}
  \tsem{\tplus{r_1}{r_2}{r_3}} = & \dots
\end{align*}

\begin{align*}
  \tsem{\tminus{r_1}{r_2}{r_3}} = & \dots
\end{align*}

\begin{align*}
  \tsem{\tsetatob{r_1}{r_2}} = & 
                                 \begin{cases}
                                   \updPcAddr{\Phi\update{\reg.r_1}{c}} &
                                   \arraycolsep=0pt
                                   \begin{array}[t]{l}
                                     \Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \tand \\
                                     c = ((\perm,\lin),\baddr,\eaddr,\baddr) \\
                                     \perm \neq \enter \tand \perm \not\in \opaquePerm{}
                                   \end{array}
                                   \\
                                   \failed & \totherwise
                                 \end{cases}
\end{align*}

\begin{align*}
  \tsem{\txjmp{r_1}{r_2}} = & 
                              \begin{cases}
                                \Phi
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \update{\reg.\pcreg}{c_1} \\
                                  \update{\reg.\rdata}{c_2}
                                \end{array} & 
                                \arraycolsep=0pt
                                \begin{array}[t]{l}
                                  \Phi(r_1) = \sealed{c_1,\sigma} \text{ and } \\
                                  \Phi(r_2) = \sealed{c_2,\sigma} \text{ and } \\
                                  \nonExec{c_2}
                                \end{array}
\\
\failed & \text{otherwise}
                              \end{cases}
\end{align*}

Sealing a capability: $\tcseal{}{}{}$ seals a sealable capability
\begin{align*}
  \tsem{\tcseal{r_1}{r_2}{r_3}} = & 
                                    \begin{cases}
                                      \updPcAddr{\Phi\update{\reg.r_1}{\sealed{\Phi(r_2),\phi_{\var{base}}}}} &
                                      \arraycolsep=0pt
                                      \begin{array}[t]{l}
                                        \Phi(r_2) \in \SealableCaps \text{ and } \\
                                        \Phi(r_3) = \seal{\lin,\phi_{\var{base}},\phi_{\var{end}}} \\
                                        \phi_{\var{base}} \leq \phi_{\var{end}} % This allows one to restrict a seal to not have any authority
                                      \end{array} \\
                                      \failed & \text{otherwise}
                                    \end{cases}
\end{align*}

$\tsplice{}{}$ we allow two capabilities to be spliced if the second one starts on the address after the first one ends. They must also agree on permission, globality and linearity (so we also allow non-linear capabilities to be spliced). We do, however, exclude enter capabilities as this may cause subtle security issues.
\begin{align*}
  \tsem{\tsplice{r_1}{r_2}} = &
                                \begin{cases}
                                  \updPcAddr{\Phi\update{r_1}{\dots}\update{r_2}{c}} &
                                  \arraycolsep=0pt
                                  \begin{array}[t]{l}
                                    \Phi(r_1) = ((\perm, \lin), \baddr_1, \eaddr_1, \aaddr_1) \\
                                    \Phi(r_2) = ((\perm, \lin), \baddr_2, \eaddr_2, \aaddr_2) \\
                                    \eaddr_1 + 1 = \baddr_2 \\
                                    \perm \neq \enter \\
                                    c = ((\perm, \lin), \baddr_1, eaddr_2, \aaddr_1)
                                  \end{array}
                                  \\
                                  \failed & \totherwise
                                \end{cases}
\end{align*}

$\tsplit{}{}$ this instruction splits a capability in two. We require the address we wish to split on to be in the interval of the authority granted by the capability to prevent handing out authority from capabilities with no authority. We prohibit enter capabilities to prevent subtle errors. 
\begin{align*}
  \tsem{\tsplit{r_1}{r_2}} = &
                               \begin{cases}
                                 \updPcAddr{\Phi\update{r_1}{c_1}\update{r_2}{c_2}} &
                                 \arraycolsep=0pt
                                 \begin{array}[t]{l}
                                   \Phi(r_1) = ((\perm, \lin), \baddr, eaddr, \aaddr) \\
                                   r_2 = n \text{ or } \Phi(r_2) = n \text{ and in either case } n \in \nats\\
                                   \perm \neq \enter\\
                                   \baddr \leq n  < \eaddr\\
                                   c_1 = ((\perm,\lin),\baddr, n, \aaddr) \\
                                   c_2 = ((\perm,\lin),n + 1, \eaddr,\aaddr)
                                 \end{array} \\
                                 \failed & \totherwise
                               \end{cases}
\end{align*}


\subsection{Target program linking and layout}
\lau{13-09-2017: TODO take another look and linking and consider what the setup must be now that we don't have local capabilities.}
For a $\scall{}{}$ to be secure after compilation, we need to use the seal mechanism. In order for a program to seal a capability, it must have a seal available. We propose that a compiled program must have the layout sketched in Figure~\ref{fig:trg-prog-link}. The first address of a program contains a seal (unique to this program), the second address contains a capability for a linking table, and the following addresses contain the instructions of the program. The capability for the program points to the first address of the program and it has permission no greater then global read-execute (notice that it does not have write).

The capability for the linking table is a global read-write capability, which means that it does not grant access to alter the table (which means that the table could potentially be shared between multiple parties). The linking table contains pairs of sealed code and data capabilities.

The program should also have access to a persistent memory which it has in the register $\rdata$ where it has a global read-write capability (or something less) (notice that this capabilty should not have execute permission). Finally the program also has access to local memory in the form of a stack. The capability for the stack resides in $\rstk$ and the capability should have local read-write-local permission (or less)
\lau{30-08-2017: The stack capability may even need to be opaque for the sake of making the setup general (we will be handing over opaque stack capabilities).}

\lau{30-08-2017: should the capability for the ``persistent'' memory reside along side the code?}

Notice that the linking part is not strictly necessary for the compilation, but we would like to be able to link our known programs with other programs.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{img/prog_layout.jpg}
  \caption{Target program linking and layout (there is a typo in the figure: the pc capability should be global rather than local).}
  \label{fig:trg-prog-link}
\end{figure}

\subsection{Compiler}
\[
\comp{\cdot} : \src{i}^* \fun \trg{i}^*
\]

\[
  \comp{\scall{r_1}{r_2}} = 
  \begin{array}[t]{l}
    % Make the stack capability into the return capability and seal it:
    %   Push r_data to the stack (should this be made the responsibility of the programmer? If it happens here, then it should probably also be part of the call semantics. Especially, the call semantics should "eat" another piece of memory on the stack to make sure there is no discrepancy.)
    %   Seal the stack capability (with what? where does the seal come from? I think we talked about this, and it is something that should be handled like linking (a fresh seal is available in the beginning of a programs code along with a capability for a linking table)).
    % restrict the stack capability to the unused part (and clear this part).
    % make return capability and ceal it:
    %   Move a copy of pc to a different register.
    %   Adjust the pc copy to point to the return address.
    %   Seal it with the seal.
    % remove all data from temp registers (that is at least the seal).
    % jmpx to r1 and r2
    % restore code:
    %   move the stack pointer to the proper register
    %   pop the data capability
  \end{array}
\]

\clearpage
\section{Examples}
\subsection{Capability Opacity}
\label{subsec:capability-opacity}
This example was introduced when we envisioned a capability machine with $\spush{}$, $\spop{}$, $\ssload{}{}$, $\scall{}{}$ and $\sreturn$ instructions. The below example is a motivation for having variable length instructions in the source language because if we have enough memory to ``do the same'' in the target language as in the source language, then the below example does not work.

The following pseudo program demonstrates the need of opaque capabilities. If we assume a system with no opaque capabilities, then the following programs break compiler correctness
\begin{lstlisting}
[basicstyle=\sourcecolor{}\ttfamily] 
p1 ::= if r1 is length 2 then
         call r1 with the following callback in r5:
           {put $\textit{\texttt{diverging}}$ closure in r2;
            return};
         halt
       else diverge

p2 ::= if r1 is length 2 then
         call r1 with the following callback in r5:
           {put $\textit{\texttt{terminating}}$ closure in r2;
            return};
         halt
       else diverge
\end{lstlisting}
The diverging closure could just contain $\sjmp{\pcreg}$, which diverges. The terminating closure could just be $\sreturn$.

The context with $r1$ as an executable capability pointing to:
\begin{lstlisting}
$\scall{r5}{0}$
$\sjmp{r5}$
\end{lstlisting}
\footnote{At this time $\scall{}{}$ did argument spilling and it only takes one argument because we were considering enter capabilities.}distinguishes the two contexts, but two instructions are not enough to do the same at the target level. We would not have enough instructions to set up a proper return pointer for the compiled return to use.

\clearpage
\section{Back translation}
The back translation is an embedding of source language into .

\section{Notes}
\subsection{Leuven stay conclusions}
\begin{enumerate}
\item Enter capabilities replaces by sealed code/data pairs \label{item:first-point}
  \begin{itemize}
  \item To allow us to forbid dynamic code generation
  \end{itemize}
\item Conditional full-abstraction
  \begin{itemize}
  \item No undefined behaviour by \emph{trusted code} in any context implies full-abstraction. (Blame idea: undefined as undef of current pc, so current pc can be checked for whether it was the trusted code).
  \item Avoids dynamic checks to protect trusted code against itself.
  \item Possible due to point \ref{item:first-point}.
  \end{itemize}
\item replace push/pull/call/ret/sload by symbolic return pointer (pair) and stack pointer.
  \begin{itemize}
  \item Allows backtranslation to be embedding into source language.
    \begin{itemize}
    \item Interpreter for backtranslation is not able to accurately replicate code length.
    \end{itemize}
  \end{itemize}
\item Worlds similar to CSF paper, but invariants on seals as well.
  \begin{itemize}
  \item Invariants says what can be sealed with a certain seals.
  \end{itemize}
\item Linker: resolves symbols
  \begin{itemize}
  \item Export refs (Question: do we allow other things than sealed code/data pairs to be exported?)
  \item Import refs
  \item Fresh seal requirement
  \end{itemize}
\item Components are memory segments and symbols.
\item Variable instruction length in the source to avoid leaking information through code size that cannot be matched after compilation (breaks compiler correctness, se example in subsection~\ref{subsec:capability-opacity}).
  \begin{itemize}
  \item Notice x86 allows instructions of up to infinite length, so this is not weird.
  \end{itemize}
\item Have opaque capabilities.
  \begin{itemize}
  \item Without opaque capabilities, stack consumption could be inferred through stack pointer index etc.
  \end{itemize}
\item Considered PORs for transition systems to: ($a \rightarrow b \Rightarrow a = a \text{ and } b = b$)
  \begin{itemize}
  \item Define one region that governs the stack
  \item Make the regions more general
  \item For now, we have not done this: instead we stick with the transition systems we have and have to regions governing the stack reflecting the CSF work.
  \end{itemize}
\end{enumerate}

\subsection{Some explanation}
\subsubsection{The source language}
The whole idea of this paper is to show that we enforce well-bracketed control flow correctly by taking a source language with a native stack and native call and return instructions and well-bracketedness enforced by the operational semantics.
We then prove that we can compile this source language to a regular assembly target language (without a native stack) in a fully abstract way using our stack and return pointer discipline.
So the design goals for our source language were precisely these: it should be an intermediate language that stays as close as possible to our target language, can be fully abstractly compiled to the target and feature a native well-behaved stack.
This source language can then be used as the second-to-last language in the compilation chain of a fully abstract compiler.
By compiling in a fully abstract way to our source language and then composing with our compiler, fully abstract compilation to our target language follows easily.

These design goals drove us to the current definition of our source language and some special design choices.
Particularly, contrary to what one might expect in a language with a native stack, we do not use call/return and push/pop instructions.
The reason is that we are working in a language where the length of code blocks can be observable.
Imagine two trusted blocks of code that looks as follows:
\begin{lstlisting}
[basicstyle=\sourcecolor{}\ttfamily] 
p1:       <assert that r1 contains an executable capability to a block of 
           instr_length (push) + instr_length(jmp)>
          <load return capability to p1-ret1 in r2>
          <load value 0 in r3>
          <jump to r1>
p1-ret1:  <assert that 0 is loaded in the next free stack position>
          <repeat the above with value 1 in r3>
          ...
p1-ret2:  <assert that 1 is loaded in the next free stack position>
          <repeat the above with value 2 in r3>
          ...
p1-ret3:  <assert that 2 is loaded in the next free stack position>
          halt

p2:       <assert that r1 contains an executable capability to a block of 
           instr_length (push) + instr_length(jmp)>
          <load return capability to p2-ret1 in r2>
          <load value 1 in r3>
          <jump to r1>
p2-ret1:  <assert that 1 is loaded in the next free stack position>
          <repeat the above with value 2 in r3>
          ...
p2-ret2:  <assert that 2 is loaded in the next free stack position>
          halt
\end{lstlisting}

p1 and p2 each accept an (unprotected) closure from the context whose lenght is restricted.
Together with the checks performed by p1 and p2, there is only one possible implementation of the closure that will not fail, namely
\begin{lstlisting}
[basicstyle=\sourcecolor{}\ttfamily] 
closure: push r3
         jmp r2
\end{lstlisting}

However, this is no longer true in the target language.
Assume that $\mathtt{push r3}$ is implemented as a store to $\rstk$ followed by an increment of $\rstk$.
The adversary can now construct a closure that does not use the standard implementation of push, but instead does this:
\begin{lstlisting}
[basicstyle=\targetcolor{}\ttfamily] 
evil-closure: jnz r3 r2
              store \rstk r3
              jmp r2
\end{lstlisting}
If we now assume that the instructions in evil-closure (jnz+store+jmp) are the same length as the original closure(store+increment+jmp), then the adversary can now construct a closure that discriminates $\mathtt{p1}$ and $\mathtt{p2}$ above.
The essential point here is that an assumption in the source language that relies on facts about instruction length (``a closure restricted to the instruction-size of push+ret that modifies the stack and returns can only be implemented in one way'') is no longer valid, because there are now more low-level ways of interacting with the stack.

To remedy this, we decided to modify our source language to use a different way of interacting with the stack.
This alternative approach stays even closer to the target language.
The problem is not actually that we shouldn't offer push/pop and call/return instructions, but rather that our language should also offer an equivalent for the more low-level interactions with the stack that are possible in the target language.
As such, we introduce special token values that play the role of the stack pointer/return pointer and we allow all interactions with them that are possible using instructions like \sstore{}{}, \smove{}{} etc.
Specifically, as shown in \cref{sec:domains}, there are new token capabilities $\stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}$, $\retptrd$ and $\retptrc$ which represent a copy of the stack pointer, and the code and data parts of the sealed return closure.
Rather than invoking \spush{} or \spop{}, one can store into the $\stkptr{}$ and modify its current address and as we can see in \cref{sec:source-language}, this has the semantic effect that one would expect.
Similarly, rather than invoking \sreturn{}, one would ccall the $\retptrd$ and $\retptrc$ sealed code/data pair.

We do not offer primitive \sreturn{}, \spush{} and \spop{} instructions, even though there is nothing keeping us from doing that, either as an additional primitive instruction or as a macro on top of the primitive token values mentioned above.
We do offer a primitive \scall{}{} instruction, and it offers the only way to create a new stack frame.
It is the only instruction that does not have a target language counterpart.
However, there is a counterpart to \sxjmp{}{}, the instruction that would be used for jumping in the code that \scall{}{} compiles to.
We will discuss later that this means that if we backtranslate an adversary piece of code (in the full abstraction proof), then it will be backtranslated (under our trivial back-translation) to equivalent code that \emph{never} does an actual call, but always just jumps to where it wants to go.
In other words, the back-translated code never uses call to protect its own stack frame from the code that it passes control to.
This means that the back-translated code is quite insecure, but we don't need it to be: it just needs to be behaviorally equivalent to the target language code that it represents.

% Finally, rather than invoking call, \dominique{7-9-2017: err, what's the reason we don't follow the same pattern for call?}.
% \lau{07-09-2017: One would use $\scall{}{}$ with a pair of sealed capabilities to securely jump to this pair - that is to have this pair executed in a new stack frame. The return would happen just by using $\sxjmp{}{}$ with the $\retptrd$ and $\retptrc$. However, this would work with the local capabilities as the real implementation of $\retptrd$ would be a sealed version of the entire stack pointer. In other words, upon jumping back no extra work would have to be done. Now, however, the old stack pointer should be spliced (using the new $\ssplice{}{}$ instruction) with the stack pointer we sent away in order to regain the old stack pointer. In other words, we need something to recognise when a return happens.}
% \lau{07-09-2017: On second thought, when compiled all the code necessary for the call will be generated based on the $\scall{}{}$ instruction. The real implementation of the $\retptrc$ will simply point to a piece of clean up code that splices together the old/private stack pointer with the one we got from the untrusted party. This may, however, give some issues when we want to reason about it because there will be a disconnect between where the clean up job is done in the operational semantics of the source language (namely as part of the $\sxjmp{}{}$), but in a translated program, the code that does the clean up origins with the $\scall{}{}$ instruction. }

Note that the token values representing the stack and return pointer in our source language are essentially just a weird alternative syntax for something we would otherwise write using call/return and push/pop.
However, it does remove the problem described above of relying on facts that follow from code length, because we can now write exactly the same code in source and target and it will do exactly the same thing if it is well-behaved.
The code would look exactly the same in source and target, it would just be working with token values in the source versus real stack and return pointers in the target.
That the problem is really gone should follow from being able to write a full-abstraction proof.
However, our approach should also simplify that proof.
The reason is that back-translating should become essentially trivial: rather than performing some form of emulation or a real back-translation (which would inevitably make code size larger), it should be sufficient to just use unmodified target instructions as source instructions that will just be working with different types of values.


\subsubsection{Conditional full abstraction}
\label{sec:conditional-full-abstraction}

Another novelty in this work is the fact that we do not want to prove general full abstraction (i.e. two source programs are behaviorally equivalent if and only if they are compiled to behaviorally equivalent target programs).
The reason is that we only want to prove a result about programs that respect the calling convention, i.e.\ that do not do anything stupid.
For example, in the old setup with global/local capabilities, when trusted code performs an \scall{}{}, it should make sure that it does not store a copy of its stack pointer in a place that is accessible to the callee (e.g.\ in a register or in the callee's part of the stack).
Such sanity conditions are necessary (we cannot guarantee anything for code that does such stupid things) but we do not want to spend computation time on checking them.
Instead, we expect a reasonable compiler to guarantee in some way that its generated code never does such stupid things and then our guarantees should apply.

Note that in the new setup with linear capabilities instead of local/global ones, there seems to be less opportunity for the trusted code to do stupid things, so it may be that we no lnoger need these sanity conditions, but this is not clear yet.

Assuming that we need sanity conditions on the source code, the question is how we formulate them in our full abstraction.
Our idea is to formulate a notion of conditional full abstraction: ``if source programs t1 and t2 never perform stupid things under any possible source interaction, then they are source-equivalent iff their compilations are target-equivalent.''.
However, the question remains how we formalise the condition ``if source programs t1 and t2 never perform stupid things under any possible source interaction''.

Two possible approaches:
\begin{itemize}
\item \emph{Blame}: the idea here would be that we introduce a notion of ``undefined behavior'' in the operational semantics.
  ``Doing stupid things'' like leaving copies of the stack pointer around on a call, would cause the system to enter an undefined state.
  We would then like to express the above mentioned sanity condition as ``t1 and t2 never evaluate to undefined when plugged into an arbitrary program context''.
  However, that doesn't work, because it does not discriminate between undefined behavior caused by t1 or t2 (on the one hand) and the program context (on the other hand).
  To remedy this, we intended to use a notion of blame assignment: the undefined state would contain the address of the pc that was active at the moment it went wrong.
  We would then express the above mentioned sanity condition as ``t1 and t2 never evaluate to undefined(pc) where pc is within the trusted code's assigned code memory when plugged into an arbitrary program context''.

  The problem with this approach is that it does not combine well with dynamically generated code (solution: exclude code-generation?) and that it adds a lot of complexity.

\item \emph{A logical relation}: An alternative approach (suggested by Lars to Lau) might be to define a logical relation to express the sanity condition ``t1 and t2 never evaluate to undefined when plugged into an arbitrary program context''.
  This remains to be thought through in more detail, but it might be simpler and/or be easier to combine with dynamic code generation.
\end{itemize}

\subsection{Linear Capabilities}
\label{sec:linear-cap}
The idea with linear capabilities is to limit aliasing of a capability. We specifically wanted a linear capability for the stack pointer, to not have to erase large pieces of memory, which we have to when we use local capabilities. With linear capabilities, we would just need to find the one linear capability to be sure we have the only capability under our control.

There are multiple ways that linear capabilities could work (we choose the second one):
\begin{enumerate}
\item A linear capability comes with a system wide guarantee that no alias for this capability (or any part of the memory it has authority over). In other words, the linear capability is the only capability for this piece of memory. 

In order for this to work, the memory must initilaly be partitioned into two part. One controlled by a non-linear capability and one controled by a linear capability. The semantics of the machine would now have to make sure that the linear capability is never aliased. For instance, moving a linear capability from one register would cause the source register to be cleared. 

In this scheme, it would be okay to permit linear capabilities to become non-linear (which would consume the linear capability). The reasoning would be that it is okay to remove the aliasing restriction and thus make the part of memory with the no-aliasing guarantee smaller. If some program depends on a certain capability received from an adversary to be linear, then they would simple have to check whether it is in fact linear. As the linear capability is consumed when making it non-linear, it would have no way to regain the linear capability.

\item A linear capability can be created from a non-linear capability. The linear capability has no guarantee that it is not aliased, but no aliases can be made from the linear capability. The linear capability can now be passed to an adversary and if the adversary gives back the linear capability when they return, then we know that they have no alias for it (provided we did not give them one and they did not have one in the first place), because the linear capability does not permit them to creat an alias.

In this scheme, the system would initially have one non-linear capability for all of the memory. The linear capabilities would then be generated as they are needed.
\end{enumerate}
Notice that the two schemes are incompatible as they would undermine eachother.

We choose to use the second scheme for the following reasons:
\begin{enumerate}
\item While the stack pointer was the motivation for the linear capabilities, we believe they can also be used for other things such as return pointers. When used for return pointers, we know that the return pointer used to return to us was the only one available. However, if we used the first scheme, then all of the code would have to be in the linear part of memory. This would be undesirable if we want to provide several entities access to the same program. 
\end{enumerate}

\subsubsection{Write-linear capabilities}

At the time is writing, it is unclear whether write-linear (in the style of write-local permission\footnote{Here it would mean that linear capabilities can only be written through capabilities with write-linear permission and all capabilities with write-linear permission must themselves be linear.}) is necessary. One might think that it is necessary to prevent ``indirect aliasing'', which here would mean that a linear capability would be stored in a piece of memory for which there are multiple non-linear capabilities. This does, however, not seem to be a problem as the aliasing invariants are never broken. The memory the linear capability governs is still not aliased and if anyone needs to use the capability, they would have to load it to a register which would remove it from memory.

One thing write-linear capabilities may be useful for is to make sure that return capabilities are used in the correct order, i.e., ensuring well-bracketedness. 
\lau{08-09-2017: I have not thought the above completely through} 
\lau{13-09-2017: Dominique wrote something about this in an e-mail. The splicing necessary for each call would be what is needed to make the write-linear obsolete. The splicing would fail in the cases where someone try to use the wrong data-capability. Further something like write-linear would have the same issue as write-local. We would rely on the fact that the write-linear permission limits the space where we might need to look for linear capabilties. In order to remove the desired linear capability, we would still need to search through all the places it could be which would be infeasible (like the clear memory segment instruction).}

We have also considered removing local capabilities as these no longer seem necessary and only add complexity. However, they may be relevant to ensure the well-bracketed control flow (this will need further consideration).

\end{document}