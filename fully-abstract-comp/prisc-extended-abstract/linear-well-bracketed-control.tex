\documentclass[sigplan, review]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{cleveref}
\usepackage{natbib}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
% \acmDOI{10.475/123_4}

% ISBN
% \acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[PriSC]{Workshop on Principles of Secure Compilation}{January 2018}{Los Angeles, California USA} 
\acmYear{2018}
\copyrightyear{2018}

% \acmPrice{15.00}

%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}


\begin{document}
\title{Enforcing Well-bracketed Control Flow and Stack Encapsulation using Linear Capabilities}
% \titlenote{Produces the permission block, and
%   copyright information}
\subtitle{Extended Abstract}
% \subtitlenote{The full version of the author's guide is available as
%   \texttt{acmart.pdf} document}

\author{Lau Skorstengaard}
% \orcid{}
\affiliation{%
  \institution{Aarhus University}
}
\email{lau@cs.au.dk}

\author{Dominique Devriese}
\orcid{0000-0002-3862-6856}
\affiliation{%
  \institution{imec-DistriNet, KU Leuven}
}
\email{dominique.devriese@cs.kuleuven.be}

\author{Lars Birkedal}
\affiliation{%
  \institution{Aarhus University}
}
\email{birkedal@cs.au.dk}

% The default list of authors is too long for headers}
% \renewcommand{\shortauthors}{B. Trovato et al.}


% \begin{abstract}
% This paper provides a sample of a \LaTeX\ document which conforms,
% somewhat loosely, to the formatting guidelines for
% ACM SIG Proceedings. 
% \end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>  
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}


% \keywords{ACM proceedings, \LaTeX, text tagging}

% \begin{teaserfigure}
%   \includegraphics[width=\textwidth]{sampleteaser}
%   \caption{This is a teaser}
%   \label{fig:teaser}
% \end{teaserfigure}


\maketitle

\section{Introduction}
Secure compilers preserve source-language (security-relevant) properties even when the  compiled code interacts with arbitrary target-language components.
Generally, properties that hold in the source language but not in the target language, need to be somehow enforced by the compiler.
Two properties that hold in many high-level source languages, but not in the assembly languages that they are compiled to are the well-bracketedness of control flow and the encapsulation of local state.

Well-bracketed control flow expresses that invoked functions must either return to their callers, invoke other functions themselves or diverge, and generally holds in programming languages that do not offer a primitive form of continuations. 
At the assembly level, this is not so obvious, as invoked functions get direct access to return pointers, that they are supposed to jump to a single time, at the end of their execution, but there is no guarantee that untrusted assembly code respects this intended usage.
Particularly, it may invoke return pointers from other stack frames than the one it was invoked from, either ones from frames higher in the call stack or from stack frames that no longer exist because they have already been returned to before. 

Local state encapsulation is the guarantee that when a function invokes another function, its local variables will not have been modified when the invoked function returns.
At the assembly level, this property is also far from obvious, local variables are stored on the stack when another function is invoked, and functions are not supposed to touch stack frames other than their own.
However, untrusted assembly code is usually not prevented from ignoring this requirement and overwriting the local state of its caller or other stack frames.

To enforce these properties, a target language is needed with some form of security primitive that can be used to prevent untrusted code from misbehaving, without imposing too much overhead on well-behaved code.
The virtual-memory based security primitives on commodity processors do not seem sufficiently fine-grained to efficiently support this type of enforcement.
More suitable security primitives are offered by a type of processors known as capability machines \citep{levy_capability-based_1984,watson_cheri:_2015}.
These processors use tagged memory to enforce a strict separation between integers and \emph{capabilities}: pointers that carry authority.
Capabilities come in different flavours.
Memory capabilities are used to read and write to memory.
Additionally, CHERI offers a notion of sealed code-data pairs of capabilities that represent a type of encapsulated closure: a piece of code coupled with private state that it gains access to upon invocation.\footnote{Other capability machines offer other mechanisms that can be used to the same effect.} 

CheriBSD, an operating sytem built on the CHERI capability machine, uses per-component separate stacks and a central, trusted stack manager component to enforce well-bracketed control flow and private state encapsulation \citep{watson_cheri:_2015}.
To prevent the stack pointer (or derivatives from it) from being passed to other components, CheriBSD uses local capabilities: a type of capabilities that can be kept in registers but not stored in memory (except through store-local capabilities like the stack pointer itself).
The literature does not contain many details about the mechanism, let alone a formal analysis, but most importantly, the mechanism does not seem like it can support higher-order interfaces (e.g. C function pointers) in a scalable fashion.

In recent work, we have been looking at an alternative approach \citep{skorstengaard_reasoning_nodate}.
It is also based on CHERI's local capabilities, but combines them with a more traditional, single, shared stack that scales better in the presence of higher-order interfaces.
By passing stack and return pointers as local capabilities, our mechanism effectively prevents callees from storing them on the heap.
Using a step-indexed Kripke logical relation, we are able to prove correctness of programs that rely on well-bracketed control flow in a complex way.

While this approach works quite well, this paper investigates another alternative approach.
The aim of this new approach is to resolve two limitations: (1) the need to clear the stack on boundary crossings and (2) the lack of a formal statement of well-bracketed control flow and local state encapsulation.
In the next two sections, we discuss these two limitations and how we intend to resolve them.

\section{Linear Capabilities, not Local}


\section{Formalising well-bracketed control flow}

\section{Conclusion}
Contributions here?

\bibliographystyle{ACM-Reference-Format}
\bibliography{references} 

\end{document}
