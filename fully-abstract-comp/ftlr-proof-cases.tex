\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}

\input{preamble}

\title{FTLR proof cases}

\begin{document}

\maketitle
\section{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[$\lrv$ mono]
  For all $n$, $w_1$, $w_2$, and $W' \future W$, if $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in \lrv(W')$
\end{lemma}

\section{FTLR proof}
By induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
\begin{proof}
  Assume
\[
  \npair{(b,e)}\in \readCond{\lin,W}
\]
and show
\[
\npair{((\rx,\lin),\baddr,\eaddr,\aaddr),
       ((\rx,\lin),\baddr,\eaddr,\aaddr)} \in \lre(W)
\]
We write $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{[(c,c)]} \in \lrp(W)$
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is well-defined.
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\updReg{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\updReg{\pcreg}{c})$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S,\Phi_T)} \in \lro
\]
Let $i \leq n'$ be given \footnote{ignoring the frame...} and show
\[
  \Phi_S \term[i] \Rightarrow \Phi_T \term
\]
and 
\[
  \Phi_T \term[i] \Rightarrow \Phi_S \term
\]

\subsubsection*{Assuming source machine terminates}
First show the former of the two, assume $\Phi_S\term[i]$. We now consider the first step of $\Phi_S \term[i]$\footnote{if $i=0$, then we have a contradiction with $\Phi_S\term[i]$.}. 
The possible instructions that could have been executed are:
\begin{enumerate}
\item $\tfail$
\item $\thalt$
\item $\tjmp{\trg{r_1}}$
\item $\tjnz{\trg{r_1}}{\trg{\rn}}$
\item $\tisptr{\trg{r_1}}{\trg{r_2}}$
\item $\tgeta{\trg{r_1}}{\trg{r_2}}$
\item $\tgetb{\trg{r_1}}{\trg{r_2}}$
\item $\tgetp{\trg{r_1}}{\trg{r_2}}$
\item $\tgetlin{\trg{r_1}}{\trg{r_2}}$
\item $\tmove{\trg{r_1}}{\trg{\rn}}$
\item $\tstore{\trg{r_1}}{\trg{r_2}}$
\item $\tload{\trg{r_1}}{\trg{r_2}}$
\item $\tcca{\trg{r_1}}{\trg{\rn}}$
\item $\trestrict{\trg{r_1}}{\trg{r_2}}{\trg{\rn}}$
\item $\tlt{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tplus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tminus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tsetatob{\trg{r_1}}{\trg{r_2}}$
\item $\txjmp{\trg{r_1}}{\trg{r_1}}$
\item $\tcseal{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\tsplice{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\scall[o]{}{r_1}{r_2}$
\end{enumerate}

\paragraph{Case: $\protect\tfail$}

\paragraph{Case: $\protect\thalt$}

\paragraph{Case: $\protect\tjmp{\trg{r}}$}

\paragraph{Case: $\protect\tjnz{\trg{r}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tisptr{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tgeta{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tgetb{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tgete{\trg{r}}{\trg{r}}\mid$}

\paragraph{Case: $\protect\tgetlin{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tmove{\trg{r}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tstore{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tload{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tcca{\trg{r}}{\trg{\rn}}$}

\paragraph{Case: $\protect\trestrict{\trg{r}}{\trg{r}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tlt{\trg{r}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tplus{\trg{r}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tminus{\trg{r}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsetatob{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\scall[o]{}{r_1}{r_2}$}
In case $\scall[o]{}{r_1}{r_2}$ is the first step of the execution. We can assume $r_1,r_2 \neq \pcreg$ as this would cause the execution to fail\footnote{{\color{red} TODO:} We still have to consider what happens if the temp register is jumped to.}. By assumption, $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ which in particular means that for suitable $W_{R,1}$ and $W_{R,2}$
\[
  \npair[n']{(\src{\reg_S}(r_i),\reg_T(r_i))} \in \lrv(W_{r,1}) \text{ for i = 1,2}
\]
We can further deduce that $\src{\reg_S}(r_i)$ for $i=1,2$ are sealed capabilities as the execution would otherwise fail. This gives us
\[
  \begin{array}{l}
    \forall W' \future W_{R,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}
\]
At this point we need to pick a suitable $W' \future W_{R,1}$. To this end, we need to know a bit about $W_{R,1}$. From the operational semantics, we know $\Phi_S(\rstk) = \stkptr{\perm,\baddr_\stk,\eaddr_\stk,\aaddr_\stk}$ and by assumption $\Phi_S(\rstk) \in \lrv(W_{R,\stk})$. From this we can conclude that there is a stack region (specifically a spatially owned region) $r$ for which $W_{R,\stk} \nequal[n'-1] \stdreg{[\baddr_\stk',\eaddr_\stk']}{\spa}$ where $[\baddr_\stk',\eaddr_\stk'] \supseteq [\baddr_\stk,\eaddr_\stk]$\footnote{Actually concluding this involves knowing that $W_{R,\stk}$ is ``well-formed'' which we use the heap satisfaction assumption to conclude. Perhaps a notion of well-formed worlds would be good along with a couple of lemmas that use it to make this reasoning once and for all.}. As $W_{R,\stk} \oplus W_{R,1}$ is well-formed, $W_{R,1}(r)$ must be a similar spatial region to the one in $W_{R,\stk}$.
We pick $W'$ to be
\[
  \begin{array}{r l}
    W' = W     & \updReg{r}{\revoked}\\
               & \updReg{z}{\stdreg{[\baddr_\stk',\aaddr_\stk -1]}{\spa}}\\
               & \updReg{y}{\stdreg{[\aaddr_\stk,\eaddr_\stk']}{\spa}}
  \end{array}
\]
where $x$ and $y$ are fresh region names. To indicate similar worlds to $W'$ with the same ownership as another world well-defined w.r.t. $W$, we write $W'_{R,1}$ with the same spatially owned region as $W_{R,1}$. Using the private part of the future world relation, it is easy to see that $W'$ is a future world of $W_{R,1}$ (by the operational semantics $\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk$). Using world monotonicity of $H_\sigma \; \sigma$\footnote{{\color{red}This means that $H_\sigma$ must be monotone in the world!}}, we get
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W'_{R,2}
\]
which we use to get:
\[
  \npair[n'']{\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2)} \in \lrexj(W_{R,1}' \oplus W_{R,2}')
\]
In order to use this, we need to pick a register-file pair and suitable memories. We pick a $\Phi_S$ in $\lrexj$, so the $\Phi_S'$ in $\lrexj$ becomes the $\Phi_S'$ we assumed $\Phi_S$ steps to. Specifically
\[
  \Phi_S.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_S(r_1)}}\\
    \update{r_2}{\linCons{\Phi_S(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk}\\
    \update{\rretc}{c_{\ret,c}}\\
    \update{\rretd}{c_{\ret,d}}\\
    \update{\rtmp{1}}{0}\\
  \end{array}
\]
where
\begin{itemize}
\item $c_\stk = \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1}$
\item $c_{\ret,c} = \retptrc(\sigma',(\perm,\lin),\baddr,\eaddr,\aaddr+\calllen))$
\item $c_{\ret,d} = \retptrd(\sigma',(\aaddr_\stk,\eaddr_\stk))$
\end{itemize}
and
$\ms_S,((\dots,\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}) :: \stk),\ms_\stk|_{[\baddr_\stk,\aaddr_\stk-1]}$

For the target side, we pick the register-file
\[
  \Phi_T.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_T(r_1)}}\\
    \update{r_2}{\linCons{\Phi_T(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk'}\\
    \update{\rretc}{c_{\ret,c}'}\\
    \update{\rretd}{c_{\ret,d}'}\\
    \update{\rtmp{1}}{0}\\
  \end{array}  
\]
where
\begin{itemize}
\item $c_\stk' = ((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1)$
\item $c_{\ret,c}' = \sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)}$
\item $c_{\ret,d}' = \sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)}$
\end{itemize}
\lau{We do not actually check the linearity of the stack, but it should have been checked that the base address actually is the stack base address which would give us that it is linear. This is not an assumption we have formally stated at the moment!}
and the same memory
\[
  \Phi_T.\ms_T\update{\aaddr_\stk}{42}
\]
We have to argue (1) that this register-file pair is in the register-file relation for a world $W_R'$ with the same ownership as $W_R$ and regions $z$ and $y$ are owned, and (2) the memory-pair satisfies the memory satisfaction relation for a world $W_M'$ (i.e. with the same ownership as $W_M$).
 
Let's start with (2). Here we use that we took a standard region and replaced by two standard regions. This means that when we split up the memory, we can reuse the same splitting og memory and world (w.r.t memory) except for the memory segment that previously satsfied the standard region in question. This memory segment, we split in two, so each piece fit with one of the new regions.

For (1), we need to consider the contents of all registers. For the registers that were not overwritten, their safety follows from the register-file relation assumption we start with along with monotonicity and non-expansiveness of the value relation. This is also the case for $r_i$, $i=1,2$ if the capability is linear and it is trivial otherwise (as it is $0$). $\rtmp{1}$ is also trivial as it is $0$. This leaves $\rstk$, $\rretc$, and $\rretd$.

For $\rstk$, we make sure the $z$ region is owned in the world we use. Now we use that we had a standard region governing the stack to get that everything on there is in the value relation. We then use the monotonicity of the value relation to conclude that everything is in the value relation in this future world which satisfies the read and write condition.

For $\rretc$ we pick $W'$ as our world. It should be the case that $H_\sigma \; \sigma' \; W''_o$ only contains one \emph{executable} pair, namely the one we consider. Let $W'' \future W$, $n''<n'$, and $(c_S',\vsc_T') \in H_\sigma \; \sigma' \; W''_o$ be given and show
\[
  \npair[n'']{(c_{\ret,c},c_S',\sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)},\sealed{\sigma',\vsc_T})}
\]
Here we can assume $(c_S',\vsc_T') \in H_\sigma \; \sigma' \;W''_o$ is a data capability\footnote{if it is not, then the execution would fail. Further, the other case we would have to consider ($c_{\reg,c}$ as the data capability) would also fail.}.\footnote{{\color{red}This suggest that $H_\sigma$ should accept only stack capabilities and specifically non-empty ones.}}


\paragraph{Case: $\protect\txjmp{r_1}{r_2}$} 
In the case $\txjmp{r_1}{r_2}$\footnote{$\pcreg$ is a corner case here. It will fail contradicting previous assumption of termination.} was executed, we know that $\Phi_S(r_1)$ and $\Phi_S(r_2)$ either points to two sealed capabilities or a return pointer pair (all other cases result in $\Phi_S \step \failed$ contradicting $\Phi_S\term[i]$). From assumption \ref{item:reg-ass} we know
\[
  \npair[n']{(\Phi_S(r_i), \Phi_T(r_i))} \in \lrv(W_{R,i}) \text{ for $i = 1,2$}
\]
where $W_{R,i}$ are partitions of the partitioning of $W_R$ we get from assumption \ref{item:reg-ass}. From the previous observation w.r.t. $\Phi_S(r_1)$ and $\Phi_S(r_2)$, we know that we are in the "sealed capability case" of $\lrv$. This in particular gives us that
\[
  \begin{array}{l}
    \forall W' \future W_{r,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}
\]
where $\Phi_T(r_2) = \sealed{\sigma,\vsc_{T,2}}$.
Now use the former with $W'=W_{R,1}$, $W_o = W_{R,2}$, and $n'' = i-1$ to get
\[
  \npair[i-1]{\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2)} \in \lrexj(W_{R,1} \oplus W_{R,2}) 
\]
Using $\lrexj$, we want to ``start from'' configuration pair $(\Phi_S,\Phi_T)$ and end up in $(\Phi_S',\Phi_T')$ where
\begin{itemize}
\item $\Phi_S' = \xjumpResult{\Phi_S(r_1)}{\Phi_S(r_2)}{\Phi_S}$
\item $\Phi_T' = \xjumpResult{\Phi_T(r_1)}{\Phi_T(r_2)}{\Phi_T}$
\end{itemize}
so we simply pick the same memory as in $\Phi_S,\Phi_T$ and the same register file but with $r_1$ and $r_2$ cleared if $\Phi(r_i)$ is linear, respectively. Using $W_M$ memory satisfaction follows from assumption \ref{item:mem-ass}. Using $W_R$ with all the ownership of regions owned by $W_{R,i}$, $i =1,2$ stripped, the register-file satisfaction follows from \ref{item:reg-ass}. Finally the $\npair[i-1]{[(\Phi_S(r_1),\Phi_T(r_1)),(\Phi_S(r_2),\Phi_T(r_2))]}\in\lrp(W_{R,1},W_{R,2})$ follows from the $\lrv$ assumption. Finally the consistency of the worlds we use follows easily.

All in all, this allows us to conclude
\[
  \npair[i-1]{\Phi_S',\Phi_T'} \in \lro
\]
From the assumption $\Phi_S\term[i]$, we get $\Phi'_S\term[i-1]$ which we use with the above to conclude $\Phi_T' \term$. By the operational semantics of $\txjmp{r_1}{r_2}$, $\Phi_T \step \Phi_T'$ with which we conclude $\Phi_T \term$.

% Now show
% \[
%   \Phi_T \term[i] \Rightarrow \Phi_S \term
% \]

\paragraph{Case: $\protect\tcseal{\trg{r}}{\trg{r}}{\trg{r}}$}

\paragraph{Case: $\protect\tsplit{\trg{r}}{\trg{r}}{\trg{r}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsplice{\trg{r}}{\trg{r}}{\trg{r}}$}

\subsubsection*{Assuming target machine terminates}
\paragraph{Case: }
In the case  is the first step of the execution,


\end{proof}
\end{document}
