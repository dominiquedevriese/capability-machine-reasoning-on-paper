\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}

\usepackage[svgnames]{xcolor}

\input{preamble}

\title{FTLR proof cases}

\begin{document}

\maketitle
\section{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[$\lrv$ mono]
  For all $n$, $w_1$, $w_2$, and $W' \future W$, if $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in \lrv(W')$.
\end{lemma}

\begin{lemma}[$\lro$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_T \nstep[j] \Phi_T' \text{ and } \npair[n-j]{(\Phi_S,\Phi_T')} \in \lro,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lro
\]
\end{lemma}

\dominique{9-3-2018: the below is a proposed generalisation of the above antireduction lemma  that I expect will hold (based on experience with similar LRs in the past).}
\begin{lemma}[$\lro$ closed under antireduction (generalised previous lemma)]
  For all $\Phi_S$, $\Phi_S'$, $\Phi_T$, $\Phi_T'$, $j_S,J_T$, $n$, if
  \begin{itemize}
  \item $\Phi_S \nstep[j_S] \Phi_S'$
  \item $\Phi_T \nstep[j_T] \Phi_T'$
  \item $\npair{(\Phi_S',\Phi_T')} \in \lro$
\end{itemize}
then
\[
  \npair[n+\min(j_S,j_T)]{(\Phi_S,\Phi_T)} \in \lro
\]
\end{lemma}


\begin{lemma}[readCondition works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\readCond{l,W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_S(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\writeCond{l,W}$
  \end{itemize}
  Then $\memSat{(\ms_S[a\mapsto 0],\stk,\ms_\stk,\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\readCond{l,W}$, we get an $r \in \addressable{\lin,
    \pwheap}$ and $[\baddr',\eaddr'] \supseteq [\baddr,\eaddr]$ such that $\pwheap(r)
  \nsubeq \stdreg{[\baddr',\eaddr']}{\pur}$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwheap) =
  \dom(\pwheap[W_M])$ and $\pwheap(r) \oplus \pwheap[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$ such that
  \begin{itemize}
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\memSatHeap{\ms_S,\ms_\var{T,heap}}{W_\var{heap}}$.
  \end{itemize}

  From $\memSatHeap{\ms_S,\ms_\var{T,heap}}{W_\var{heap}}$, we get an
  $R_\ms : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,heap} = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_2(R_\ms(r))$,
  $\ms_S = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_1(R_\ms(r))$,
  $\exists R_W : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \World\ldotp$
  $W_\var{heap} = \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwheap[W_\var{heap}]}, n' < n$, we have that
  $\npair[n']{R_\ms(r)} \in  \pwheap[W_\var{heap}](r).H \; \pwheap[W_\var{heap}](r).s \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwheap} \subseteq
  \activeReg{\pwheap[W_\var{heap}]}$, so $\npair[n']{R_\ms(r)} \in
  \pwheap[W_\var{heap}](r).H \; \pwheap[W_\var{heap}](r).s \; \xi^{-1}(R_W(r))$.
  Because $\pwheap(r) \nsubeq \stdreg{[\baddr',\eaddr']}{\pur}$ and $W\oplus W_M = W \oplus (W_\var{heap} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that
  also $\pwheap[W_\var{heap}](r) \nsubeq \stdreg{[\baddr',\eaddr']}{\pur}$ this
  means that also $\npair[n']{R_\ms(r)} \in
  H^{\mathrm{std}}_{[\baddr',\eaddr']}\; \xi^{-1}(R_W(r))$.

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = [\baddr',\eaddr']$ and we get a $S : [\baddr',\eaddr'] \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in [\baddr',\eaddr']} S(\aaddr)$ and $\forall \aaddr \in [\baddr',\eaddr'] \ldotp \npair[n'-1]{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.
  \dominique{TODO: get rid of n'-1 above somehow.}

  Since $a \in [b,e] \subseteq [\baddr',\eaddr']$, we have that $\npair[n'-1]{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}}' \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})$ with $W_r' = \oplus_{\aaddr \in ([\baddr',\eaddr']\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{heap}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}))\\
    &=
    \oplus_{\aaddr \in [\baddr',\eaddr']} S(\aaddr) \oplus W_{\var{heap}}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    R_W(r) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
      W_\var{heap} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\writeCond{l,W}$, then
  we get an $r' \in \addressable{\lin, \pwheap} \subseteq \activeReg{\pwheap[W_\var{heap}]}$
  and $[\baddr',\eaddr'] \supseteq [\baddr,\eaddr]$ such that
  $\pwheap(r) \nsupeq[n-1] \stdreg{[\baddr',\eaddr']}{\pur}$ and
  $\pwheap(r) \text{ is address-stratified}$. Because $W \oplus W_M$ is defined, it follows that also 
  $\pwheap[W_\var{heap}](r) \nsupeq[n-1] \stdreg{[\baddr',\eaddr']}{\pur}$ and
  $\pwheap[W_\var{heap}](r) \text{ is address-stratified}$.
  \dominique{TODO: get rid of n-1 above.}

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = [\baddr',\eaddr'] = \dom(R_\ms(r').2) = \dom(R_\ms(r').1)$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair[n']{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwheap[W_\var{heap}](r).H \;
  \pwheap[W_\var{heap}](r).s \; \xi^{-1}(W_r')$ because $\pwheap[W_\var{heap}](r)$ is address-stratified and $\pwheap[W_\var{heap}](r) \nsupeq[n-1] \stdreg{[\baddr',\eaddr']}{\pur}$.

  From this, it follows that $\memSatHeap{\ms_S\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{heap}'}$ and finally $\memSat{(\ms_S\update{a}{0},\stk,\ms_\stk,\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{definition}[purePart]
  For any world $W$, we define
  \begin{align*}
    \purePart{W} &\defeq (\purePart{\pwheap},\purePart{\pwpriv},\purePart{\pwfree})\\
    \purePart{W_\var{heap}} &\defeq
                       \begin{cases}
                         W_{\var{heap}}(r) & \text{if } W_\var{heap}(r) = (pure,\var{sm})\\
                         (\spatial,\var{sm}) & \text{if } W_\var{heap}(r) = (\spatial,\var{sm})\\
                         (\spatial,\var{sm}) & \text{if } W_\var{heap}(r) = (\spatialo,\var{sm})\\
                         \revoked & \text{if } W_\var{heap}(r) = \revoked\\
                       \end{cases}\\
    \purePart{W_\var{priv}} &\defeq
                       \begin{cases}
                         ((\spatial,\var{sm}),\sigma) & \text{if } W_\var{priv}(r) = ((\spatial,\var{sm}),\sigma)\\
                         ((\spatial,\var{sm}),\sigma) & \text{if } W_\var{priv}(r) = ((\spatialo,\var{sm}),\sigma)\\
                         (\revoked,\sigma) & \text{if } W_\var{priv}(r) = (\revoked,\sigma)\\
                       \end{cases}\\
    \purePart{W_\var{free}} &\defeq
                       \begin{cases}
                         W_{\var{free}}(r) & \text{if } W_{\var{free}}(r) = (pure,\var{sm})\\
                         (\spatial,\var{sm}) & \text{if } W_{\var{free}}(r) = (\spatial,\var{sm})\\
                         (\spatial,\var{sm}) & \text{if } W_{\var{free}}(r) = (\spatialo,\var{sm})\\
                         \revoked & \text{if } W_{\var{free}}(r) = \revoked\\
                       \end{cases}
  \end{align*}
\end{definition}

\begin{lemma}[purePart is pure]
 For all $W$, we have that $W = W \oplus \purePart{W}$.
\end{lemma}

\begin{lemma}
  \label{lem:world-fut-purePart}
  For all $W$, we have that $W \future \purePart{W}$.
  \dominique{11-3-2018: Err.. this doesn't seem to hold as we don't have that $\spatialo \future \spatial$. This also means that we don't currently have that $W_1 \oplus W_2 \future W_1$. Shouldn't we?  }
\end{lemma}

\begin{lemma}[non-linear words are pure]
  \label{lem:non-linear-pure}
  If $\npair{(w_1,w_2)} \in \lrv(H_\sigma,W)$ and ($\nonLinear{w_1}$ or $\nonLinear{w_2}$), then
  $\npair{(w_1,w_2)} \in \lrv(H_\sigma,\purePart{W})$.
  \dominique{11-3-2018: proving this lemma depends on lemma~\ref{lem:world-fut-purePart} for the higher-order cases.}
\end{lemma}

\begin{lemma}[load from capability works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $\npair{(c,c)}\in\lrv(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item $w_S = \linCons{\ms_S(a)}$, $w_T = \linCons{\ms_T(a)}$
  \item $\linConsPerm{\perm}$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat{(\ms_S\update{\mem.a}{w_S},\stk,\ms_\stk,\ms_T\update{\mem.a}{w_T})}{W_M'}$
  \item $\npair{(\ms_S(a),\ms_T(a))} \in \lrv(W')$
  \end{itemize}
  \dominique{11-3-2018: this lemma depends on Lemma~\ref{lem:non-linear-pure} for the non-linear case.}
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\section{FTLR proof}
By induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
\begin{proof}
  Assume
\[
  \begin{array}{l}
  \npair{(\baddr,\eaddr)}\in \readCond{\lin,W}\\
  \npair{(\baddr,\eaddr)}\in \xReadCond{\lin,W}
  \end{array}
\]
and show
\[
\npair{((\rx,\lin),\baddr,\eaddr,\aaddr),
       ((\rx,\lin),\baddr,\eaddr,\aaddr)} \in \lre(W)
\]
We write $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{[(c,c)]} \in \lrp(W)$ 
\dominique{Weird that this is an assumption here.  Shouldn't this be a proof obligation? Or rather: I think this should not be here at all but in the value relation instead? Remove this from the definition of $\lre$?}
\lau{$(c,c)$ is not shown or assumed to be in the value relation, so to make sure it respects lineraity, this condition is placed here. Further, this does become a proof obligation when you use the FTLR.}
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is well-defined\label{item:worlds-def}
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\updReg{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\updReg{\pcreg}{c})$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S,\Phi_T)} \in \lro
\]
Let $i \leq n'$ be given \footnote{ignoring the frame...} and show
\[
  \Phi_S \term[i] \Rightarrow \Phi_T \term
\]
and 
\[
  \Phi_T \term[i] \Rightarrow \Phi_S \term
\]

\subsubsection*{Assuming source machine terminates}
First show the former of the two, assume $\Phi_S\term[i]$.
Since $\Phi_S \neq \halted$, we have that $1 \leq i \leq n'$.

We know that $\Phi_S(\pcreg) = \Phi_T(\pcreg) = c$, $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$, $\npair{(\baddr,\eaddr)}\in \readCond{\lin,W}$ and $\npair{(\baddr,\eaddr)}\in \xReadCond{\lin,W}$.
From Lemmas~\ref{lem:readcond-writecond-work}, using $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$ (from assumption~\ref{item:mem-ass}) and $W \oplus W_R \oplus W_M$ is well-defined (assumption~\ref{item:worlds-def}), we get (for any $a' \in [\baddr,\eaddr]$) that $\npair[n']{(\ms_S(a'),\ms_T(a'))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.

Since $\Phi_S \neq \halted$, this means that it must take a next execution step and also that $\Phi_S \not\step\failed$. 
This is only possible if one of the following holds:
\begin{itemize}
\item $\callCond{\Phi_S,r_1,r_2,\aaddr}$ and
  $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$ and 
  $\exec{\Phi_S(\pcreg)}$.

  In this case, we have for all $i = 0..\calllen-1$ that $\npair[n']{(\ms_S(\aaddr+i),\ms_T(\aaddr+i))} \in \lrv(W')$ for some $W'$, and also $\ms_S(\aaddr+i) \in \ints$, so by definition of $\lrv$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i)$.
\item ($\src{(\neg\callCond{\Phi_S,r_1,r_2,\aaddr}}$ or $\src{\eaddr < \aaddr + \calllen-1) \tand}$) and
  $\withinBounds{\Phi_S(\pcreg)}$ and $\exec{\Phi_S(\pcreg)}$.

  In this case, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(W')$ for some $W'$, and also $\ms_S(\aaddr) \in \ints$ (since $\Phi_S \not\step\failed$), so by definition of $\lrv$, we have that $\ms_T(\aaddr) = \ms_S(\aaddr)$.
\end{itemize}

We now consider the first step of $\Phi_S \term[i]$ (we have already mentioned that $i \geq 1$).
The possible instructions that could have been executed are:
\begin{enumerate}
\item $\tfail$
\item $\thalt$
\item $\tjmp{\trg{r_1}}$
\item $\tjnz{\trg{r_1}}{\trg{\rn}}$
\item $\tisptr{\trg{r_1}}{\trg{r_2}}$
\item $\tgeta{\trg{r_1}}{\trg{r_2}}$
\item $\tgetb{\trg{r_1}}{\trg{r_2}}$
\item $\tgetp{\trg{r_1}}{\trg{r_2}}$
\item $\tgetlin{\trg{r_1}}{\trg{r_2}}$
\item $\tmove{\trg{r_1}}{\trg{\rn}}$
\item $\tstore{\trg{r_1}}{\trg{r_2}}$
\item $\tload{\trg{r_1}}{\trg{r_2}}$
\item $\tcca{\trg{r_1}}{\trg{\rn}}$
\item $\trestrict{\trg{r_1}}{\trg{r_2}}{\trg{\rn}}$
\item $\tlt{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tplus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tminus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tsetatob{\trg{r_1}}{\trg{r_2}}$
\item $\txjmp{\trg{r_1}}{\trg{r_1}}$
\item $\tcseal{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\tsplice{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\scall[o]{}{r_1}{r_2}$
\end{enumerate}

\paragraph{Case: $\protect\tfail$}
Contradiction, because then $\Phi_S \step \failed \not\nstep[i-1] \halted$.

\paragraph{Case: $\protect\thalt$}
In this case $\Phi_S \step \halted$.
We've seen above that $\ms_T(\aaddr) = \ms_S(\aaddr)$, so because $\decInstr{}$ is shared by source and target, we have that $\Phi_T \step\halted$.

\paragraph{Case: $\protect\tjmp{\trg{r_1}}$}

\paragraph{Case: $\protect\tjnz{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tisptr{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\protect\tgeta{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgetb{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgete{\trg{r_1}}{\trg{r_2}}\mid$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgetlin{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tmove{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tstore{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\protect\tload{\trg{r_1}}{\trg{r_2}}$}
Since $\Phi_S\not\step\failed$, we have that $\Phi_S \step \Phi_S' \term[i-1]$ and one of the following cases hold: 
\begin{itemize}
\item \[\Phi_S' = \updPcAddr{\Phi\update{\mem.a}{w_2}\updReg{r_1}{w}}\]
  with $\Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ 
  $\perm \in \readAllowed{}$, $\withinBounds{\Phi(r_2)}$, $w = \Phi.\mem(a)$ and $w_2 = \linCons{w}$ and $\linConsPerm{w,\perm}$
\item \[\Phi_S' = \updPcAddr{\Phi \update{\ms_\stk.a}{w_2}\updReg{r_1}{w}}\]
  with $\Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $\perm \in \readAllowed{}$, $\withinBounds{\Phi(r_2)}$, $\aaddr \in \dom(\Phi.\ms_\stk)$, $w = \Phi.\ms_\stk(a)$ and $w_2 = \linCons{w}$ and $\linConsPerm{w,\perm}$
\end{itemize}

\paragraph{Case: $\protect\tcca{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\trestrict{\trg{r_1}}{\trg{r_2}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tlt{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tplus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tminus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsetatob{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\scall[o]{}{r_1}{r_2}$}
In case $\scall[o]{}{r_1}{r_2}$ is the first step of the execution. We can assume $r_1,r_2 \neq \pcreg$ as this would cause the execution to fail\footnote{Assuming $\pcreg$ was one of the two registers, then the step relation would reqiure the register to contain an executable capability while the call semantics would require there to be a sealed capability.}\footnote{{\color{red} TODO:} We still have to consider what happens if the temp register is jumped to.}. By assumption, $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ which in particular means that for suitable $W_{R,1}$ and $W_{R,2}$
\[
  \npair[n']{(\src{\reg_S}(r_i),\reg_T(r_i))} \in \lrv(W_{r,1}) \text{ for i = 1,2}
\]
We can further deduce that $\src{\reg_S}(r_i)$ for $i=1,2$ are sealed capabilities as the execution would otherwise fail. This gives us
\[
  \begin{array}{l}
    \forall W' \future W_{R,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}
\]
At this point, we need to pick a suitable $W' \future W_{R,1}$. To this end, we need to know a bit about $W_{R,1}$. From the operational semantics, we know $\Phi_S(\rstk) = \stkptr{\perm,\baddr_\stk,\eaddr_\stk,\aaddr_\stk}$ and by assumption $\Phi_S(\rstk) \in \lrv(W_{R,\stk})$. From this we can conclude that there is a stack region (specifically a spatially owned region) $r$ for which $W_{R,\stk} \nequal[n'-1] \stdreg{[\baddr_\stk',\eaddr_\stk']}{\spa}$ where $[\baddr_\stk',\eaddr_\stk'] \supseteq [\baddr_\stk,\eaddr_\stk]$\footnote{Actually concluding this involves knowing that $W_{R,\stk}$ is ``well-formed'' which we use the heap satisfaction assumption to conclude. Perhaps a notion of well-formed worlds would be good along with a couple of lemmas that use it to make this reasoning once and for all.}. As $W_{R,\stk} \oplus W_{R,1}$ is well-formed, $W_{R,1}(r)$ must be a similar spatial region to the one in $W_{R,\stk}$.
We pick $W'$ to be
\[
  \begin{array}{r l}
    W' = W     & \update{\mathrm{free}.r}{\revoked}\\
               & \update{\mathrm{free}.x}{\stdreg{[\baddr_\stk',\aaddr_\stk -1]}{\spa}}\\
               & \update{\mathrm{priv}.y}{(\stdreg{[\aaddr_\stk,\eaddr_\stk']}{\spa},\opc)}
  \end{array}
\]
\lau{12-05-2018: Write what $\opc$ is.}
where $x$ and $y$ are fresh region names in the respective part of the world. To indicate similar worlds to $W'$ with the same ownership as another world well-defined w.r.t. $W$, we write $W'_{R,1}$ with the same spatially owned region as $W_{R,1}$. Using the private part of the future world relation, it is easy to see that $W'$ is a future world of $W_{R,1}$ (by the operational semantics $\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk$). Using world monotonicity of $H_\sigma \; \sigma$\footnote{{\color{red}This means that $H_\sigma$ must be monotone in the world!}}, we get
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W'_{R,2}
\]
which we use to get:
\[
  \npair[n'']{\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2)} \in \lrexj(W_{R,1}' \oplus W_{R,2}')
\]
In order to use this, we need to pick a register-file pair and suitable memories. We pick a $\Phi_S$ in $\lrexj$, so the $\Phi_S'$ in $\lrexj$ becomes the $\Phi_S'$ we assumed $\Phi_S$ steps to. Specifically
\[
  \Phi_S.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_S(r_1)}}\\
    \update{r_2}{\linCons{\Phi_S(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk}\\
    \update{\rretc}{c_{\ret,c}}\\
    \update{\rretd}{c_{\ret,d}}\\
    \update{\rtmp{1}}{0}\\
  \end{array}
\]
where
\begin{itemize}
\item $c_\stk = \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1}$
\item $c_{\ret,c} = \retptrc(\sigma',(\perm,\lin),\baddr,\eaddr,\aaddr+\calllen))$
\item $c_{\ret,d} = \retptrd(\sigma',(\aaddr_\stk,\eaddr_\stk))$
\end{itemize}
and
$\ms_S,((\opc,\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}) :: \stk),\ms_\stk-\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}$

For the target side, we pick the register-file
\[
  \Phi_T.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_T(r_1)}}\\
    \update{r_2}{\linCons{\Phi_T(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk'}\\
    \update{\rretc}{c_{\ret,c}'}\\
    \update{\rretd}{c_{\ret,d}'}\\
    \update{\rtmp{1}}{0}\\
  \end{array}  
\]
where
\begin{itemize}
\item $c_\stk' = ((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1)$
\item $c_{\ret,c}' = \sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)}$
\item $c_{\ret,d}' = \sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)}$
\end{itemize}
\lau{We do not actually check the linearity of the stack, but it should have been checked that the base address actually is the stack base address which would give us that it is linear. This is not an assumption we have formally stated at the moment!}
and the same memory
\[
  \Phi_T.\ms_T\update{\aaddr_\stk}{42}
\]
We have to argue (1) that this register-file pair is in the register-file relation for a world $W_R'$ with the same ownership as $W_R$ and regions $z$ and $y$ are owned, and (2) the memory-pair satisfies the memory satisfaction relation for a world $W_M'$ (i.e. with the same ownership as $W_M$).
 
Let's start with (2). Here we use that we took a standard region and replaced by two standard regions. This means that when we split up the memory, we can reuse the same splitting og memory and world (w.r.t memory) except for the memory segment that previously satsfied the standard region in question. This memory segment, we split in two, so each piece fit with one of the new regions.

For (1), we need to consider the contents of all registers. For the registers that were not overwritten, their safety follows from the register-file relation assumption we start with along with monotonicity and non-expansiveness of the value relation. This is also the case for $r_i$, $i=1,2$ if the capability is linear and it is trivial otherwise (as it is $0$). $\rtmp{1}$ is also trivial as it is $0$. This leaves $\rstk$, $\rretc$, and $\rretd$.

For $\rstk$, we make sure the $z$ region is owned in the world we use. Now we use that we had a standard region governing the stack to get that everything on there is in the value relation. We then use the monotonicity of the value relation to conclude that everything is in the value relation in this future world which satisfies the read and write condition.

For $\rretc$ we pick $W'$ as our world. It should be the case that $H_\sigma \; \sigma' \; W''_o$ only contains one \emph{executable} pair, namely the one we consider. Let $W'' \future W$, $n''<n'$, and $(c_S',\vsc_T') \in H_\sigma \; \sigma' \; W''_o$ be given and show
\[
  \npair[n'']{(c_{\ret,c},c_S',\sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)},\sealed{\sigma',\vsc_T})} \in \lrexj(W'')
\]
Here we can assume $(c_S',\vsc_T') \in H_\sigma \; \sigma' \;W''_o$ is a data capability pair\footnote{if it is not, then the execution would fail. Further, the other case we would have to consider ($c_{\reg,c}$ as the data capability) would also fail.}.\footnote{{\color{red}This suggest that $H_\sigma$ should accept only stack capabilities and specifically non-empty ones.}}

{\color{DarkRed}
  A this point, we would like to use the induction hypothesis with the assumptions we get from $\lrexj$. That is, we use the induction hypothesis to (hopefully) get

\[
  \npair[n'']{((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots),((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen)} \in \lre(W'')
\]
(notice that the target has ``caught up'' here.) The assumptions we get from $\lrexj(W'')$ are not synced, so this would indicate that we need the target side to catch up.
}

\paragraph{Case: $\protect\txjmp{r_1}{r_2}$} 
In the case $\txjmp{r_1}{r_2}$\footnote{$\pcreg$ is a corner case here. It will fail contradicting previous assumption of termination.} was executed, we know that $\Phi_S(r_1)$ and $\Phi_S(r_2)$ either points to two sealed capabilities or a return pointer pair (all other cases result in $\Phi_S \step \failed$ contradicting $\Phi_S\term[i]$). From assumption \ref{item:reg-ass} we know
\[
  \npair[n']{(\Phi_S(r_i), \Phi_T(r_i))} \in \lrv(W_{R,i}) \text{ for $i = 1,2$}
\]
where $W_{R,i}$ are partitions of the partitioning of $W_R$ we get from assumption \ref{item:reg-ass}. From the previous observation w.r.t. $\Phi_S(r_1)$ and $\Phi_S(r_2)$, we know that we are in the "sealed capability case" of $\lrv$. This in particular gives us that
\[
  \begin{array}{l}
    \forall W' \future W_{r,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}
\]
where $\Phi_T(r_2) = \sealed{\sigma,\vsc_{T,2}}$.
Now use the former with $W'=W_{R,1}$, $W_o = W_{R,2}$, and $n'' = i-1$ to get
\[
  \npair[i-1]{\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2)} \in \lrexj(W_{R,1} \oplus W_{R,2}) 
\]
Using $\lrexj$, we want to ``start from'' configuration pair $(\Phi_S,\Phi_T)$ and end up in $(\Phi_S',\Phi_T')$ where
\begin{itemize}
\item $\Phi_S' = \xjumpResult{\Phi_S(r_1)}{\Phi_S(r_2)}{\Phi_S}$
\item $\Phi_T' = \xjumpResult{\Phi_T(r_1)}{\Phi_T(r_2)}{\Phi_T}$
\end{itemize}
so we simply pick the same memory as in $\Phi_S,\Phi_T$ and the same register file but with $r_1$ and $r_2$ cleared if $\Phi(r_i)$ is linear, respectively. Using $W_M$ memory satisfaction follows from assumption \ref{item:mem-ass}. Using $W_R$ with all the ownership of regions owned by $W_{R,i}$, $i =1,2$ stripped, the register-file satisfaction follows from \ref{item:reg-ass}. Finally the $\npair[i-1]{[(\Phi_S(r_1),\Phi_T(r_1)),(\Phi_S(r_2),\Phi_T(r_2))]}\in\lrp(W_{R,1},W_{R,2})$ follows from the $\lrv$ assumption. Finally the consistency of the worlds we use follows easily.

All in all, this allows us to conclude
\[
  \npair[i-1]{\Phi_S',\Phi_T'} \in \lro
\]
From the assumption $\Phi_S\term[i]$, we get $\Phi'_S\term[i-1]$ which we use with the above to conclude $\Phi_T' \term$. By the operational semantics of $\txjmp{r_1}{r_2}$, $\Phi_T \step \Phi_T'$ with which we conclude $\Phi_T \term$.

% Now show
% \[
%   \Phi_T \term[i] \Rightarrow \Phi_S \term
% \]

\paragraph{Case: $\protect\tcseal{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$}

\paragraph{Case: $\protect\tsplit{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsplice{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$}

\subsubsection*{Assuming target machine terminates}
\dominique{I suspect it would be more economical to not treat this case separately from the above (source machine terminates), but rather prove both results simultaneously by induction on the length of the terminating execution.}
\paragraph{Case: }
In the case  is the first step of the execution,


\end{proof}
\end{document}
