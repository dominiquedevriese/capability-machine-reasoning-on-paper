\subsection{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[Downwards closure of relations]
  \label{lem:downwards-closed}
  If $n' \leq n$, then
  \begin{itemize}
  \item If $\npair{A} \in \readCond{\lin,W}$, then $\npair[n']{A} \in \readCond{\lin,W}$.
  \item If $\npair{A} \in \stackReadCond{\lin,W}$, then $\npair[n']{A} \in \stackReadCond{\lin,W}$.
  \item If $\npair{A} \in \writeCond{\lin,W}$, then $\npair[n']{A} \in \writeCond{\lin,W}$.
  \item If $\npair{A} \in \stackWriteCond{\lin,W}$, then $\npair[n']{A} \in \stackWriteCond{\lin,W}$.
  \item If $\npair{A} \in \execCond{\lin,W}$, then $\npair[n']{A} \in \execCond{\lin,W}$.
  \item If $\npair{A} \in \xReadCond{W}$, then $\npair[n']{A} \in \xReadCond{W}$.
  \item If $\npair{(w,w')} \in \lrvg{\trust}(W)$, then $\npair[n']{(w,w')} \in \lrvg{\trust}(W)$.
  \item If $\npair{(w,w')} \in \lrrg{\trust}(W)$, then $\npair[n']{(w,w')} \in \lrrg{\trust}(W)$.
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$, then also $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$.
  \end{itemize}
\end{lemma}

\begin{lemma}[Non-expansiveness of relations]
  \label{lem:non-expansiveness}
  If $W \nequal W'$, then
  \begin{itemize}
  \item $\xReadCond{W} \nequal \xReadCond{W'}$.
  \item If $\stackReadCond{\lin,W} \nequal \stackReadCond{\lin,W'}$.
  \item If $\writeCond{\lin,W} \nequal \writeCond{\lin,W'}$.
  \item If $\stackWriteCond{\lin,W} \nequal \stackWriteCond{\lin,W'}$
  \item If $\execCond{\lin,W} \nequal \execCond{\lin,W'}$.
  \item If $\xReadCond{W} \nequal \xReadCond{W'}$.
  \item If $\lrvg{\trust}(W) \nequal \lrvg{\trust}(W')$.
  \item If $\lrrg{\trust}(W) \nequal \lrrg{\trust}(W')$.
  \item For all $n' \le n$, $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$ iff $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W'}$.
  \item ...
  \end{itemize}
\end{lemma}

\begin{lemma}[World monotonicity of relations]
  \label{lem:monotonicity}
  For all $n$, $W' \future W$, we have that
  \begin{itemize}
  \item If $(w_1,w_2) \in H_\sigma~\sigma~W$, then $(w_1,w_2) \in H_\sigma~\sigma~W'$.
    \lau{This should hold for any valid $H_\sigma$, but we need to prove it for specific instantiations.}
  \item If $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in
    \lrv(W')$.
  \item If $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap(\pwheap[W_1])(W)$, then $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in
    \lrheap(\pwheap[W_1])(W')$.
\end{itemize}
\end{lemma}
\begin{proof}
  Follows from the definitions.
  Note: the proof for $\lrheap$ relies on Lemma~\ref{lem:oplus-future-distr}.
\end{proof}

\begin{lemma}[$\lror$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_T \nstep[j]{} \Phi_T' \text{ and } \npair[n-j]{(\Phi_S,\Phi_T')} \in \lror,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lror
\]
\end{lemma}

\begin{lemma}[$\lrol$ closed under source language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_S \nstep[j]{\gc} \Phi_S' \text{ and } \npair[n-j]{(\Phi_S',\Phi_T)} \in \lrol,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lrol
\]
\end{lemma}


\dominique{9-3-2018: the below is a proposed generalisation of the above antireduction lemma  that I expect will hold (based on experience with similar LRs in the past).}
\begin{lemma}[$\lro$ closed under antireduction (generalised previous lemma)]
  \label{lem:lro-anti-red-gen}
  For all $\Phi_S$, $\Phi_S'$, $\Phi_T$, $\Phi_T'$, $j_S,j_T$, $n$, if
  \begin{itemize}
  \item $\Phi_S \nstep[j_S]{\gc} \Phi_S'$
  \item $\Phi_T \nstep[j_T]{} \Phi_T'$
  \item $\npair{(\Phi_S',\Phi_T')} \in \lro$
\end{itemize}
then
\[
  \npair[n+\min(j_S,j_T)]{(\Phi_S,\Phi_T)} \in \lro
\]
\end{lemma}


\begin{lemma}[readCondition works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\readCond{l,W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_S(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\writeCond{l,W}$
  \end{itemize}
  Then $\memSat{(\ms_S[a\mapsto 0],\stk,\ms_\stk,\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\readCond{l,W}$, we get an $S \subseteq \addressable{\lin,
    \pwheap}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwheap(r).H
  \nsubeq \stdreg{R(r),\gc}{\pur}.H$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwheap) =
  \dom(\pwheap[W_M])$ and $\pwheap(r) \oplus \pwheap[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(W_M)(W_\var{heap})$.
  \end{itemize}

  From $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(W_M)(W_\var{heap})$, we get an
  $R_\ms : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,heap} = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_2(R_\ms(r))$,
  $\ms_S = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_1(R_\ms(r))$,
  $\exists R_W : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \World\ldotp$
  $W_\var{heap} = \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwheap[W_M]}$, we have that
  $\npair{R_\ms(r)} \in  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.
  We also get an $R_\var{seal} : \dom(\activeReg{\pwheap}) \fun \powerset{\Seal}$ such that  $\biguplus_{r \in \dom(\activeReg{\pwheap})} R_\var{seal}(r)) \subseteq \overline{\sigma}$ and $\dom(\pwheap(r).H_\sigma) = R_\var{seal}(r)$.

  We have that $r \in \addressable{\lin, \pwheap} \subseteq
  \activeReg{\pwheap[W_\var{heap}]}$, so $\npair{R_\ms(r)} \in
  \pwheap[W_M](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwheap(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$ and $W\oplus W_M$ is defined, it follows that
  also $\pwheap[W_M](r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}}' \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{heap}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{heap}}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    R_W(r) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
      W_\var{heap} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\writeCond{l,W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwheap} \subseteq \activeReg{\pwheap[W_M]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ such that
  for all $r \in S'$, $\pwheap(r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$ and
  $\pwheap(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwheap[W_M](r').H \nsupeq \stdreg{R'(r'),\gc}{\pur}.H$ and
  $\pwheap[W_M](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $\dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwheap[W_\var{heap}](r).H \; \xi^{-1}(W_r')$ because $\pwheap[W_M](r)$ is address-stratified and $\pwheap[W_M](r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$.

  From this, it follows that $\npair{(\overline{\sigma},\ms_S\update{a}{0},\ms_\var{T,heap}\update{a}{0})} \in \lrheap(W_M)(W_r' \oplus W_\var{heap}')$ and finally $\npair{(\overline{\sigma},\ms_S\update{a}{0},\stk,\ms_\stk,\ms_T\update{a}{0})} \in \lrheap(W_M')(W_r' \oplus W_{\var{heap}}')$.
\end{proof}

\begin{lemma}[stackReadCondition works]
  \label{lem:stackreadcond-stackwritecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\stackReadCond{W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\stackWriteCond{W}$
  \end{itemize}
  Then $\memSat{(\ms_S,\stk,\ms_\stk[a\mapsto 0],\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\stackReadCond{W}$, we get an $S \subseteq \addressable{\lin,
    \pwfree}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwfree(r).H
  \nsubeq \stdreg{R(r),\gc}{\pur}.H$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwfree) =
  \dom(\pwfree[W_M])$ and $\pwfree(r) \oplus \pwfree[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})}\in\lrheap(\pwheap[W_M])(W_\var{heap})$.
  \end{itemize}

  From $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$, we get an
  $R_\ms : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,free\_stack} = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_2(R_\ms(r))$,
  $\ms_\stk = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_1(R_\ms(r))$,
  $\stkb \in \dom(\ms_\var{T,free\_stack}) \wedge \stkb \in \dom(\ms_\stk)$,
  $\exists R_W : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \World\ldotp$
  $W_\var{free\_stack} = \oplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwfree[W_\var{free\_stack}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwfree} \subseteq \activeReg{\pwfree[W_\var{free\_stack}]}$, so $\npair{R_\ms(r)} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwfree(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$ and $W\oplus W_M = W \oplus (W_\var{free\_stack} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that also $\pwfree[W_\var{free\_stack}](r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$.
  This means that also $\npair{R_\ms(r)} \in H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}')$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{free\_stack}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_\var{heap}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_{\var{heap}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    R_W(r) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{free\_stack}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
    &=
      W_\var{free\_stack} \oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\stackWriteCond{W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwfree} \subseteq \activeReg{\pwheap[W_\var{free\_stack}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ and
  for all $r \in S'$, $\pwfree(r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$ and
  $\pwfree(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwfree[W_\var{free\_stack}](r').H \nsupeq \stdreg{R'(r'),\gc}{\pur}.H$ and
  $\pwfree[W_\var{free\_stack}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $ \dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(W_r')$ because $\pwfree[W_\var{free\_stack}](r)$ is address-stratified and $\pwfree[W_\var{free\_stack}](r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$.

  From this, it follows that $\memSatFStack{\ms_\stk\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{free\_stack}'}$ and finally $\memSat{(\ms_S,\stk,\ms_\stk\update{a}{0},\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[load from regular capability works]
  \label{lem:readcond-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$, $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrv(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, $\perm \in \readAllowed{}$ and $\perm' \in \readAllowed{}$, we get that $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$.

  Lemma~\ref{lem:readcond-writecond-work} then gives us a $W'$ and $W_M'$ such that $W_M = W' \oplus W_M'$ and $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$.
  
  it remains to prove that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_S(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm,\perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrv(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \writeCond{\lin,W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:downwards-closed}, we then get that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.

  \item case $\neg\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = \ms_S(\aaddr)$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?}
    and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by downwards closure of memory satisfaction, i.e.~Lemma~\ref{lem:downwards-closed}.
  \end{itemize}
\end{proof}

\begin{lemma}[load from stack capability works]
  \label{lem:load-stack-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item ($\aaddr \in [\baddr,\eaddr]$ or $\aaddr' \in [\baddr',\eaddr']$)
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, ($\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$), we get that $\perm = \perm'$, $\lin' = \linear$, $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \stackReadCond{W}$.

  From Lemma~\ref{lem:stackreadcond-stackwritecond-work}, we then get that $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  

  It remains to prove that $\memSat{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_\stk(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm = \perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \stackWriteCond{W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:downwards-closed}, we then get that $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{0},\ms_T\update{\aaddr'}{0})}{W_M'}$.

  \item case $\neg\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = \ms_\stk(\aaddr)$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?}
    and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by downwards closure of memory satisfaction, i.e.\ Lemma~\ref{lem:downwards-closed}.
  \end{itemize}
\end{proof}

\subsection{FTLR proof}
By induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
\begin{proof}
  Assume
  \begin{itemize}
  \item $\trust = \trusted \vee \npair{[\baddr,\eaddr]} \in \readCond{\lin,W}$
  \item $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$
  \end{itemize}
  and one of the following sets of requirements holds:
  \begin{enumerate}[label={\roman*)}]
  \item \begin{itemize}
    \item $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \trusted$
    \item For all $\npair{\stpair{\reg}{\reg}} \in \lrrtrusted(W)$ and $\memSat{\src{\ms_S},\src{\ms_\stk},\src{\stk},\ms_T}{W}$ and $\ms_f$, we have $\src{\Phi} = (\src{\ms_S} \uplus \ms_f, \src{reg_S}, \src{\stk}, \src{\ms_\stk})$ and 
      \begin{itemize}           
      \item $\src{\Phi}$ checks $\stkb$ before calls in $\ta$ (Definition~\ref{def:check-stack-addr-before-call}).
      \item $\src{\Phi}$ uses link seals properly in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ (Definition~\ref{def:use-return-seals-call}).
      \item $\src{\Phi}$ handle trusted seals properly in $\ta$ with components parameters $\sigrets$ and $\sigcloss$ (Definition~\ref{def:handle-trusted-seals-properly}).
      \item $\src{\Phi}$ does not store link seals and code capabilities in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ (Definition~\ref{def:never-store-seal-code-cap}).
      \end{itemize}
    \end{itemize}
  \item
    \begin{itemize}
    \item $[\baddr,\eaddr] \mathrel{\#} \ta$
    \item $\trust = \untrusted$
    \end{itemize}
  \end{enumerate}
and show
\[
\npair{(c,c)} \in \lreg{\trust}(W)
\]
For $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrrg{\trust}(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is well-defined\label{item:worlds-def}
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\update{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\update{\pcreg}{c})$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S,\Phi_T)} \in \lro
\]
In order to do this, we first, we prove that one of the following holds:
\lau{TODO: add $\neq$ failed to the cases that are not failed.}
\begin{enumproof}
  \item \label{case:ftlr:failed} $\Phi_S \step[\gc] \failed$ and $\Phi_T
    \step[i] \failed$ for some $i$.
  \item \label{case:ftlr:halted} $\Phi_S \step[\gc] \halted$ and $\Phi_T \step\halted$
  \item \label{case:ftlr:get-and-arith-op} All of the following hold: (includes simple cases: gettype, geta, getb,
    gete, getp, getl, lt, plus, minus, one case of move that can be handled
    uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r}{z}} \neq \failed$
    \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r}{z}} \neq \failed$
    \item $z \in \ints$
    \end{itemize}
  \item \label{case:ftlr:call} All of the following hold:
    \begin{itemize}
    \item $\callCond{\Phi_S,r_1,r_2,\aaddr}$
    \item $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$
    \item $\exec{\Phi_S(\pcreg)}$
    \item for all $i = 0..\calllen-1$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i) \in \ints$.
    \item $[\baddr,\eaddr] \subseteq \ta$
    \item $\Phi_S \step[\gc] \Phi_S' \neq \failed$
    \item $\Phi_T \step \Phi_T' \neq \failed$
    \item $\Phi_T' = \updPc{\Phi_T\updReg{\rtmp{1}}{z}}$
    \item $z \in \ints$
    \item $\Phi_S(r_1) = \sealed{\sigma,c_1}$
    \item $\Phi_S(r_2) = \sealed{\sigma,c_2}$
    \item $\nonExec{c_2}$
    \item $\Phi_S(\stk) = \stkptr{\rw, \baddr_\stk, \eaddr_\stk, \aaddr_\stk}$
    \item $\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk$
    \item $\Phi_S(\pcreg) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
    \item $w_1 = \linCons{c_1}$ and $w_2 = \linCons{c_2}$
    \item \[
        \begin{split}
          \Phi_S''.\reg = \Phi_S.reg      &[\rstk \mapsto \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1}] \\
          &[\rretc \mapsto \sealed{\sigma',\retptrc(\baddr,\eaddr,\aaddr+\calllen)}]\\
          &[\rretd \mapsto \sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)}] \\
          &[r_1,r_2 \mapsto w_1,w_2] \\
          &[\rtmp{1} \mapsto 0]
        \end{split}
      \]
    \item $\Phi_S''.\mem = \Phi_S.\mem$
    \item $\ms_{\stk\_\priv,S} = \Phi_S.\ms_\stk |_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}$
    \item $\Phi_S''.\stk = ((\aaddr+\calllen),\ms_{\stk\_\priv,S}) :: \Phi_S.\stk$
    \item $\Phi_S''.\ms_\stk = \Phi_S.\ms_\stk -
      \Phi_S.\ms_\stk|_{\aaddr_\stk,\eaddr_\stk}$
    \item $\baddr \leq \aaddr+\offpc \leq \eaddr$
      \lau{TODO: Need to have an explicit $\offpc$.}
    \item $\mem(\aaddr+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma_\aaddr}$
    \item $\sigma' = \sigma_\aaddr + \offsigma$
    \item $\sigma_\aaddr \leq \sigma' \leq \sigma_\eaddr$
      
    \item $\Phi_S' =\var{xjumpResult}\left(c_1,c_2, \Phi_S' \right)$

    \end{itemize}
  \item All of the following hold: (includes cap-manipulation cases: move, cca,
    restrict, seta2b, cseal, split, splice, that can be handled mostly
    uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1\cdots r_k}{w_1\cdots w_k}}\neq
      \failed$
    \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1\cdots r_k}{w_1'\cdots w_k'}}
      \neq \failed$
    \item One of the following holds:
      \begin{enumproof}
      \item (restrict,cca,seta2b) $w_1 = ((\perm',\lin),\baddr,\eaddr,\aaddr')$,
        $w_1' = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi_T(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k =
        1$
      \item (restrict,cca,seta2b) $w_1 = \stkptr{\perm',\baddr,\eaddr,\aaddr'}$,
        $w_1' = ((\perm',\linear),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $\Phi_T(r_1) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$,
        $k = 1$
      \item (cca,seta2b) $w_1 = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$,
        $w_1' = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$, $\Phi_S(r_1) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$ and $\Phi_T(r_1) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$, $k = 1$
      \item (move) $w_1 = \Phi_S(r_1)$, $w_1' = \Phi_S(r_1)$, and
        $\isLinear{w_1} \Rightarrow w_2 = w_2' = 0$, and $\neg \isLinear{w_1}
        \Rightarrow (w_2 = \Phi_S(r_2) \wedge w_2' = \Phi_T(r_2)$) and $k = 2$.
      \item (cseal) $w_1 = \sealed{\sigma,\Phi_S(r_1)}$, $w_1' =
        \sealed{\sigma,\Phi_T(r_1)}$, $\Phi_S(r_2) = \Phi_T(r_2) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $k=1$
      \item (split) $\Phi_T(r_3) = \Phi_S(r_3) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$,
        $w_1 = w_1' = ((\perm,\lin),\baddr,n,\aaddr)$, $w_2 = w_2' =
        ((\perm,\lin),n+1,\eaddr,\aaddr)$, $k=2$.
      \item (split) $\Phi_T(r_3) = \Phi_S(r_3) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $\sigma_\baddr \leq n$, $n <
        \sigma_\eaddr$, $w_1 = w_1' = \seal{\sigma_\baddr,n,\sigma}$, $w_2 =
        w_2' = \seal{n+1,\sigma_\eaddr,\sigma}$, $k=2$.
      \item (split) $\Phi_S(r_3) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$,
        $\Phi_T(r_3) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$,
        $n < \eaddr$, $w_1 = \stkptr{\perm,\baddr,n,\aaddr}$, $w_1' =
        ((\perm,\linear),\baddr,n,\aaddr)$, $w_2 =
        \stkptr{\perm,n+1,\eaddr,\aaddr}$, $w_2' =
        ((\perm,\linear),n+1,\eaddr,\aaddr)$, $k=2$.
      \item (splice) $\Phi_T(r_2) = ((\perm,\linear),\baddr_2,\eaddr_2,\_)$,
        $\Phi_S(r_2) = \stkptr{\perm,\baddr_2,\eaddr_2,\_}$, and $\Phi_T(r_3) =
        ((\perm,\linear),\eaddr_2+1,\eaddr_3,\aaddr_3)$, $\Phi_S(r_3) =
        \stkptr{\perm,\eaddr_2+1,\eaddr_3,\aaddr_3}$, and $\baddr_2 \leq
        \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
        $w_1=((\perm,\linear),\baddr_2,\eaddr_3,\aaddr_3)$, $w_1'=
        \stkptr{\perm,\baddr_2,\eaddr_3,\aaddr_3}$, and $w_2 = w_2' = w_3 = w_3'
        = 0$, and $k=3$
      \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) =
        ((\perm,\lin),\baddr_2,\eaddr_2,\_)$, and $\Phi_T(r_3) = \Phi_S(r_3) =
        ((\perm,\lin),\eaddr_2+1,\eaddr_3,\aaddr_3)$, and $\baddr_2 \leq
        \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
        $w_1=w_1'=((\perm,\lin),\baddr_2,\eaddr_3,\aaddr_3)$, and $\lin =
        \linear \Rightarrow w_2 = w_2' = w_3 = w_3' = 0$, and $\lin = \normal
        \Rightarrow (w_2 = w_2' = \Phi_T(r_2) \text{ and } w_3 = w_3' =
        \Phi_T(r_3))$, and $k=3$
      \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) =
        \seal{\sigma_{\baddr,2},\sigma_{\eaddr,2},\_}$, and $\Phi_T(r_3) =
        \Phi_S(r_3) =
        \seal{\sigma_{\eaddr,2}+1,\sigma_{\eaddr,3},\sigma_{\aaddr,3}}$, and
        $\sigma_{\baddr,2} \leq \sigma_{\eaddr,2}$, and $\sigma_{\eaddr,2} + 1
        \leq \sigma_{\eaddr,3}$and $w_1 = w_1' = \seal{\sigma_{\baddr,2},
          \sigma_{\eaddr,3}, \sigma}$
      \end{enumproof}
    \end{itemize}
  \item All of the following hold: (includes memory-manipulation cases: store,
    load, that can be handled mostly uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' =
      \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\mem.\aaddr}{w}}$
    \item $\Phi_T' =
      \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\mem.\aaddr}{w'}}$
    \item One of the following hold:
      \begin{enumproof}
      \item (store) $w_1 = w_1' = \Phi_S(r_1) = \Phi_T(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \writeAllowed{}$,
        and
        $\withinBounds{w_1}$, and\\
        $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
        w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
        \text{ and } w_2' = \Phi_T(r_2))$.
      \item (load) $w_2 = w_2' = \Phi_T(r_2) = \Phi_S(r_2) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \readAllowed{}$,
        $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and \\
        $w_1 = \Phi_S.\mem(\aaddr)$, and $w_1' = \Phi_T.\mem(\aaddr)$, and \\
        $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
        $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
      \end{enumproof}
    \end{itemize}
  \item All of the following hold: (includes memory-manipulation cases: store,
    load, that can be handled mostly uniformly (stack))
    \begin{itemize}
    \item $\Phi_S \step[\gc]\Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' =
      \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\ms_\stk.\aaddr}{w}}$
    \item $\Phi_T' =
      \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\ms_\stk.\aaddr}{w'}}$
    \item One of the following hold:
      \begin{enumproof}
      \item (store) $w_1 = \Phi_T(r_1) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $w_1' = \Phi_S(r_1) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \writeAllowed{}$,
        and
        $\withinBounds{w_1}$, and\\
        $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
        w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
        \text{ and } w_2' = \Phi_T(r_2))$.
      \item (load) $ w_2' = \Phi_T(r_2) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, and $w_2 = \Phi_S(r_2) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \readAllowed{}$,
        $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and $\aaddr \in
        \dom(\Phi.\ms_\stk)$, and $\aaddr \in \dom(\Phi.\ms_\stk)$, and\\
        $w_1 = \Phi_S.\ms_\stk(\aaddr)$, and $w_1' = \Phi_T.\ms_\stk(\aaddr)$, and \\
        $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
        $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
      \end{enumproof}
    \end{itemize}
  \item All of the following hold: (includes control-flow manipulation cases:
    jmp, jnz, xjmp, that can be handled mostly uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item One of the following holds
      \begin{enumproof}
      \item(jnz) $\Phi_S' = \updPcAddr{\Phi_S}$ and $\Phi_T' =
        \updPcAddr{\Phi_T}$
      \item(jmp,jnz) $\Phi_S' = \Phi_S\updReg{\pcreg,r_1}{\Phi_S(r_1),w_1}$ and
        $\Phi_T' = \Phi_T\updReg{\pcreg,r_1'}{\Phi_T(r_1),w_1'}$ and
        $\isLinear{\Phi_S(r_1)} \Rightarrow w_1 = w_1' = 0$ and $\neg
        \isLinear{\Phi_S(r_1)} \Rightarrow (w_1 = \Phi_S(r_1) \text{ and } w_1'
        = \Phi_T(r_1))$
      \item(xjmp) $\Phi_S(r_1) = \sealed{\sigma,c_1}$ and $\Phi_S(r_2) =
        \sealed{\sigma,c_2}$ and $\Phi_T(r_1) = \sealed{\sigma,c_1'}$ and
        $\Phi_T(r_2) = \sealed{\sigma,c_2'}$ and $\Phi_S'(r_1,r_2) =
        \linCons{c_1},\linCons{c_2}$ and $\Phi_T'(r_1,r_2) =
        \linCons{c_1'},\linCons{c_2'}$ and\\
        $c_1' \neq \retptrc(\_)$ and $c_2' \neq \retptrd(\_)$ and
        $\nonExec{c_\data}$ and $\Phi_T'(\pcreg,\rdata) = c_1',c_2'$ and one of
        the following hold:
        \begin{enumproof}
        \item $c_1 \neq \retptrc(\_)$ and $c_2 \neq \retptrd(\_)$ and
          $\nonExec{c_\data}$ and $\Phi_S'(\pcreg,\rdata) = c_1,c_2$.
        \item $c_1 = \retptrc(\baddr,\eaddr,\aaddr)$, and $c_2 =
          \retptrd(\aaddr_\stk,\eaddr_{\stk,\priv})$ and $\Phi(r_\stk) =
          \stkptr{\rw,\stkb,\eaddr_\stk,\_}$ and $\Phi_S.\stk = \stk_\var{frame}
          :: (\aaddr,\ms_{\stk,\priv})$ and $\dom(\ms_{\stk,\priv} =
          [\eaddr_\stk+1,\eaddr_{\stk,\priv}])$ and $\Phi_S'.\ms_\stk =
          \ms_{\stk,\priv} \uplus \Phi_S.\ms_\stk$ and $\Phi_S'.\stk = \stk$ and
          \[
            \begin{split}
              \Phi_S' = \Phi_S&[\pcreg \mapsto ((\rx,\normal),\baddr,\eaddr,\aaddr)]\\
              &[\rstk \mapsto
              \stkptr{\rw,\stkb,\eaddr_{\stk,\priv},e_\stk+1}] \\
              &[\rdata,\rtmp{1},\rtmp{2},r_2 \mapsto 0, 0, 0, 0]
            \end{split}
          \]
        \end{enumproof}
      \end{enumproof}
    \end{itemize}
  \end{enumproof}
\lau{TODO: Argue that the above is indeed the case.}

By the above observation, we know that $\Phi_S \step[\gc] \Phi_S'$ and $\Phi_T \step
\Phi_T'$ for some $\Phi_S'$ and $\Phi_T'$. According to
Lemma~\ref{lem:lro-anti-red-gen}, it suffices to show:
\[
  \npair[n'-1]{(\Phi_S',\Phi_T')} \in \lro
\]
Consider each of the possible cases:

In case \ref{case:ftlr:failed}, both executions go to failed. In this case, we
either assume that the target configuration terminates or that the source
configuration terminates, but in either case it leads to a contradiction with
the failing configuration.
\\\\
In case \ref{case:ftlr:halted}, both source and target configuration halts in 0
steps, so both directions of $\lro$ are trivially satisfied.
\\\\
In case \ref{case:ftlr:get-and-arith-op}, we use the induction hypothesis to get
\[
  \npair[n'-1]{(((\perm,\lin),\baddr,\eaddr,\aaddr+1),((\perm,\lin),\baddr,\eaddr,\aaddr+1))} \in \lre(W)
\]
This is possible by using the initial assumptions along with Lemma \ref{lem:downwards-closed}.
By Lemma~\ref{lem:downwards-closed}, we know $\memSat[n'-1]{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$.
By Lemma~\ref{lem:downwards-closed} and the fact that integers are always safe,
we know $\npair[n'-1]{(\reg_S\update{r}{z},\reg_T\update{r}{z})} \in \lrr(W_R)$.
This allows us to conclude
\[
  \npair[n'-1]{(\Phi_S',\Phi_T')} \in \lro
\]
as desired.
\\\\
In case \ref{case:ftlr:call}, we first need to let the target execution catch
up. That is $\Phi_T' \nstep[15]{} \Phi_T''$ for 
\[
\Phi_T'' = \Phi_T
\begin{array}[t]{l}
  \update{\mem.\aaddr_\stk}{42} \\
  \updReg{\rstk}{((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1)} \\
  \updReg{\rretd}{\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)}} \\
  \updReg{\rretc}{\sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\retoffset)}} \\
  \updReg{\rtmp{1}}{0}\\
  \updReg{r_1,r_2}{\linCons{\Phi_T(r_1)},\linCons{\Phi_T(r_2)}}\\
  \updReg{\pcreg}{c_1'}\\
  \updReg{\rdata}{c_2'}
\end{array}
\]
where $\Phi_T(r_i) = \sealed{\sigma,c_i'} \text{ for $i\in\{1,2\}$}$ and $\retoffset = 15$ which is the offset to the return code.
Now using Lemma~\ref{lem:lro-anti-red-gen} again, it suffices to show
\[
  \npair[n'-1]{(\Phi_S',\Phi_T'')} \in \lro
\]
By assumption, we have $\npair[n']{(\reg_S(r_i),\reg_T(r_i))} \in \lrr(W_{R,i})$ for some $W_{R,i}$ with $i \in \{1,2\}$.
We know the capabilities in $r_1$ and $r_2$ are sealed capabilities, and by
Lemma~\ref{lem:unique-h-sigma} and the definition of $\lrv$ we get
$\npair[n'-1]{\stpair[.]{c_2}{c_2'}} \in H_\sigma \; \sigma \; \xi^{-1}(W_{R,2})$
and w.l.o.g.\

\begin{equation}
\forall W' \future W_{R,1}, W_o, n' < n, \npair[n']{(c_2,c_2')} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \npair[n']{c_1,c_2,c_1',c_2'} \in \lrexj(W'\oplus W_o)\label{eq:ftlr:call:sealed-code-assump}
\end{equation}
Now construct $W_{R,1}'$ as follows:

By Lemma~\ref{lem:nsub-and-nsup-std} and the safety assumption on the register-file, there exists $S \supseteq [\baddr_\stk, \eaddr_\stk]$ such that for some $R : S \fun \powerset{\nats}$ we have $\biguplus_{r \in S} R(r) \supseteq [\baddr_\stk,\eaddr_\stk]$ and for all $r$ in $S$ $\pwfree[W_{R,1}](r).H \nequal \stdreg{R(r),\gc}{\pur}.H$ and $|R(r)| = 1$ and $\pwfree[W_{R,1}](r) \text{ is address-stratified}$.
Now define
\[
  W_{R,1}' = W_{R,1}[\free.R^{-1}([\aaddr_\stk,\eaddr_\stk]) \mapsto \revoked][\priv.r_\var{priv\_stk} \mapsto (\stareg[(\ms_{\stk\_\priv,S},\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}),\gc]{\spa,\square},\aaddr+\calllen)]
\] 
For a fresh $r_\var{priv\_stk}$.
We know $W_{R,1}' \future W_{R,1}$ as the revoked regions must have been $\spatial$ in $W_{R,q}$ (as they are owned by the part of the world assigned to the stack-register in the register-file relation).
The static region for the private stack is an extension.

Pick this world as $W'$ in Eq~\ref{eq:ftlr:call:sealed-code-assump}
. Let $W_{R,2}'$ be the same world but
with the ownership of $W_{R,2}$ and pick it for $W_o$.
Now use monotonicity of $H_\sigma$ with the above facts to get
\[
  \npair[n']{c_1,c_2,c_1',c_2'} \in \lrexj(W_{R,1}'\oplus W_{R,2}')
\]
Now pick register files and memories such that they form $\Phi_S''$ (defined in
the assumptions) and $\Phi_T''$ and for $W_R'$ and $W_M'$ (we define them below) show
\begin{enumerate}[label=\roman*.]
\item \label{case:ftlr:scall:world} $W_{R,1}'\oplus W_{R,2}' \oplus W_R' \oplus W_M'$
\item \label{case:ftlr:scall:reg} $\npair[n'-1]{(\Phi_S''.\reg,\Phi_T''.\reg)} \in \lrr(\{\rdata\})(W_R')$
\item \label{case:ftlr:scall:mem} $\memSat[n'-1]{\Phi_S''.\mem,\Phi_S''.\stk,\Phi_S''.\ms_\stk,\Phi_T''.\mem}{W_M'}$
\end{enumerate}
to get
\[
 \npair[n'-1]{(\Phi_S',\Phi_T'')} \in \lro
\]
as desired. It remains to show \ref{case:ftlr:scall:world}-\ref{case:ftlr:scall:mem}.

Case \ref{case:ftlr:scall:world}: Pick $W_R'$ and $W_M'$ to have the regions of $W_{R,1}'$, but where $W_R'$ owns $r_\var{priv\_stk}$ and otherwise has the ownership of $W_R$ and $W$ with the exception of the regions owned by $W_{R,1}'$ and $W_{R,2}'$.
$W_M'$ has the ownership of $W_M$.
Case \ref{case:ftlr:scall:world} follows from assumption $W \oplus W_R \oplus W_M$.
The only changes to the worlds is that some ownership has been shifted from $W_R$ to $W_{R,1}$ and $W_{R,2}$ and the ownership for $W$ now belongs to $W_R'$.
In other words, no ownership has been duplicated.

Case \ref{case:ftlr:scall:reg}, using assumption $\npair[n'-1]{(\reg_S\update{r}{z},\reg_T\update{r}{z})} \in \lrr(W_R)$, we get a way to split the ownership of $W_R$.
We take this as the starting point, but with the following changes: regions $r_1$ and $r_2$ maps to worlds with no ownership.
region $\rstk$ maps to a world with the same ownership, but of course without the now revoked regions.
Region $\rretd$ maps to a world that owns private $r_\var{priv\_stk}$ region.
Finally, $\rretc$ maps to a world with the ownership of $W$.

we split the world in the same way for the registers that remain unchanged, the
result follows from Lemma \ref{lem:downwards-closed} and \ref{lem:monotonicity}.
This leaves the following cases:
\begin{description}
\item[Case $\rstk$:] \lau{TODO}
\item[Case $\rtmp{1}$:] \lau{TODO}
\item[Case $r_1$,$r_2$:] \lau{TODO}
\item[Case $\rretd$:] We have to show 
  \[
    \npair[n'-1]{(\sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)},\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)})} \in \lrv(W_{R,\rretd}')
  \]
  where $W_{R,\rretd}'$ is the part of $W_R'$ with ownership over $r_\var{priv\_stk}$.
  From the assumption $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$ we get $R \subseteq \addressable{\normal, \pwheap}$ and $\exists M : S \fun \powerset{\MemSeg}$ such that $\biguplus_{r\in S} \dom(M(r)) \supseteq [\baddr,\eaddr]$ and $\forall r \in S \ldotp \pwheap(r) \nequal \codereg{\sigrets',\_,M(r),\gc}$.
  Further by $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W}$, we know that for one
  $r \in S$ there is a $\mscode' \subseteq \mscode$\footnote{Follows from
    $H^\var{code}$ requiring $\dom(\mscode') \subseteq \ta$ and $\dom(\mscode) =
    \ta$ and finally that $\mscode$ is part of $\ms_S$.} such that
  \begin{equation}
    \npair[n']{(\mscode',\mscode')} \in H^{\var{code}} \; \sigrets' \; \sigcloss' \; \mscode' \; (\ta,\_)\label{eq:ftlr:rretd:Hcode}
  \end{equation}
  where $\sigma' \in \sigrets'$ and $\dom(\mscode') \supseteq [\baddr,\eaddr]$ and $\aaddr + \offpc \in \dom(\mscode')$.
  That is $\mscode'$ contains the call we are considering.
  \lau{TODO: Make the above more precise and possibly put into a lemma (also needed in the next case).}
  Use the $r$ in question as the witness.
  The $\xReadCond{}$ gives us $\pwheap(r) \nequal \codereg{\_,\_,\mscode',\gc}$.
  As it is a pure region, it is also present in the future world we consider.
  We now have to show:
  \begin{enumerate}[label=\alph*)]
  \item for $n'' < n'-1$ we have
    \[\npair[n'']{\left(\array{l}\retptrd(\aaddr_\stk,\eaddr_\stk),\\((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)\endarray\right)}
      \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode'
      \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_{R,\rretd}')
    \]
    First $\dom(\mscode') \subseteq \ta$ follows from \ref{eq:ftlr:rretd:Hcode} and the assumption $[\baddr,\eaddr] \ subseteq \ta$.
    Now pick $r_\var{priv\_stk}$ as the witness.
    We immediately get $\dom(\ms_{\stk\_\priv,S}) = \dom(\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}) = [\aaddr_\stk,\eaddr_\stk]$.
    Next, $\decInstr(\mscode'(\aaddr,\aaddr+\calllen-1)) = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}}$ follows from $\callCond{\Phi_S,r_1,r_2,\aaddr}$.
    Finally, $\ms_\code(\aaddr+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr}$ with $\sigma' = \sigma_\baddr + \offpc \in \sigrets'$ which follows from $\sigrets',\sigcloss' \vdash_{\mathrm{comp-code}} \mscode'$ and the fact that the call is there.
  \item $\isLinear{\sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)}}$ iff
    $\isLinear{\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk)}}$\\
    Trivial as both are linear.    
  \item
    \[
      \begin{array}{l}
        \forall W'' \future \purePart{W_{R,\rretd}'}, W_o, n'' < n'-1,\\
        \quad\npair[n'']{(\vsc_S',\vsc_T')}
        \in  H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode'
        \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_o) \ldotp \\
        \qquad\npair[n']{\retptrd(\aaddr_\stk,\eaddr_\stk),\vsc_S',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1),\vsc_T'} \in
        \lrexj(W'\oplus W_o))
      \end{array}
    \]
    Trivial as both configuration fails.
  \end{enumerate}
  
\item[Case $\rretc$:]
  We have to show 
  \[
    \npair[n'-1]{\left(\array{l}\sealed{\sigma',\retptrc(\baddr,\eaddr,\aaddr +
        \calllen)},\\\sealed{\sigma',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)}\endarray\right)} \in \lrv(W_{R,\rretc}')
  \]
  where $W_{R,\rretc}'$ has the ownership of $W$.
  Just as in the previous case, we know that for some region $r$ there exists $\mscode' \subseteq \mscode$ such that: $\pwheap(r) \nequal \codereg{\sigrets',\_,\mscode',\gc}$ where $\sigma' \in \sigrets'$ and $\dom(\mscode') \supseteq [\baddr,\eaddr]$ and $\aaddr + \offpc \in \dom(\mscode')$.
  It follows easily from the definition of $H_\sigma^\var{code}$ that
  \begin{equation}
    \label{eq:code-caps-in-h-sigma}
    \npair[n'']{\left(\array{l}\retptrc(\baddr,\eaddr,\aaddr + \calllen),\\((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)\endarray\right)} \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode' \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_{R,\rretc}')
  \end{equation}
  for $n'' < n'-1$.
  Both capabilities are non-linear, so $\isLinear{\retptrc(\baddr,\eaddr,\aaddr + \calllen)}$ iff $\isLinear{((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)}$ is indeed the case.
  Finally we need to show:
  \[
    \begin{array}{l}
      \forall W'' \future \purePart{W_{R,\rretc}'}, W_o, n'' < n'-1,\\
      \quad  \npair[n'']{(\vsc_S',\vsc'_T)} \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode' \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_o) \ldotp \\
      \qquad \npair[n'']{\retptrc(\baddr,\eaddr,\aaddr + \calllen),\vsc_S',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset),\vsc_T'} \in \lrexj(W''\oplus W_o))
    \end{array}
  \]
  To this end let $W'' \future \purePart{W_{R,\rretc}'}$ and $W_o$ be given s.t.
  $W'' \future \purePart{W_{R,\rretc}'} \oplus W_o$ is defined. Further, let
  $\npair[n'']{(\vsc_S',\vsc'_T)} \in H^\mathrm{code,\square}_\sigma \;
  \sigrets' \; \sigcloss' \; \mscode' \; (\ta,\stkb) \; \sigma' \;
  \xi^{-1}(W_o)$ be given and show 
  \[
    \npair[n'']{\retptrc(\baddr,\eaddr,\aaddr + \calllen),\vsc_S',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset),\vsc_T'} \in \lrexj(W''\oplus W_o))
  \]
  Now let $n''' \leq n''$ be given along with $\reg[3]_S$, $\reg[3]_T$, $\ms^{(3)}_S$, $\ms^{(3)}_T$,$\ms^{(3)}_\stk$, $\stk^{(3)}$, $W_R''$, and $W_M''$ such that
  \begin{itemize}
  \item $W'' \oplus W_o \oplus W_R'' \oplus W_M''$ is defined
  \item $\memSat[n''']{\ms^{(3)}_S,\ms^{(3)}_\stk, \stk^{(3)}, \ms^{(3)}_T}{W_M''}$
  \item $\npair[n''']{(\reg[3]_S,\reg[3]_T)} \in \lrr(W_R'')$
  \end{itemize}
  
  Based on $H_\sigma^\var{code}$, there are three possible values for $\vsc_S'$ and $\vsc_T'$.
  In the first case, $\vsc_S'$ is a $\retptrc$ and $\vsc_T'$ is a capability with permission $\rx$.
  In this case, $\xjumpResult{}{}{}$ will give to failed configurations which is trivially in the observation relation.
  In the next case, it is required that $\sigma' \in \sigcloss'$, but this cannot be the case as \lau{TODO I think this case should follow from $H^\var{code}$ and the comp-code judgement, but it does not.
    Specifically, the comp-code judgement (for now) does not require $\sigrets'$ and $\sigcloss'$ to be disjointed.}

  This leaves us with one final case, namely $\vsc_S'= \retptrd(\baddr_\stk',\eaddr_\stk')$ and $\vsc_T'=((\rw,\linear),\baddr_\stk',\eaddr_\stk',\baddr_\stk'-1)$.
  Further we know
  \[
    \begin{array}{l}
    \exists r \in \addressable{\linear,\pwpriv[W_o]} \ldotp \pwpriv[W_o](r).H \nequal (\stareg[(\ms_{\priv,S}^{(3)},\ms_{\priv,T}^{(3)}),(\ta,\stkb)]{\spao,\square}, \aaddr'+\calllen) \tand \\
    \quad \dom(\ms_S) = \dom(\ms_T) = [\baddr_\stk',\eaddr_\stk'] \tand\\
    \quad \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
    \quad \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets 
    \end{array}
  \]
  Call this region $r'$.
  By the above, the fact that the code capability pair is in $H_\sigma^\var{code}$ (\ref{eq:code-caps-in-h-sigma}) and Lemma~\ref{lem:unique-ret-seals}, we get $\aaddr' = \aaddr$.
  This means that $W_M''$ and $W_R''$ has this region. 

  We know that the two register-files are related which in particular means that
  the values in register $\rstk$ are related. Now consider the following cases:
  \lau{TODO: Perhaps make a lemma that says if source fail and target step to
    fail, then the two configurations are in $\lro$.}
  \begin{itemize}
  \item $\Phi_S(\rstk) \neq \stkptr{\_,\_,\_,\_}$\\
    In this case due to $\reg[3]_S$ being related to $\reg[3]_T$, there are three cases we need to consider.
    In all cases, the source configuration will fail because the value in the stack register is not a stack capability.
    If we can argue that the target configuration also will fail, then the two are in the observation relation.
    First, if $\reg[3]_T = \sealed{\sigma_\var{ret\_\stk},\vsc_T''}$, then the return code will fail when the base address (a sealed capability has no base address, so the instruction returns $-1$) is compared to $\stkb$.
    Second, if $\reg[3]_T = \seal{\_,\_,\_}$, then the target execution fails when it attempts to splice this seal with $\vsc_T'$.
    Finally, $\reg[3]_T = ((\perm_\var{ret\_\stk},\lin_\var{ret\_\stk}),\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_)$ and $\npair[n''']{[\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk}]} \in \readCond{\lin_\var{ret\_\stk},W_{R,\rstk}''}$ is satisfied.
    This means that it is satisfied by some heap region, but by the memory satisfaction assumption $\stkb$ must be in the free stack part of the world.
    This means that the execution will fail that $\stkb$ check.
  \item $\Phi_S(\rstk) = \stkptr{\perm_\var{ret\_\stk},\baddr_\var{ret\_\stk},\_,\_}$ and $\baddr_\var{ret\_\stk} \neq \stkb$\\
    Here the source side will fail the xjmp as the base address is not $\stkb$.
    Similarly on the target side, the return code will fail the $\stkb$ check.
  \item $\Phi_S(\rstk) = \stkptr{\_,\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_}$ and $\baddr_\var{ret\_\stk} = \stkb$ and either $\eaddr_\var{ret\_\stk} +1 \neq \baddr_\stk' $ or $\perm_\var{ret\_\stk} \neq \rw$ or
    $\baddr_\var{ret\_\stk} > \eaddr_\var{ret\_\stk}$.\\
    In this case, the source configuration will fail as one of the conditions in $\var{xjumpResult}$ will not be met.
    On the target side, the splice will fail as either the two capabilities being spliced don't line up, the permissions don't match, or the range of authority is empty, respectively.
  \item $\Phi_S(\rstk) = \stkptr{\perm_\var{ret\_\stk},\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_}$ and $\baddr_\var{ret\_\stk} = \stkb$ and $\eaddr_\var{ret\_\stk} +1 = \baddr_\stk' $ and $\perm_\var{ret\_\stk} = \rw$ and $\baddr_\var{ret\_\stk} \leq \eaddr_\var{ret\_\stk}$.
    \\
    We would like to show that $\ms_{\priv,S}^{(3)}$ is the top most stack frame and that $r'$ governs it.
    By the memory satisfaction assumption and the presence of $r'$ in $W_M''$ we know that $\stk^{(3)}$ is non-empty.
    By the memory satisfaction on the private stack, the following must be the case:
    \[
      \begin{array}{l}
        \stk^{(3)} = (\opc_0,\ms_0), \dots (\opc_m,\ms_m) \wedge \\
        \forall i \in \{0,\dots,m\} \ldotp (\dom(\ms_i) \neq \emptyset \wedge\\
        \quad \forall i < j \ldotp \forall a \in \dom(\ms_i) \ldotp \forall a' \in \dom(\ms_j) \ldotp \stkb < a < a')\\
      \end{array}
    \]
    Assume for contradiction $\ms_{\priv,S}^{(3)}$ is not the top frame. In that
    case $\dom(\ms_0) \neq \emptyset$ and $\forall a \in \dom(\ms_0) \ldotp
    \ldotp \stkb < a < b_\stk$ at the same time, we know
    \[
      \npair[n'']{(\stkptr{\rw,\stkb,\eaddr_\var{ret\_\stk},\_},((\rw,\linear),\stkb,\eaddr_\var{ret\_\stk},\_))}
      \in \lrv(W_{R,\rstk}'')
    \]
    which means that the free stack part of the world contains a region that at least governs $[\stkb,\eaddr_\var{ret\_\stk}]$.
    Combine this with $\eaddr_\var{ret\_\stk} +1 = \baddr_\stk' $, we can conclude that no such address can exist in $\ms_0$, so it must be empty, but this cannot be the case either.
    Therefore, the top stack frame must contain $\ms_{\priv,S}^{(3)}$.
    Further, due to the disjointedness required by memory satisfaction, it must be $r'$ that governs this stack frame.
    This also means that we have $\opc_0 =  \aaddr+\calllen$.
    With this, we have all the requirements for $\var{xjumpResult}$ satisfied on
    both sides which allows us to pick the necessary configurations:
    \begin{multline*}
      \Phi^{(4)}_S=\xjumpResult{r_1}{r_2}{(\ms_S^{(3)},\reg[3]_S,(\ms_{\priv,S}^{(3)},\aaddr+\calllen)
        :: \stk^{(3)}_\var{rest},\ms_\stk^{(3)})} =\\
      (\ms_S^{(3)},\reg[3]_S
      \arraycolsep=0pt
      \begin{array}[t]{l}
        \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen)} \\
        \updReg{\rdata}{0} \\
        \updReg{\rstk}{\stkptr{\rw,\stkb,e_\stk',\eaddr_\var{ret\_stk}+1}} \\
        \updReg{\rtmp{1}}{0} \\
        \updReg{\rtmp{2}}{0}
      \end{array}
      ,\stk^{(3)}_\var{rest},\ms_{\priv,S}^{(3)} \uplus \ms_\stk^{(3)})
    \end{multline*}
    and
    \begin{multline*}
      \Phi^{(4)}_T=\xjumpResult{r_1}{r_2}{(\ms_T^{(3)},\reg[3]_T)} =\\
      (\ms_T^{(3)},\reg[3]_S
      \arraycolsep=0pt
      \begin{array}[t]{l}
        \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\retoffset)} \\
        \updReg{\rdata}{((\rw,\linear),\stkb,\eaddr_\var{ret\_stk})}
      \end{array})
    \end{multline*}
    It now remains to show
    \[
      \npair[n''']{(\Phi^{(4)}_S,\Phi^{(4)}_T)} \in \lro
    \]
    Use Lemma~\ref{lem:lro-anti-red-gen} by which it suffices to show the
    following two things:
    \begin{itemize}
    \item
      \[
        \Phi^{(4)}_T \step[l] \Phi^{(5)}_T = (\ms_T^{(3)},\reg[3]_S
        \arraycolsep=0pt
        \begin{array}[t]{l}
          \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen)} \\
          \updReg{\rdata}{0} \\
          \updReg{\rstk}{((\rw,\linear),\stkb,e_\stk',\eaddr_\var{ret\_stk}+1)} \\
          \updReg{\rtmp{1}}{0} \\
          \updReg{\rtmp{2}}{0}
        \end{array})
      \]
      for some number of steps $l$. This follows immediately from the
      operational semantics.
    \item
      \[
        \npair[n''']{(\Phi^{(4)}_S,\Phi^{(5)}_T)} \in \lro
      \]
      Here we need to use the induction hypothesis.
    \end{itemize}

  \end{itemize}




  
  

\end{description}
This concludes case \ref{case:ftlr:scall:reg}

Case: \ref{case:ftlr:scall:mem}, \lau{TODO}

\end{proof}

\begin{lemma}[Unique return seals]
  \label{lem:unique-ret-seals}
  If
  \begin{itemize}
  \item $\mscode([\aaddr..\aaddr+\calllen-1]) = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}}$
  \item $\mscode([\aaddr'..\aaddr'+\calllen-1]) = \overline{\scall{\offpc',\offsigma'}{r_1'}{r_2'}}$
  \item $\mscode(\aaddr + \offpc) = \seal{\sigma_b,\sigma_e,\sigma_b}$ and $\sigma = \sigma_b + \offpc$
  \item $\mscode(\aaddr' + \offpc') = \seal{\sigma_b',\sigma_e',\sigma_b'}$ and $\sigma = \sigma_b' + \offpc'$
  \end{itemize}
  then
  \[
    \aaddr = \aaddr'
  \]
  and $\offpc = \offpc'$ and $\offsigma = \offsigma'$ and $r_1 = r_1'$ and $r_2 = r_2'$ and $\sigma_b = \sigma_b'$ and $\sigma_e = \sigma_e'$.
\end{lemma}
\begin{proof}
  \lau{TODO}
\end{proof}
%%% Local Variables:
%%% TeX-master: "technical-report"
%%% End: