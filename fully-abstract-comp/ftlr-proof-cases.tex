\subsection{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[Downwards closure of relations]
  \label{lem:downwards-closed}
  If $n' \leq n$, then
  \begin{itemize}
  \item If $\npair{A} \in \readCond{\lin,W}$, then $\npair[n']{A} \in \readCond{\lin,W}$.
  \item If $\npair{A} \in \stackReadCond{\lin,W}$, then $\npair[n']{A} \in \stackReadCond{\lin,W}$.
  \item If $\npair{A} \in \writeCond{\lin,W}$, then $\npair[n']{A} \in \writeCond{\lin,W}$.
  \item If $\npair{A} \in \stackWriteCond{\lin,W}$, then $\npair[n']{A} \in \stackWriteCond{\lin,W}$.
  \item If $\npair{A} \in \execCond{\lin,W}$, then $\npair[n']{A} \in \execCond{\lin,W}$.
  \item If $\npair{A} \in \xReadCond{W}$, then $\npair[n']{A} \in \xReadCond{W}$.
  \item If $\npair{(w,w')} \in \lrvg{\trust}(W)$, then $\npair[n']{(w,w')} \in \lrvg{\trust}(W)$.
  \item If $\npair{(w,w')} \in \lrrg{\trust}(W)$, then $\npair[n']{(w,w')} \in \lrrg{\trust}(W)$.
  \item If $\memSatFStack{ms_\stk,\ms_T}{W}$, then $\memSatFStack[n']{ms_\stk,\ms_T}{W}$.
  \item If $\memSatStack{ms_\stk,\ms_T}{W}$, then $\memSatStack[n']{ms_\stk,\ms_T}{W}$.
  \item If $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap{\pwheap}(W)$, then $\npair[n']{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap{\pwheap}(W)$.
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$, then also $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$.
  \end{itemize}
\end{lemma}
\begin{proof}
  The properties for $\readCond{}$, $\stackReadCond{}$, $\writeCond{}$, $\stackWriteCond{}$, $\execCond{}$, $\xReadCond{}$ follow easily by definition.
  The property for $\lrv$ follows from the others and by definition.
  The property for $\lrr$ follows directly from the one for $\lrv$.
  
  The property for $\lrheap$, $\memSatFStack{\_,\_}{\_}$, $\memSatStack{\_,\_}{\_}$ follows from the downward closure of regions in the world, and the property for $(\_,\_,\_,\_) :_n W$ follows from those.
\end{proof}

\begin{lemma}[Properties of n-equality of worlds]
  \label{lem:n-equality-props}
  If $W_1 \nequal W_2$ then
  \begin{itemize}
  \item $\purePart{W_1} \nequal \purePart{W_2}$
  \item If $W_1' \future W_1$ then there exists a $W_2'$ such that $W_2' \nequal W_1'$ and $W_2' \future W_2$.
  \item If $W_1' \oplus W_1$ is defined, then there exists a $W_2' \nequal W_1'$ and $W_2' \oplus W_2$ is defined.
  \item If $W_1 = W_1' \oplus W_1''$ then there exist $W_2' \nequal W_1'$ and $W_2'' \nequal W_1''$ such that $W_2 = W_2' \oplus W_2''$.
  \end{itemize}
\end{lemma}
\begin{proof}
  Easy to prove by unfolding definitions and making unsurprising choices for existentially quantified worlds.
\end{proof}

\begin{lemma}[Non-expansiveness of relations]
  \label{lem:non-expansiveness}
  If $W \nequal W'$, then
  \begin{itemize}
  \item $\readCond{W} \nequal \readCond{W'}$.
  \item If $\stackReadCond{\lin,W} \nequal \stackReadCond{\lin,W'}$.
  \item If $\writeCond{\lin,W} \nequal \writeCond{\lin,W'}$.
  \item If $\stackWriteCond{\lin,W} \nequal \stackWriteCond{\lin,W'}$
  \item If $\xReadCond{W} \nequal \xReadCond{W'}$.
  \item $\lre(W) \nequal \lre(W')$.
  \item $\lrexj(W) \nequal \lrexj(W')$.
  \item If $\execCond{\lin,W} \nequal \execCond{\lin,W'}$.
  \item If $\lrvg{\trust}(W) \nequal \lrvg{\trust}(W')$.
  \item If $\lrrg{\trust}(W) \nequal \lrrg{\trust}(W')$.
  \item If $\memSatFStack{ms_\stk,\ms_T}{W}$, then $\memSatFStack{ms_\stk,\ms_T}{W'}$.
  \item If $\memSatStack{ms_\stk,\ms_T}{W}$, then $\memSatStack{ms_\stk,\ms_T}{W'}$.
  \item If $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap{\pwheap}(W)$, then $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap{\pwheap[W']}(W')$.
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$ iff $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W'}$.
  \item ...
  \end{itemize}
\end{lemma}
\begin{proof}
  The properties for $\readCond{}$, $\stackReadCond{}$, $\writeCond{}$, $\stackWriteCond{}$, $\xReadCond{}$ follow from the fact that these are defined to use the world only for comparing regions using $\nequal$, $\nsubeq$ and $\nsupeq$. 

  The property for $\lre$ and $\lrexj$ follow from Lemma~\ref{lem:n-equality-props}.

  The property for $\execCond{}$ follows from Lemma~\ref{lem:n-equality-props} and the property for $\lre$.

  The property for $\lrv$ follows from the other properties, by definition, from Lemma~\ref{lem:n-equality-props}, non-expansiveness of regions \dominique{Is $\xi$ non-expansive/contractive/?}
  TODO

  The property of $\lrr$ follows from the one for $\lrv$.

  The property for $\lrheap$, $\memSatFStack{\_,\_}{\_}$, $\memSatStack{\_,\_}{\_}$ and $(\_,\_,\_,\_) :_n W$ follows from the non-expansiveness of regions in the world. \dominique{and $\xi?$}
  TODO
\end{proof}

\begin{lemma}[World monotonicity of relations]
  \label{lem:monotonicity}
  For all $n$, $W' \future W$, we have that
  \begin{itemize}
  \item If $(w_1,w_2) \in H_\sigma~\sigma~W$, then $(w_1,w_2) \in H_\sigma~\sigma~W'$.
    \lau{This should hold for any valid $H_\sigma$, but we need to prove it for specific instantiations.}
  \item If $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in
    \lrv(W')$.
  \item If $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap(\pwheap[W_1])(W)$, then $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in
    \lrheap(\pwheap[W_1])(W')$.
\end{itemize}
\end{lemma}
\begin{proof}
  Follows from the definitions.
  Note: the proof for $\lrheap$ relies on Lemma~\ref{lem:oplus-future-distr}.
\end{proof}

\begin{lemma}[$\lror$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_T \nstep[j]{} \Phi_T' \text{ and } \npair[n-j]{(\Phi_S,\Phi_T')} \in \lror,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lror
\]
\end{lemma}
\begin{proof}
  Special case of Lemma~\ref{lem:lro-anti-red-gen}.
\end{proof}

\begin{lemma}[$\lrol$ closed under source language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_S \nstep[j]{\gc} \Phi_S' \text{ and } \npair[n-j]{(\Phi_S',\Phi_T)} \in \lrol,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lrol
\]
\end{lemma}
\begin{proof}
  Special case of Lemma~\ref{lem:lro-anti-red-gen}.
\end{proof}


\begin{lemma}[$\lro$ closed under antireduction (generalised previous lemma)]
  \label{lem:lro-anti-red-gen}
  For all $\Phi_S$, $\Phi_S'$, $\Phi_T$, $\Phi_T'$, $j_S,j_T$, $n$, if
  \begin{itemize}
  \item $\Phi_S \nstep[j_S]{\gc} \Phi_S'$
  \item $\Phi_T \nstep[j_T]{} \Phi_T'$
  \item $\npair{(\Phi_S',\Phi_T')} \in \lro$
  \end{itemize}
  then
  \[
    \npair[n+\min(j_S,j_T)]{(\Phi_S,\Phi_T)} \in \lro
  \]
\end{lemma}
\begin{proof}
  Our two languages are deterministic\dominique{Lemma needed for this, I guess..}, so we have that $\Phi_S \sterm{\ta,\stkb}$ iff $\Phi_S \sterm{\ta,\stkb}$ and $\Phi_T \term$ iff $\Phi_T' \term$.
  It is also easy to show that if $\Phi_S \sterm[i + \min(j_S,j_T)]{\ta,\stkb}$, then $\Phi_S' \sterm[i]{\ta,\stkb}$ and if $\Phi_T \term[i+\min(j_S,j_T)]$, then $\Phi_T' \term[i]$.
  The result then follows easily by definition of $\lrol$ and $\lror$.
\end{proof}

\begin{lemma}[Capability safety doesn't depend on address]
  \label{lem:cap-in-lrv-regardless-of-addr}
  If
  \[
    \npair{((\perm,\lin),\baddr,\eaddr,\aaddr),((\perm,\lin),\baddr,\eaddr,\aaddr)} \in \lrvg{\trust}(W)
  \]
  then
  \[
    \npair{((\perm,\lin),\baddr,\eaddr,\aaddr'),((\perm,\lin),\baddr,\eaddr,\aaddr')} \in \lrvg{\trust}(W)
  \]
\end{lemma}
\begin{proof}
  Direct form the definition of $\lrvg{\trust}$.
\end{proof}

\begin{lemma}[Stack capability safety doesn't depend on address]
\label{lem:stkptr-in-lrv-regardless-of-addr}
  If
  \[
    \npair{((\stkptr{\perm,\baddr,\eaddr,\aaddr},(\perm,\lin),\baddr,\eaddr,\aaddr))} \in \lrvg{\trust}(W)
  \]
  then
  \[
    \npair{(\stkptr{\perm,\baddr,\eaddr,\aaddr'},((\perm,\lin),\baddr,\eaddr,\aaddr'))} \in \lrvg{\trust}(W)
  \]
\end{lemma}
\begin{proof}
  Direct from the definition of $\lrvg{\trust}$.
\end{proof}

\begin{lemma}[Seal safety doesn't depend on current seal]
  \label{lem:seal-in-lrv-regardless-of-cur-seal}
  If
  \[
    \npair{(\seal{\sigma_\baddr,\sigma_\eaddr,\sigma},\seal{\sigma_\baddr,\sigma_\eaddr,\sigma})} \in \lrvg{\trust}(W)
  \]
  then
  \[
    \npair{(\seal{\sigma_\baddr,\sigma_\eaddr,\sigma'},\seal{\sigma_\baddr,\sigma_\eaddr,\sigma'})} \in \lrvg{\trust}(W)
  \]
\end{lemma}
\begin{proof}
  Direct from the definition of $\lrvg{\trust}$.
\end{proof}


\begin{lemma}[Capability safety monotone w.r.t. permission]
  \label{lem:cap-in-lrv-mono-perm}
  If
  \[
    \npair{((\perm,\lin),\baddr,\eaddr,\aaddr),((\perm,\lin),\baddr,\eaddr,\aaddr)} \in \lrvg{\trust}(W)
  \]
  and
  \[
    \perm' \sqsubseteq \perm
  \]
  then
  \[
    \npair{((\perm',\lin),\baddr,\eaddr,\aaddr),((\perm',\lin),\baddr,\eaddr,\aaddr)} \in \lrvg{\trust}(W)
  \]
\end{lemma}
\begin{proof}
  Direct from the definition of $\sqsubseteq$ and $\lrvg{\trust}$.
\end{proof}

\begin{lemma}[Capability splitting retains safety for normal capabilities]
  \label{lem:splitting-safety-normal}
  If
  \begin{itemize}
  \item $\npair{(c,c)} \in \lrvg{\trust}(W)$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $b \le n \le e$
  \item $c_1 = ((\perm,\lin),\baddr,n,\aaddr)$
  \item $c_2 = ((\perm,\lin),n,\eaddr,\aaddr)$
  \item $c_3 = \linCons{c}$
  \end{itemize}
  then there exist $W_1,W_2$,$W_3$ such that
  \begin{itemize}
  \item $W = W_1 \oplus W_2 \oplus W_3$
  \item $\npair{(c_1,c_1)} \in \lrvg{\trust}(W_1)$
  \item $\npair{(c_2,c_2)} \in \lrvg{\trust}(W_2)$
  \item $\npair{(c_3,c_3)} \in \lrvg{\trust}(W_3)$
  \end{itemize}
\end{lemma}
\begin{proof}
  TODO
  
  From $\npair{(c,c)} \in \lrvg{\trust}(W)$, we get that either $\perm = \noperm$, in which case we can pick the ownership distribution to be the same as before, or $\npair{[\baddr,\eaddr]} \in \readCond{\linear,R_R(r_3)}$.

    In the latter case, we get $S \subseteq \addressable{\linear,R_R(r_3)}$ and $R : S \fun \powerset{R_R(r_3)}$ such that $\forall r \in S \ldotp |R(r)| = 1$ and $\biguplus_{r\in S} R(r) \supseteq [\baddr,\eaddr]$.

    This gives us a way to distribute the ownership, namely $r_3$ gives up ownership of regions $R^{-1}([\baddr,\eaddr])$, $r_1$ gets ownership of $R^{-1}([\baddr,n])$, and $r_2$ gets ownership over $R^{-1}([n+1,\eaddr])$.
    The remainder of the ownership distribution remains unchanged.

TODO TODO TODO     
    Now we have to argue the following:
    \begin{itemize}
    \item if $\perm \in \readAllowed$, then
      \begin{itemize}
      \item $\npair{[\baddr,n]} \in \readCond{\linear,R_R'(r_1)}$
      \item $\npair{[n+1,\eaddr]} \in \readCond{R_R'(r_2)}$
      \end{itemize}
      
    \item if $\perm \in \writeAllowed$, then
      \begin{itemize}
      \item $\npair{[\baddr,n]} \in \writeCond{\linear,R_R'(r_1)}$
      \item $\npair{[n+1,\eaddr]} \in \writeCond{\linear,R_R'(r_2)}$
      \end{itemize}
    \item $\perm \neq \rx$

      Assuming $\perm = \rx$, then it must have been the case that $\lin = \normal$ contradicting the assumption $\isLinear{(\Phi_S(r_3))}$.
      
    \end{itemize}
    or
    \begin{itemize}
    \item 
    \end{itemize}
    depending on whether the permission of the capability was $\perm = \noperm$
    or not. In both cases, the result follows immediately by the assumptions.

    If $\neg \isLinear{(\Phi_S(r_3))}$, then we pick $R_R' = R_R$

    TODO

\end{proof}

\begin{lemma}[Capability splitting retains safety for stack capabilities]
  \label{lem:splitting-safety-stack}
  If
  \begin{itemize}
  \item $\npair{(c_S,c_T)} \in \lrvg{\trust}(W)$
  \item $c_S = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c_T = ((\perm,\linear),\baddr,\eaddr,\aaddr)$
  \item $b \le n \le e$
  \item $c_{1,S} = \stkptr{\perm,\baddr,n,\aaddr}$
  \item $c_{1,T} = ((\perm,\linear),\baddr,n,\aaddr)$
  \item $c_{2,S} = \stkptr{\perm,n,\eaddr,\aaddr}$
  \item $c_{2,T} = ((\perm,\linear),n,\eaddr,\aaddr)$
  \item $c_3 = 0$
  \end{itemize}
  then there exist $W_1,W_2$,$W_3$ such that
  \begin{itemize}
  \item $W = W_1 \oplus W_2 \oplus W_3$
  \item $\npair{(c_{1,S},c_{1,T})} \in \lrvg{\trust}(W_1)$
  \item $\npair{(c_{2,S},c_{2,T})} \in \lrvg{\trust}(W_2)$
  \item $\npair{(c_3,c_3)} \in \lrvg{\trust}(W_3)$
  \end{itemize}
\end{lemma}
\begin{proof}
  Similar to the proof of Lemma~\ref{lem:splitting-safety-normal}.
\end{proof}

\begin{lemma}[Capability splicing retains safety for normal capabilities]
  \label{lem:splitting-safety-normal}
  If
  \begin{itemize}
  \item $\npair{(c_1,c_1)} \in \lrvg{\trust}(W_1)$
  \item $\npair{(c_2,c_2)} \in \lrvg{\trust}(W_2)$
  \item $c_1 = ((\perm,\lin),\baddr,m,\aaddr)$
  \item $c_2 = ((\perm,\lin),m+1,\eaddr,\aaddr)$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $b \le m \le e$
  \item $c_1' = \linCons{c_1}$
  \item $c_2' = \linCons{c_2}$
  \item $W_1\oplus W_2 \oplus W_M$ is defined
  \item $\memSat{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$
  \end{itemize}
  then there exist $W_1',W_2',W_3'$ such that
  \begin{itemize}
  \item $W_1 \oplus W_2 = W_1' \oplus W_2' \oplus W_3'$
  \item $\npair{(c,c)} \in \lrvg{\trust}(W_3')$
  \item $\npair{(c_1',c_1')} \in \lrvg{\trust}(W_1')$
  \item $\npair{(c_2',c_2')} \in \lrvg{\trust}(W_2')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c_1,c_1)} \in \lrvg{\trust}(W_1)$ and $\npair{(c_2,c_2)} \in \lrvg{\trust}(W_2)$, it follows that either ($[b,m] \mathrel{\#} \ta$ or $[b,m] \subseteq \ta$) and also either ($[m+1,e] \mathrel{\#} \ta$ or $[m+1,e] \subseteq \ta$).

  Consider first the case where either $[b,m] \subseteq \ta$ or $[m+1,e]\subseteq \ta$.
  Then by definition of $\lrvg{\trust}$, we have that $\lin = \normal$, $\trust = \trusted$ and $\npair{[b,m]} \in \xReadCond{W_1}$ or $\npair{[m+1,e]} \in \xReadCond{W_2}$, respectively.
  It follows by definition of $\xReadCond{}$ and $\codereg{}$ that $[\baddr-1,m+1]$ or $[m,\eaddr+1] \subseteq \ta$, respectively, so that it is impossible that $[m+1,\eaddr]\mathrel{\#} \ta$ or $[\baddr,m] \mathrel{\#} \ta$ respectively.
  In other words, we must have that both $[b,m] \subseteq \ta$ and $[m+1,e]\subseteq \ta$.

  From Lemma~\ref{lem:conds-splicable}, it follows that also $\npair{[\baddr,\eaddr]}\in\xReadCond{W_1\oplus W_2}$ and from Lemma~\ref{lem:non-linear-pure}, it follows that $\npair{[\baddr,\eaddr]}\in\xReadCond{}(\purePart{W_1\oplus W_2})$.
  Finally, we have that $\npair{(c,c)}\in\lrvg{\trust}(\purePart{W_1\oplus W_2})$.
  We can take $W_3' = \purePart{W_1\oplus W_2}$, $W_1' = W_1$ and $W_2' = W_2$ and the remaining proof obligations follow by assumption and by Lemma~\ref{lem:purePart-duplicable} and~\ref{lem:oplus-assoc-comm}.
  
  Now consider the case that both $[b,m] \mathrel{\#} \ta$ and $[m+1,e]\mathrel{\#} \ta$.
  The results now follow by definition of $\lrv$, using Lemma~\ref{lem:conds-splicable} and~\ref{lem:non-linear-pure}, taking $W_3' = W_1 \oplus W_2$ and $W_1' = \purePart{W_1}$ and $W_2' = \purePart{W_2}$.
\end{proof}

\begin{lemma}[Capability splicing retains safety for stack capabilities]
  \label{lem:splicing-safety-stack}
  If
  \begin{itemize}
  \item $\npair{(c_{1,S},c_{1,T})} \in \lrvg{\trust}(W_1)$
  \item $\npair{(c_{2,S},c_{2,T})} \in \lrvg{\trust}(W_2)$
  \item $b \le m \le e$
  \item $c_{1,S} = \stkptr{\perm,\baddr,m,\aaddr}$
  \item $c_{1,T} = ((\perm,\linear),\baddr,m,\aaddr)$
  \item $c_{2,S} = \stkptr{\perm,m+1,\eaddr,\aaddr}$
  \item $c_{2,T} = ((\perm,\linear),m+1,\eaddr,\aaddr)$
  \item $c_S = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c_T = ((\perm,\linear),\baddr,\eaddr,\aaddr)$
  \end{itemize}
  then we have that
  \begin{itemize}
  \item $\npair{(c_S,c_T)} \in \lrvg{\trust}(W_1 \oplus W_2)$
  \end{itemize}
\end{lemma}
\begin{proof}
  This follows easily by definition of $\lrv$ and using Lemma~\ref{lem:conds-splicable}.
\end{proof}

\begin{lemma}[Stack capability safety monotone w.r.t. permission]
\label{lem:stkptr-in-lrv-mono-perm}
  If
  \[
    \npair{(\stkptr{\perm,\baddr,\eaddr,\aaddr},((\perm,\lin),\baddr,\eaddr,\aaddr))} \in \lrvg{\trust}(W)
  \]
  and
  \[
    \perm' \sqsubseteq \perm
  \]
  then
  \[
    \npair{(\stkptr{\perm',\baddr,\eaddr,\aaddr},((\perm',\lin),\baddr,\eaddr,\aaddr))} \in \lrvg{\trust}(W)
  \]
\end{lemma}
\begin{proof}
  Follows directly from the definition.
\end{proof}


\begin{lemma}[readCondition works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\readCond{l,W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_S(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\writeCond{l,W}$
  \end{itemize}
  Then $\memSat{(\ms_S[a\mapsto 0],\stk,\ms_\stk,\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\readCond{l,W}$, we get an $S \subseteq \addressable{\lin,
    \pwheap}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwheap(r).H
  \nsubeq \stdreg{R(r),\gc}{\pur}.H$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwheap) =
  \dom(\pwheap[W_M])$ and $\pwheap(r) \oplus \pwheap[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(W_M)(W_\var{heap})$.
  \end{itemize}

  From $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(W_M)(W_\var{heap})$, we get an
  $R_\ms : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,heap} = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_2(R_\ms(r))$,
  $\ms_S = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_1(R_\ms(r))$,
  $\exists R_W : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \World\ldotp$
  $W_\var{heap} = \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwheap[W_M]}$, we have that
  $\npair{R_\ms(r)} \in  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.
  We also get an $R_\var{seal} : \dom(\activeReg{\pwheap}) \fun \powerset{\Seal}$ such that  $\biguplus_{r \in \dom(\activeReg{\pwheap})} R_\var{seal}(r)) \subseteq \overline{\sigma}$ and $\dom(\pwheap(r).H_\sigma) = R_\var{seal}(r)$.

  We have that $r \in \addressable{\lin, \pwheap} \subseteq
  \activeReg{\pwheap[W_\var{heap}]}$, so $\npair{R_\ms(r)} \in
  \pwheap[W_M](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwheap(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$ and $W\oplus W_M$ is defined, it follows that
  also $\pwheap[W_M](r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}}' \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{heap}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{heap}}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    R_W(r) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
      W_\var{heap} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\writeCond{l,W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwheap} \subseteq \activeReg{\pwheap[W_M]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ such that
  for all $r \in S'$, $\pwheap(r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$ and
  $\pwheap(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .

  Because $W \oplus W_M$ is defined, it follows that also
  $\pwheap[W_M](r').H \nsupeq \stdreg{R'(r'),\gc}{\pur}.H$ and
  $\pwheap[W_M](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $\dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwheap[W_\var{heap}](r).H \; \xi^{-1}(W_r')$ because $\pwheap[W_M](r)$ is address-stratified and $\pwheap[W_M](r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$.

  From this, it follows that $\npair{(\overline{\sigma},\ms_S\update{a}{0},\ms_\var{T,heap}\update{a}{0})} \in \lrheap(W_M)(W_r' \oplus W_\var{heap}')$ and finally $\npair{(\overline{\sigma},\ms_S\update{a}{0},\stk,\ms_\stk,\ms_T\update{a}{0})} \in \lrheap(W_M')(W_r' \oplus W_{\var{heap}}')$.
\end{proof}

\begin{lemma}[stackReadCondition works]
  \label{lem:stackreadcond-stackwritecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\stackReadCond{W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\stackWriteCond{W}$
  \end{itemize}
  Then $\memSat{(\ms_S,\stk,\ms_\stk[a\mapsto 0],\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\stackReadCond{W}$, we get an $S \subseteq \addressable{\lin,
    \pwfree}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwfree(r).H
  \nsubeq \stdreg{R(r),\gc}{\pur}.H$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwfree) =
  \dom(\pwfree[W_M])$ and $\pwfree(r) \oplus \pwfree[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})}\in\lrheap(\pwheap[W_M])(W_\var{heap})$.
  \end{itemize}

  From $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$, we get an
  $R_\ms : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,free\_stack} = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_2(R_\ms(r))$,
  $\ms_\stk = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_1(R_\ms(r))$,
  $\stkb \in \dom(\ms_\var{T,free\_stack}) \wedge \stkb \in \dom(\ms_\stk)$,
  $\exists R_W : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \World\ldotp$
  $W_\var{free\_stack} = \oplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwfree[W_\var{free\_stack}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwfree} \subseteq \activeReg{\pwfree[W_\var{free\_stack}]}$, so $\npair{R_\ms(r)} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwfree(r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$ and $W\oplus W_M = W \oplus (W_\var{free\_stack} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that also $\pwfree[W_\var{free\_stack}](r).H \nsubeq \stdreg{R(r),\gc}{\pur}.H$.
  This means that also $\npair{R_\ms(r)} \in H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}')$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{free\_stack}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_\var{heap}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_{\var{heap}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    R_W(r) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{free\_stack}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
    &=
      W_\var{free\_stack} \oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\stackWriteCond{W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwfree} \subseteq \activeReg{\pwheap[W_\var{free\_stack}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ and
  for all $r \in S'$, $\pwfree(r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$ and
  $\pwfree(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .

  Because $W \oplus W_M$ is defined, it follows that also
  $\pwfree[W_\var{free\_stack}](r').H \nsupeq \stdreg{R'(r'),\gc}{\pur}.H$ and
  $\pwfree[W_\var{free\_stack}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $ \dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(W_r')$ because $\pwfree[W_\var{free\_stack}](r)$ is address-stratified and $\pwfree[W_\var{free\_stack}](r).H \nsupeq \stdreg{R'(r),\gc}{\pur}.H$.

  From this, it follows that $\memSatFStack{\ms_\stk\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{free\_stack}'}$ and finally $\memSat{(\ms_S,\stk,\ms_\stk\update{a}{0},\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[load from regular capability works]
  \label{lem:readcond-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$, $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrvg{\trust}(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  Consider first the case that $\npair{(c,c')}\in\lrv(W)$.

  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, $\perm \in \readAllowed{}$ and $\perm' \in \readAllowed{}$, we get that $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$.

  Lemma~\ref{lem:readcond-writecond-work} then gives us a $W'$ and $W_M'$ such that $W_M = W' \oplus W_M'$ and $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$.

  it remains to prove that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_S(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(W)$ that also $\isLinear{\ms_T(\aaddr')}$ and $\linCons{\ms_T(\aaddr')} = 0$.
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm,\perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrv(W)$, it then follows that $\npair{(\baddr,eaddr)} \in \writeCond{\lin,W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:downwards-closed}, we then get that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.

  \item case $\neg\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = \ms_S(\aaddr)$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?}
    and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by downwards closure of memory satisfaction, i.e.~Lemma~\ref{lem:downwards-closed}.
  \end{itemize}

  Now consider the case that $\npair{(c,c')}\in(\lrvg{\trusted}(W) \setminus \lrv(W))$. then we have that $[b,e] \subseteq \ta$ and $\npair{[b,e]} \in \xReadCond{W}$.
  By definition of $\xReadCond{}$, there is an $r_a$ such that $\pwheap(r) \nequal \codereg{\_,\_,\code,\gc}$, $a \in \dom(\code)$.
  By definition of $\codereg{}$ and using the fact that $\dom(\code) \ni a \in [b,e] \subseteq \ta$, we know that $\dom(\code) \subseteq \ta$ and $\_,\_\vdash_{\mathrm{comp-code}} \code$.
  From the fact that $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, together with the definition of $\codereg{}$, we know that $\npair[n']{(\Phi.\mem(a),\Phi.\mem(a))} \in \lrvg{\trusted}(\purePart{W_M})$ and we have that $\purePart{W_M} = \purePart{W}$ by Lemma~\ref{lem:purePart-oplus}. 
  From the fact that $\_,\_\vdash_{\mathrm{comp-code}} \code$, we get that $\neg \isLinear{\code(a)}$.
  
  We can then take $W_M' = W_M$, $W' = W$ and get the required results from what we have proven above and using Lemma~\ref{lem:downwards-closed}.
\end{proof}

\begin{lemma}[load from stack capability works]
  \label{lem:load-stack-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item ($\aaddr \in [\baddr,\eaddr]$ or $\aaddr' \in [\baddr',\eaddr']$)
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, ($\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$), we get that $\perm = \perm'$, $\lin' = \linear$, $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \stackReadCond{W}$.

  From Lemma~\ref{lem:stackreadcond-stackwritecond-work}, we then get that $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.


  It remains to prove that $\memSat{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_\stk(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$.
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm = \perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \stackWriteCond{W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:downwards-closed}, we then get that $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{0},\ms_T\update{\aaddr'}{0})}{W_M'}$.

  \item case $\neg\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = \ms_\stk(\aaddr)$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?}
    and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by downwards closure of memory satisfaction, i.e.\ Lemma~\ref{lem:downwards-closed}.
  \end{itemize}
\end{proof}

\begin{lemma}[Store to regular capability works]
  \label{lem:store-reg-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c_1 = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $c_1' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \writeAllowed{}$, $\perm' \in \writeAllowed{}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \item $\npair{(c_1,c_1')}\in\lrvg{\trusted}(H_\sigma,W_1)$
  \item $\npair{(c_2,c_2')}\in\lrv(H_\sigma,W_2)$
  \item $W_1 \oplus W_2 \oplus W_M$ is defined
  \item $n' < n$
  \item $c_3 = \linCons{c_2}$, $c_3' = \linCons{c_2'}$
  \end{itemize}
  Then $\exists W_2', W_M'\ldotp$
  \begin{itemize}
  \item $W_2 \oplus W_M = W_2' \oplus W_M'$
  \item $\memSat[n']{(\ms_S\update{\aaddr}{c_2},\stk,\ms_\stk,\ms_T\update{\aaddr'}{c_2'})}{W_M'}$
  \item $\npair[n']{(c_3,c_3')} \in \lrv(W_2')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c_1,c_1')}\in\lrvg{\trusted}(W_1)$ and $\perm \in \writeAllowed{}$, it follows that $c_1 = c_1'$ and $\npair{[b,e]} \in \writeCond{\lin,W_1}$. 

  We then get a $r$ and $A$, such that $a \in A$, $\pwheap[W_1](r).H \nsupeq \stdreg{A,\gc}{v}.H$ and $\pwheap[W_1](r)$ is address-stratified.

  If we decompose the judgement that $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, then we get some $\npair[n-1]{\ms_S|_A, \ms_T|_A} \in \stdreg{A,\gc}{v}.H~W_{M,A}$ for some $W_M = W_{M,A} \oplus W_{M,R}$.
  If we define $W_M'$ as $W_M \oplus W_2$ and $W_2' = \purePart{W_2}$, then we can use the properties about $\pwheap[W_1](r)$ above to show that  $\memSat[n']{(\ms_S\update{\aaddr}{c_2},\stk,\ms_\stk,\ms_T\update{\aaddr'}{c_2'})}{W_M'}$.
  The fact that $\npair[n']{(c_3,c_3')} \in \lrv(W_2')$ follows from Lemma~\ref{lem:non-linear-pure}.
\end{proof}

\begin{lemma}[Store to stack capability works]
  \label{lem:store-stack-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c_1 = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c_1' = ((\perm',\linear),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \writeAllowed{}$, $\perm' \in \writeAllowed{}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \item $\npair{(c_1,c_1')}\in\lrvg{\trusted}(H_\sigma,W_1)$
  \item $\npair{(c_2,c_2')}\in\lrv(H_\sigma,W_2)$
  \item $W_1 \oplus W_2 \oplus W_M$ is defined
  \item $n' < n$
  \item $c_3 = \linCons{c_2}$, $c_3' = \linCons{c_2'}$
  \end{itemize}
  Then $\exists W_2', W_M'\ldotp$
  \begin{itemize}
  \item $W_2 \oplus W_M = W_2' \oplus W_M'$
  \item $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{c_2},\ms_T\update{\aaddr'}{c_2'})}{W_M'}$
  \item $\npair[n']{(c_3,c_3')} \in \lrv(W_2')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c_1,c_1')}\in\lrvg{\trusted}(W_1)$ and $\perm \in \writeAllowed{}$, it follows that $\perm = \perm'$, $\baddr = \baddr'$, $\eaddr = \eaddr'$, $\aaddr = \aaddr'$ and $\npair{[b,e]} \in \stackWriteCond{W_1}$. 

  We then get a $r$ and $A$, such that $a \in A$, $\pwfree[W_1](r).H \nsupeq \stdreg{A,\gc}{v}.H$ and $\pwfree[W_1](r)$ is address-stratified.

  If we decompose the judgement that $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, then we get some $\npair[n-1]{\ms_\stk|_A, \ms_T|_A} \in \stdreg{A,\gc}{v}.H~W_{M,A}$ for some $W_M = W_{M,A} \oplus W_{M,R}$.
  If we define $W_M'$ as $W_M \oplus W_2$ and $W_2' = \purePart{W_2}$, then we can use the properties about $\pwfree[W_1](r)$ above to show that  $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{c_2},\ms_T\update{\aaddr'}{c_2'})}{W_M'}$.
  The fact that $\npair[n']{(c_3,c_3')} \in \lrv(W_2')$ follows from Lemma~\ref{lem:non-linear-pure}.
\end{proof}


\subsection{FTLR proof}

\begin{lemma}
  \label{lem:ftlr-internal-lemma}
  If
  \begin{itemize}
  \item One of the following sets of requirements holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S$ is reasonable up to $n$ steps and $[\baddr,\eaddr] \subseteq \ta$
    \item $\trust = \untrusted$ and $[b,e] \mathrel{\#} \ta$ and $\npair{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}
  \item $\Phi_S(\pcreg) = \Phi_T(\pcreg) = ((\rx,\normal),\baddr,\eaddr,\_)$
  \item $\npair{[\baddr,\eaddr]} \in \xReadCond{W_\pcreg}$
  \item $\npair{(\Phi_S.\reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)$
  \item $\memSat{\Phi_S.\mem,\Phi_S.\stk,\Phi_S.\ms_\stk,\Phi_T.\mem}{W_M}$
  \item $W_\pcreg \oplus W_R \oplus W_M$ is defined.
  \item Theorem~\ref{thm:ftlr} holds for all $n' < n$.
  \end{itemize}
  Then
  \[
    \npair{(\Phi_S,\Phi_T)} \in \lro
  \]
\end{lemma}
\begin{proof}
  In the following we will use the following: $\reg_S = \Phi_S.\reg$, $\reg_T = \Phi_T.\reg$, $\ms_S = \Phi_S.\mem$, $\ms_\stk = \Phi_S.\ms_\stk$, and $\stk = \Phi_S.\stk$.

  By complete induction on $n$, i.e. we can assume that the lemma already holds for $n' < n$.

  In order to prove this, we first, we prove that one of the following holds:
  \begin{enumproof}
  \item \label{case:ftlr:failed} $\Phi_S \step[\gc] \failed$ and $\Phi_T
    \step[i] \failed$ for some $i$.
  \item \label{case:ftlr:halted} $\Phi_S \step[\gc] \halted$ and $\Phi_T \step\halted$
  \item \label{case:ftlr:get-and-arith-op} All of the following hold: (includes simple cases: gettype, geta, getb,
    gete, getp, getl, lt, plus, minus, one case of move that can be handled
    uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r}{z}} \neq \failed$
    \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r}{z}} \neq \failed$
    \item $z \in \ints$
    \end{itemize}
  \item \label{case:ftlr:call} All of the following hold:
    \begin{itemize}
    \item $\callCond{\Phi_S,r_1,r_2,\offpc,\offsigma,\aaddr}$
    \item $r_1 \neq \rtmp{1}$ and $r_2 \neq \rtmp{1}$
    \item $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$
    \item $\exec{\Phi_S(\pcreg)}$
    \item for all $i = 0..\calllen-1$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i) \in \ints$.
    \item $[\baddr,\eaddr] \subseteq \ta$
    \item $\Phi_S \step[\gc] \Phi_S' \neq \failed$
    \item $\Phi_T \step \Phi_T' \neq \failed$
      % domi: this condition doesn't make syntactic sense and is also not used.
    % \item $\Phi_T' = \updPc{\Phi_T\updReg{\rtmp{1}}{z}}$
    \item $z \in \ints$
    \item $\Phi_S(r_1) = \sealed{\sigma,c_1}$
    \item $\Phi_S(r_2) = \sealed{\sigma,c_2}$
    \item $\nonExec{c_2}$
    \item $\Phi_S(\rstk) = \stkptr{\rw, \baddr_\stk, \eaddr_\stk, \aaddr_\stk}$
    \item $\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk$
    \item $\Phi_S(\pcreg) = ((\perm,\normal),\baddr,\eaddr,\aaddr)$
    \item $w_1 = \linCons{c_1}$ and $w_2 = \linCons{c_2}$
    \item \[
        \begin{split}
          \Phi_S''.\reg = \Phi_S.reg      &[\rstk \mapsto \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1}] \\
          &[\rretc \mapsto \sealed{\sigma',\retptrc(\baddr,\eaddr,\aaddr+\calllen)}]\\
          &[\rretd \mapsto \sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)}] \\
          &[r_1,r_2 \mapsto w_1,w_2] \\
          &[\rtmp{1} \mapsto 0]
        \end{split}
      \]
    \item $\Phi_S''.\mem = \Phi_S.\mem$
    \item $\ms_{\stk\_\priv,S} = \Phi_S.\ms_\stk |_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}$
    \item $\Phi_S''.\stk = ((\aaddr+\calllen),\ms_{\stk\_\priv,S}) :: \Phi_S.\stk$
    \item $\Phi_S''.\ms_\stk = \Phi_S.\ms_\stk -
      \Phi_S.\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}$
    \item $\baddr \leq \aaddr+\offpc \leq \eaddr$
    \item $\mem(\aaddr+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma_\aaddr}$
    \item $\sigma' = \sigma_\aaddr + \offsigma$
    \item $\sigma_\aaddr \leq \sigma' \leq \sigma_\eaddr$

    \item $\Phi_S' =\var{xjumpResult}\left(c_1,c_2, \Phi_S'' \right)$

    \end{itemize}
  \item \label{case:ftlr:move-cca-etc} All of the following hold: (includes cap-manipulation cases: move, cca,
    restrict, seta2b, cseal, split, splice, that can be handled mostly
    uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1\cdots r_k}{w_1\cdots w_k}}\neq
      \failed$
    \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1\cdots r_k}{w_1'\cdots w_k'}}
      \neq \failed$
    \item $r_i \neq \pcreg$ for all $i$
    \item One of the following holds:
      \begin{enumproof}
      \item \label{case:ftlr:move-cca-etc:cca-normal} (restrict,cca,seta2b) $w_1 = ((\perm',\lin),\baddr,\eaddr,\aaddr')$,
        $w_1' = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi_T(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k =
        1$
      \item \label{case:ftlr:move-cca-etc:cca-stack}(restrict,cca,seta2b) $w_1 = \stkptr{\perm',\baddr,\eaddr,\aaddr'}$,
        $w_1' = ((\perm',\linear),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $\Phi_T(r_1) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$,
        $k = 1$
      \item \label{case:ftlr:move-cca-etc:cca-seal}(cca,seta2b) $w_1 = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$,
        $w_1' = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma'}$, $\Phi_S(r_1) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$ and $\Phi_T(r_1) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $k = 1$
      \item \label{case:ftlr:move-cca-etc:move}(move) $w_1 = \Phi_S(r_2)$, $w_1' = \Phi_T(r_2)$, and $\isLinear{w_1} \Rightarrow w_2 = w_2' = 0$, and $\neg \isLinear{w_1} \Rightarrow (w_2 = \Phi_S(r_2) \wedge w_2' = \Phi_T(r_2)$) and $r_1 \neq r_2$ and $k = 2$.
      \item \label{case:ftlr:move-cca-etc:move-eq}(move) $w_1 = \Phi_S(r_1)$, $w_1' = \Phi_T(r_1)$ and $k = 1$.
      \item \label{case:ftlr:move-cca-etc:cseal}(cseal) $w_1 = \sealed{\sigma,\Phi_S(r_1)}$, $w_1' =
        \sealed{\sigma,\Phi_T(r_1)}$, $\Phi_S(r_2) = \Phi_T(r_2) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $k=1$
      \item \label{case:ftlr:move-cca-etc:split-normal} (split) $\Phi_T(r_3) = \Phi_S(r_3) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$,
        $w_1 = w_1' = ((\perm,\lin),\baddr,n,\aaddr)$, $w_2 = w_2' =
        ((\perm,\lin),n+1,\eaddr,\aaddr)$, $w_3 = w_3' = \linCons{\Phi_S(r_3)}$, $k=3$.
      \item \label{case:ftlr:move-cca-etc:split-seal} (split) $\Phi_T(r_3) = \Phi_S(r_3) =
        \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $\sigma_\baddr \leq n$, $n <
        \sigma_\eaddr$, $w_1 = w_1' = \seal{\sigma_\baddr,n,\sigma}$, $w_2 =
        w_2' = \seal{n+1,\sigma_\eaddr,\sigma}$, $k=2$.
      \item \label{case:ftlr:move-cca-etc:split-stack} (split) $\Phi_S(r_3) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$,
        $\Phi_T(r_3) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$,
        $n < \eaddr$, $w_1 = \stkptr{\perm,\baddr,n,\aaddr}$, $w_1' =
        ((\perm,\linear),\baddr,n,\aaddr)$, $w_2 =
        \stkptr{\perm,n+1,\eaddr,\aaddr}$, $w_2' =
        ((\perm,\linear),n+1,\eaddr,\aaddr)$, $w_3 = w_3' = 0$, $k=3$.
      \item \label{case:ftlr:move-cca-etc:splice-stack}(splice) $\Phi_T(r_2) = ((\perm,\linear),\baddr_2,\eaddr_2,\_)$,
        $\Phi_S(r_2) = \stkptr{\perm,\baddr_2,\eaddr_2,\_}$, and $\Phi_T(r_3) =
        ((\perm,\linear),\eaddr_2+1,\eaddr_3,\aaddr_3)$, $\Phi_S(r_3) =
        \stkptr{\perm,\eaddr_2+1,\eaddr_3,\aaddr_3}$, and $\baddr_2 \leq
        \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
        $w_1=((\perm,\linear),\baddr_2,\eaddr_3,\aaddr_3)$, $w_1'=
        \stkptr{\perm,\baddr_2,\eaddr_3,\aaddr_3}$, and $w_2 = w_2' = w_3 = w_3'
        = 0$, and $k=3$
      \item \label{case:ftlr:move-cca-etc:splice-normal}(splice) $\Phi_T(r_2) = \Phi_S(r_2) =
        ((\perm,\lin),\baddr_2,\eaddr_2,\_)$, and $\Phi_T(r_3) = \Phi_S(r_3) =
        ((\perm,\lin),\eaddr_2+1,\eaddr_3,\aaddr_3)$, and $\baddr_2 \leq
        \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
        $w_1=w_1'=((\perm,\lin),\baddr_2,\eaddr_3,\aaddr_3)$, and $w_2 = w_2' = \linCons{\Phi_S(r_2)}$ and $w_3 = w_3' = \linCons{\Phi_S(r_3)}$, and $k=3$
      \item \label{case:ftlr:move-cca-etc:splice-seal} (splice) $\Phi_T(r_2) = \Phi_S(r_2) =
        \seal{\sigma_{\baddr,2},\sigma_{\eaddr,2},\_}$, and $\Phi_T(r_3) =
        \Phi_S(r_3) =
        \seal{\sigma_{\eaddr,2}+1,\sigma_{\eaddr,3},\sigma_{\aaddr,3}}$, and
        $\sigma_{\baddr,2} \leq \sigma_{\eaddr,2}$, and $\sigma_{\eaddr,2} + 1
        \leq \sigma_{\eaddr,3}$and $w_1 = w_1' = \seal{\sigma_{\baddr,2},
          \sigma_{\eaddr,3}, \sigma}$
      \end{enumproof}
    \end{itemize}
  \item \label{case:ftlr:store-load-mem} All of the following hold: (includes memory-manipulation cases: store,
    load, that can be handled mostly uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' =
      \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\mem.\aaddr}{w}}$
    \item $\Phi_T' =
      \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\mem.\aaddr}{w'}}$
    \item $r_i \neq \pcreg$ for all $i$
    \item One of the following hold:
      \begin{enumproof}
      \item (store) $w_1 = w_1' = \Phi_S(r_1) = \Phi_T(r_1) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \writeAllowed{}$,
        and
        $\withinBounds{w_1}$, and\\
        $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $w_2 = \linCons{\Phi_S(r_2)}$, $w_2' = \linCons{\Phi_T(r_2)}$.
      \item (load) $w_2 = w_2' = \Phi_T(r_2) = \Phi_S(r_2) =
        ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \readAllowed{}$,
        $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and \\
        $w_1 = \Phi_S.\mem(\aaddr)$, and $w_1' = \Phi_T.\mem(\aaddr)$, and \\
        $w = \linCons{w_1}$, $w' = \linCons{w_1'}$, $\linConsPerm{\perm}{w_1}$, $\linConsPerm{\perm}{w_1'}$
      \end{enumproof}
    \end{itemize}
  \item \label{case:ftlr:store-load-stack} All of the following hold: (includes memory-manipulation cases: store,
    load, that can be handled mostly uniformly (stack))
    \begin{itemize}
    \item $\Phi_S \step[\gc]\Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item $\Phi_S' =
      \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\ms_\stk.\aaddr}{w}}$
    \item $\Phi_T' =
      \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\ms_\stk.\aaddr}{w'}}$
    \item $r_i \neq \pcreg$ for all $i$
    \item One of the following hold:
      \begin{enumproof}
      \item (store) $w_1 = \Phi_T(r_1) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $w_1' = \Phi_S(r_1) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \writeAllowed{}$,
        and
        $\withinBounds{w_1}$, and\\
        $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $w_2 = \linCons{\Phi_S(r_2)}$, $w_2' = \linCons{\Phi_T(r_2)}$.
      \item (load) $ w_2' = \Phi_T(r_2) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, and $w_2 = \Phi_S(r_2) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \readAllowed{}$,
        $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and $\aaddr \in
        \dom(\Phi.\ms_\stk)$, and $\aaddr \in \dom(\Phi.\ms_\stk)$, and\\
        $w_1 = \Phi_S.\ms_\stk(\aaddr)$, and $w_1' = \Phi_T.\ms_\stk(\aaddr)$, and $w = \linCons{w_1}$, $w' = \linCons{w_1'}$, $\linConsPerm{\perm,w_1}$ and $\linConsPerm{\perm,w_1'}$.
      \end{enumproof}
    \end{itemize}
  \item \label{case:ftlr:store-load-jump} All of the following hold: (includes control-flow manipulation cases:
    jmp, jnz, xjmp, that can be handled mostly uniformly)
    \begin{itemize}
    \item $\Phi_S \step[\gc] \Phi_S'$
    \item $\Phi_T \step \Phi_T'$
    \item One of the following holds
      \begin{enumproof}
      \item(jnz) $\Phi_S' = \updPcAddr{\Phi_S}$ and $\Phi_T' =
        \updPcAddr{\Phi_T}$
      \item(jmp,jnz) $\Phi_S' = \Phi_S\updReg{\pcreg,r_1}{\Phi_S(r_1),w_1}$ and
        $\Phi_T' = \Phi_T\updReg{\pcreg,r_1'}{\Phi_T(r_1),w_1'}$ and
        $w_1 = \linCons{\Phi_S(r_1)}$ and $w_1' = \linCons{\Phi_T(r_1)}$
      \item(xjmp) $\Phi_S(r_1) = \sealed{\sigma,c_1}$ and $\Phi_S(r_2) =
        \sealed{\sigma,c_2}$ and $\Phi_T(r_1) = \sealed{\sigma,c_1'}$ and
        $\Phi_T(r_2) = \sealed{\sigma,c_2'}$ and $\Phi_S'(r_1,r_2) =
        \linCons{c_1},\linCons{c_2}$ and $\Phi_T'(r_1,r_2) =
        \linCons{c_1'},\linCons{c_2'}$ and\\
        $c_1' \neq \retptrc(\_)$ and $c_2' \neq \retptrd(\_)$ and
        $\nonExec{c_\data}$ and $\Phi_T'(\pcreg,\rdata) = c_1',c_2'$ and one of
        the following hold:
        \begin{enumproof}
        \item $c_1 \neq \retptrc(\_)$ and $c_2 \neq \retptrd(\_)$ and
          $\nonExec{c_\data}$ and $\Phi_S'(\pcreg,\rdata) = c_1,c_2$.
        \item $c_1 = \retptrc(\baddr,\eaddr,\aaddr)$, and $c_2 =
          \retptrd(\aaddr_\stk,\eaddr_{\stk,\priv})$ and $\Phi(r_\stk) =
          \stkptr{\rw,\stkb,\eaddr_\stk,\_}$ and $\Phi_S.\stk = \stk_\var{frame}
          :: (\aaddr,\ms_{\stk,\priv})$ and $\dom(\ms_{\stk,\priv} =
          [\eaddr_\stk+1,\eaddr_{\stk,\priv}])$ and $\Phi_S'.\ms_\stk =
          \ms_{\stk,\priv} \uplus \Phi_S.\ms_\stk$ and $\Phi_S'.\stk = \stk$ and
          \[
            \begin{split}
              \Phi_S' = \Phi_S&[\pcreg \mapsto ((\rx,\normal),\baddr,\eaddr,\aaddr)]\\
              &[\rstk \mapsto
              \stkptr{\rw,\stkb,\eaddr_{\stk,\priv},e_\stk+1}] \\
              &[\rdata,\rtmp{1},\rtmp{2},r_2 \mapsto 0, 0, 0, 0]
            \end{split}
          \]
        \end{enumproof}
      \end{enumproof}
    \end{itemize}
  \end{enumproof}
  \lau{TODO: Argue that the above is indeed the case.}

  By the above observation, we know that $\Phi_S \step[\gc] \Phi_S'$ and $\Phi_T \step
  \Phi_T'$ for some $\Phi_S'$ and $\Phi_T'$.
  According to Lemma~\ref{lem:lro-anti-red-gen}, it suffices to show:
  \[
    \npair[n-1]{(\Phi_S',\Phi_T')} \in \lro
  \]
  Consider each of the possible cases:

  In case \ref{case:ftlr:failed}, both executions go to $\failed$.
  In this case, the result follows vacuously by definition of $\lrol$ and $\lror$.
  \\\\
  In case \ref{case:ftlr:halted}, both source and target configuration halts in 0
  steps, so both directions of $\lro$ are trivially satisfied.
  \\\\
  In case \ref{case:ftlr:get-and-arith-op}, we use the induction hypothesis to conclude
  \[
    \npair[n-1]{(\Phi_S',\Phi_T')} \in \lro
  \]
  from the following facts:
  \begin{itemize}
  \item One of the following sets of requirements holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S$ is reasonable up to $n-1$ steps and $[\baddr,\eaddr] \subseteq \ta$
    \item $\trust = \untrusted$ and $[b,e] \mathrel{\#} \ta$ and $\npair[n-1]{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}
    This follows from the corresponding assumption of this lemma and the fact that $\Phi_S \nstep[1]{\gc} \Phi_S'$ and Lemma~\ref{lem:ec-reasonable-antired}, \ref{lem:ec-reasonable-downwards-closed}, and \ref{lem:downwards-closed}.
  \item $\Phi_S'(\pcreg) = \Phi_T'(\pcreg) = ((\rx,\normal),\baddr,\eaddr,\_)$:
    Follows from the definition of $\updPcAddr{}$ and the assumptions of this case.
  \item $\npair[n-1]{[\baddr,\eaddr]} \in \xReadCond{W_\pcreg}$:
    Follows from the corresponding assumption of this lemma using Lemma~\ref{lem:downwards-closed}.
  \item $\npair[n-1]{(\Phi_S.\reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)$:
    Follows from the corresponding assumption of this lemma using Lemma~\ref{lem:downwards-closed}, the definition of $\lrr$ and the fact that integers are always in $\lrvg{\trust}$ by definition.
  \item $\memSat[n-1]{\Phi_S.\mem,\Phi_S.\ms_\stk,\Phi_S.\stk,\Phi_T.\mem}{W_M}$:
    Follows from the corresponding assumption of this lemma using Lemma~\ref{lem:downwards-closed}.
  \item Theorem~\ref{thm:ftlr} holds for all $n'' < n-1$:
    follows from the corresponding assumption of this lemma, since $n - 1 < n$.
  \end{itemize}

  \lau{TODO: look through this case and find the place where the ''no seal cross boundary thing'' should have been used.
    (I have done this, and it does not seem necessary (?))}
  In case \ref{case:ftlr:call}, we may assume $r_1 \neq r_2$\footnote{If the register contains a data capability, then the execution fails in the step after the jump. If it is an executable capability, then the xjump fails as it does not permit executable capabilities for the data part.} and $r_i \neq \pcreg$ for $i \in \{1,2\}$\footnote{The pc is executable which causes the xjump to fail.} as this will cause the execution to fail.
  We need to let the target execution catch up.
  That is $\Phi_T' \nstep[15]{} \Phi_T''$ for
  \[
    \Phi_T'' = \Phi_T
    \begin{array}[t]{l}
      \update{\mem.\aaddr_\stk}{42} \\
      \updReg{\rstk}{((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1)} \\
      \updReg{\rretd}{\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)}} \\
      \updReg{\rretc}{\sealed{\sigma',((\perm,\normal),\baddr,\eaddr,\aaddr+\retoffset)}} \\
      \updReg{\rtmp{1}}{0}\\
      \updReg{r_1,r_2}{\linCons{\Phi_T(r_1)},\linCons{\Phi_T(r_2)}}\\
      \updReg{\pcreg}{c_1'}\\
      \updReg{\rdata}{c_2'}
    \end{array}
  \]
  where $\Phi_T(r_i) = \sealed{\sigma,c_i'} \text{ for $i\in\{1,2\}$}$ and $\retoffset = 15$ which is the offset to the return code.
  Now using Lemma~\ref{lem:lro-anti-red-gen} again, it suffices to show
  \[
    \npair[n-1]{(\Phi_S',\Phi_T'')} \in \lro
  \]
  By assumption, we have $\npair[n]{(\reg_S(r_i),\reg_T(r_i))} \in \lrvg{\trust}(W_{R,i})$ for some $W_{R,i}$ with $i \in \{1,2\}$.
  We know the capabilities in $r_1$ and $r_2$ are sealed capabilities, and by
  Lemma~\ref{lem:unique-h-sigma} and the definition of $\lrvg{\trust}$ we get
  $\npair[n-1]{(c_2,c_2')} \in H_\sigma \; \sigma \; \xi^{-1}(W_{R,2})$
  and w.l.o.g.\

  \begin{equation}
    \forall W' \future W_{R,1}, W_o, n' < n, \npair[n']{(c_2,c_2')} \in H_\sigma \; \sigma \; \xi^{-1}(W_o) \ldotp \npair[n']{c_1,c_2,c_1',c_2'} \in \lrexj(W'\oplus W_o)\label{eq:ftlr:call:sealed-code-assump}
  \end{equation}
  Now take $W_o = W_{R,2}$, take $n' = n-1$ and construct $W_{R,1}'$ as follows:

  By Lemma~\ref{lem:nsub-and-nsup-std} and the safety assumption on the register-file, there exists $S \supseteq [\baddr_\stk, \eaddr_\stk]$ such that for some $R : S \fun \powerset{\nats}$ we have $\biguplus_{r \in S} R(r) \supseteq [\baddr_\stk,\eaddr_\stk]$ and for all $r \in S$, $\pwfree[W_{R,1}](r).H \nequal \stdreg{R(r),\gc}{\pur}.H$ and $|R(r)| = 1$ and $\pwfree[W_{R,1}](r) \text{ is address-stratified}$.
  Now take $r_\var{priv\_stk}$ fresh and define
  \[
    W_{R,1}' = W_{R,1}[\free.R^{-1}([\aaddr_\stk,\eaddr_\stk]) \mapsto \revoked][\priv.r_\var{priv\_stk} \mapsto (\stareg[(\ms_{\stk\_\priv,S},\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}),\gc]{\spa,\square},\aaddr+\calllen)]
  \]
  We know $W_{R,1}' \future W_{R,1}$ as the revoked regions must have been $\spatial$ in $W_{R,q}$ (as they are owned by the part of the world assigned to the stack-register in the register-file relation).
  The static region for the private stack is an extension of the old world.

  Pick this world as $W'$ in Eq~\ref{eq:ftlr:call:sealed-code-assump}.
  Let $W_{R,2}'$ be the same world but with the ownership of $W_{R,2}$ and pick it for $W_o$.
  Now observe that also $W_{R,2}' \future W_{R,2}$ and use monotonicity of $H_\sigma$ with the above facts to get
  \[
    \npair[n-1]{c_1,c_2,c_1',c_2'} \in \lrexj(W_{R,1}'\oplus W_{R,2}')
  \]

  Now pick register files and memories such that they form $\Phi_S''$ (defined in
  the assumptions) and $\Phi_T''$ and for $W_R'$ and $W_M'$ (we define them below) show
  \begin{enumerate}[label=\roman*.]
  \item \label{case:ftlr:scall:world} $W_{R,1}'\oplus W_{R,2}' \oplus W_R' \oplus W_M'$ is defined.
  \item \label{case:ftlr:scall:reg} $\npair[n-1]{(\Phi_S''.\reg,\Phi_T''.\reg)} \in \lrr(\{\rdata\})(W_R')$
  \item \label{case:ftlr:scall:mem} $\memSat[n-1]{\Phi_S''.\mem,\Phi_S''.\stk,\Phi_S''.\ms_\stk,\Phi_T''.\mem}{W_M'}$
  \end{enumerate}
  to get
  \[
    \npair[n-1]{(\Phi_S',\Phi_T'')} \in \lro
  \]
  as desired.

  It remains to show \ref{case:ftlr:scall:world}-\ref{case:ftlr:scall:mem}, but first we note that we can deduce the following: From the assumption $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$ we get $r \in \addressable{\normal, \pwheap}$ and $\mscode$ such that $\dom(\mscode) \supseteq [\baddr,\eaddr]$ and $\pwheap(r) \nequal \codereg{\sigrets',\_,\mscode,\gc}$.
  Further by $\memSat{\ms_S,\stk,\ms_\stk,\ms_T}{W}$, we know that
  \begin{equation}
    \npair{(\mscode\uplus\mspad,\mscode\uplus\mspad)} \in H^{\var{code}} \; \sigrets' \; \sigcloss' \; \mscode \; (\ta,\_,\gsigrets,\gsigcloss)~ W_r\label{eq:ftlr:rretd:Hcode}
  \end{equation}
  where $\sigma' \in \sigrets'$ and $\dom(\mscode) \supseteq [\baddr,\eaddr]$ and $\aaddr + \offpc \in \dom(\mscode)$ and $W = W_r \oplus \_$.
  That is: $\mscode$ contains the call we are considering.
  This also entails
  \begin{equation}
    \label{eq:ftlr:code-comp-jud}
    \sigrets',\sigcloss' \vdash_\var{code\_comp} \mscode
  \end{equation}
  from \ref{eq:ftlr:rretd:Hcode} we also get
\begin{itemize}
\item $\dom(\mscode\uplus\mspad) \subseteq \ta$

  Otherwise we would have $\dom(\mscode\uplus\mspad) \# \ta$ which would contradict $\ta\supseteq [b,e] \subseteq\dom(\mscode\uplus\mspad)$

\item $\sigrets' \subseteq \gsigrets$

  Follows from the above.
\end{itemize}
  \lau{TODO: Make the above more precise and possibly put into a lemma (also needed in the next case).}


  Case \ref{case:ftlr:scall:world}: Pick $W_R'$ and $W_M'$ to have the regions of $W_{R,1}'$, but where $W_R'$ owns $r_\var{priv\_stk}$ and otherwise has the ownership of $W_R$ and $W$ with the exception of the regions owned by $W_{R,1}'$ and $W_{R,2}'$.
  $W_M'$ has the ownership of $W_M$.
  Case \ref{case:ftlr:scall:world} follows from assumption $W \oplus W_R \oplus W_M$.
  The only changes to the worlds is that some ownership has been shifted from $W_R$ to $W_{R,1}$ and $W_{R,2}$ and the ownership for $W$ now belongs to $W_R'$.
  In other words, no ownership has been duplicated.

  Case \ref{case:ftlr:scall:reg}: We need to split the ownership of $W_R'$.
  From assumption $\npair[n]{(\Phi_S.reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)$, we get a way to split the ownership of $W_R$.
  We take this as the starting point, but with the following changes: regions $r_1$ and $r_2$ maps to worlds with no ownership (i.e.\ $\purePart{W_{R,1}'}$).
  region $\rstk$ maps to a world with the same ownership, but of course without the now revoked regions.
  Region $\rretd$ maps to a world that owns private $r_\var{priv\_stk}$ region.
  Finally, $\rretc$ maps to a world with the ownership of $W$.

  we split the world in the same way for the registers that remain unchanged, the
  result follows from Lemma \ref{lem:downwards-closed} and \ref{lem:monotonicity}.
  \dominique{No: we need to use Lemma~\ref{lem:trusted-and-reasonable-is-untrusted} together with the reasonability of registers at a boundary crossing (if there is one).}

  This leaves the following cases:
  \begin{description}
  \item[Case $\rstk$:] Show:
    \[
      \npair[n-1]{(\stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1},((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1))} \in \lrv(W_{R,\rstk}')
    \]
    We know by Assumption $\npair[n]{(\Phi_S.reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)$, we know
    \[
      \npair[n]{(\stkptr{\rw,\baddr_\stk,\eaddr_\stk,\aaddr_\stk},((\rw, \linear), \baddr_\stk ,\eaddr_\stk, \aaddr_\stk)} \in \lrvg{\trust}(W_{R,\stk})
    \]
    which by the $\mathit{stackReadCondition}$ gives $S \subseteq \addressable{\linear,\pwfree}$ and $R : S \fun \powerset{\nats}$.
    We need to pick an $S'$ to argue
    \[
      \npair[n-1]{[\baddr_\stk,\aaddr_\stk-1]} \in \stackReadCond{W_{R,\rstk}'}
    \]
    To this end pick $S' = R^{-1}(\left(\bigcup_{r\in S} R(r) \right) \setminus [\aaddr_\stk,\eaddr_\stk])$ and $R'$ to be $R$ limited to $S'$.
    As we exclude all the revoked regions and the ownership otherwise remains the
    same in $W_{R,\rstk}'$ as in $W_{R,\rstk}$, the regions in $S'$ are exactly the same in the new world as they were in $W_{R,\rstk}$.
    So what we need to show follows immediately from
    \[
      \npair[n]{[\baddr_\stk,\eaddr_\stk]} \in \stackReadCond{W_{R,\rstk}}
    \]
    and by Lemma~\ref{lem:downwards-closed}.

    We show
    \[
      \npair[n-1]{[\baddr_\stk,\aaddr_\stk-1]} \in \stackWriteCond{W_{R,\rstk}'}
    \]
    in the same way.

  \item[Case $\rtmp{1}$:] Show:
    \[
      \npair[n-1]{(0,0)} \in \lrv(W_{R,\rtmp{1}}')
    \]
    Follows immediately from the definition.

  \item[Case $r_1$,$r_2$:] The two cases are symmetric, so we just show the $r_1$ case:
    \[
      \npair[n-1]{(\linCons{c_1},\linCons{\Phi_T(r_1)})} \in \lrv(W_{R,r_1}')
    \]
    Follows from the related register files assumption and Lemma~\ref{lem:lincons-lrv} and the fact that for sealed capabilities if they are in $\lrvg{\trusted}$, then they are in the $\lrv$ part.

  \item[Case $\rretd$:] We have to show
    \[
      \npair[n-1]{(\sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)},\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)})} \in \lrv(W_{R,\rretd}')
    \]
    where $W_{R,\rretd}'$ is the part of $W_R'$ with ownership over $r_\var{priv\_stk}$.

    Use the $r=r_{\mscode}$ as the witness.
    The $\xReadCond{}$ gives us $\pwheap(r) \nequal \codereg{\_,\_,\mscode,\gc}$.
    As it is a pure region, it is also present in the future world we consider.
    We now have to show:
    \begin{enumerate}[label=\alph*)]
    \item for $n'' < n-1$ we have
      \[\npair[n'']{\left(\array{l}\retptrd(\aaddr_\stk,\eaddr_\stk),\\((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)\endarray\right)}
        \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode'
        \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_{R,\rretd}')
      \]
      First, we already know $\dom(\mscode) \subseteq \ta$ and $\sigrets' \subseteq \gsigrets$.
      Now pick $r_\var{priv\_stk}$ as the witness.
      We immediately get $\dom(\ms_{\stk\_\priv,S}) = \dom(\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}) = [\aaddr_\stk,\eaddr_\stk]$.
      Next, $\decInstr{\mscode'(\aaddr,\aaddr+\calllen-1)} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}}$ follows from $\callCond{\Phi_S,r_1,r_2,\offpc,\offsigma,\aaddr}$.
      Finally, $\ms_\code(\aaddr+\offpc) = \seal{\sigma_\baddr,\sigma_\eaddr}$ with $\sigma' = \sigma_\baddr + \offpc \in \sigrets'$ which follows from $\sigrets',\sigcloss' \vdash_{\mathrm{comp-code}} \mscode$ and the fact that the call is there.
    \item $\isLinear{\sealed{\sigma',\retptrd(\aaddr_\stk,\eaddr_\stk)}}$ iff
      $\isLinear{\sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk)}}$\\
      Trivial, both are linear.
    \item
      \[
        \begin{array}{l}
          \forall W'' \future \purePart{W_{R,\rretd}'}, W_o, n'' < n-1,\\
          \quad\npair[n'']{(\vsc_S',\vsc_T')}
          \in  H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode'
          \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_o) \ldotp \\
          \qquad\npair[n'']{\retptrd(\aaddr_\stk,\eaddr_\stk),\vsc_S',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1),\vsc_T'} \in
          \lrexj(W'\oplus W_o))
        \end{array}
      \]
      Trivial as both configurations fails.
    \end{enumerate}

  \item[Case $\rretc$:]
    We have to show
    \[
      \npair[n-1]{\left(\array{l}\sealed{\sigma',\retptrc(\baddr,\eaddr,\aaddr +
            \calllen)},\\\sealed{\sigma',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)}\endarray\right)} \in \lrv(W_{R,\rretc}')
    \]
    where $W_{R,\rretc}'$ has the ownership of $W$.
    Just as in the previous case, we know that for some region $r$ there exists an $\mscode$ such that: $\pwheap(r) \nequal \codereg{\sigrets',\_,\mscode,\gc}$ where $\sigma' \in \sigrets'$ and $\dom(\mscode) \supseteq [\baddr,\eaddr]$ and $\aaddr + \offpc \in \dom(\mscode)$ and $\sigrets' \subseteq \gsigrets$.
    It follows easily from the definition of $H_\sigma^\var{code}$ that
    \begin{equation}
      \label{eq:code-caps-in-h-sigma}
      \npair[n'']{\left(\array{l}\retptrc(\baddr,\eaddr,\aaddr + \calllen),\\((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)\endarray\right)} \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_{R,\rretc}')
    \end{equation}
    for $n'' < n-1$.
    Both capabilities are non-linear, so
    \[
      \isLinear{\retptrc(\baddr,\eaddr,\aaddr + \calllen)}\text{ iff } \isLinear{((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset)}
    \]
    is indeed the case.

    Finally we need to show:
    \[
      \begin{array}{l}
        \forall W'' \future \purePart{W_{R,\rretc}'}, W_o, n'' < n-1,\\
        \quad  \npair[n'']{(\vsc_S',\vsc'_T)} \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_o) \ldotp \\
        \qquad \npair[n'']{\retptrc(\baddr,\eaddr,\aaddr + \calllen),\vsc_S',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset),\vsc_T'} \in \lrexj(W''\oplus W_o))
      \end{array}
    \]

    To this end let $W'' \future \purePart{W_{R,\rretc}'}$ and $W_o$ be given s.t. $W'' \oplus W_o$ is defined.
    Further, let $\npair[n'']{(\vsc_S',\vsc'_T)} \in H^\mathrm{code,\square}_\sigma \; \sigrets' \; \sigcloss' \; \mscode \; (\ta,\stkb) \; \sigma' \; \xi^{-1}(W_o)$ be given and show
    \[
      \npair[n'']{\retptrc(\baddr,\eaddr,\aaddr + \calllen),\vsc_S',((\rx,\normal),\baddr,\eaddr,\aaddr + \retoffset),\vsc_T'} \in \lrexj(W''\oplus W_o))
    \]

    Now let $n''' \leq n''$ be given along with $\reg[3]_S$, $\reg[3]_T$, $\ms^{(3)}_S$, $\ms^{(3)}_T$,$\ms^{(3)}_\stk$, $\stk^{(3)}$, $W_R''$, and $W_M''$ such that
    \begin{itemize}
    \item $W'' \oplus W_o \oplus W_R'' \oplus W_M''$ is defined
    \item $\memSat[n''']{\ms^{(3)}_S,\ms^{(3)}_\stk, \stk^{(3)}, \ms^{(3)}_T}{W_M''}$
    \item $\npair[n''']{(\reg[3]_S,\reg[3]_T)} \in \lrr(W_R'')$
    \end{itemize}

    Based on $H_\sigma^\var{code}$, there are three possible values for $\vsc_S'$ and $\vsc_T'$.
    In the first case, $\vsc_S'$ is a $\retptrc$ and $\vsc_T'$ is a capability with permission $\rx$.
    In this case, $\var{xjumpResult}$ will produce failed configurations which are trivially in the observation relation.
    In the next case, it is required that $\sigma' \in \sigcloss'$, but this
    cannot be the case as $\sigma' \in \sigrets'$ and we have $\sigrets',\sigcloss' \vdash_{\mathrm{comp-code}} \mscode$, which implies that $\sigcloss' \mathrel{\#} \sigrets'$.

    This leaves us with one final case, namely $\vsc_S'= \retptrd(\baddr_\stk',\eaddr_\stk')$ and $\vsc_T'=((\rw,\linear),\baddr_\stk',\eaddr_\stk',\baddr_\stk'-1)$.
    Further we know
    \[
      \begin{array}{l}
        \exists r \in \addressable{\linear,\pwpriv[W_o]} \ldotp \pwpriv[W_o](r).H \nequal (\stareg[(\ms_{\priv,S}^{(3)},\ms_{\priv,T}^{(3)}),\gc]{\spao,\square}, \aaddr'+\calllen) \tand \\
        \quad \dom(\ms_{\priv,S}^{(3)}) = \dom(\ms_{\priv,T}^{(3)}) = [\baddr_\stk',\eaddr_\stk'] \tand\\
        \quad \decInstr{\code([\aaddr',\aaddr' + \calllen-1])} = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}} \tand \\
        \quad \code(\aaddr'+\offpc) = \seal{\sigma_b,\sigma_e,\sigma_b} \tand \sigma = \sigma_b + \offsigma \in \sigrets
      \end{array}
    \]
    Call this region $r'$.
    By the above, the fact that the code capability pair is in $H_\sigma^\var{code}$ (\ref{eq:code-caps-in-h-sigma}) and Lemma~\ref{lem:unique-ret-seals}, we get $\aaddr' = \aaddr$.
    This means that $W_M''$ and $W_R''$ have this region.

    We know that the two register-files are related which in particular means that the values in register $\rstk$ are related.
    Now consider the following cases: 
    \begin{itemize}
    \item $\reg_S^{(3)}(\rstk) \neq \stkptr{\_,\_,\_,\_}$\\
      In this case due to $\reg[3]_S$ being related to $\reg[3]_T$, there are three cases we need to consider.
      In all cases, the source configuration will fail because the value in the stack register is not a stack capability.
      If we can argue that the target configuration will also fail, then the two are in the observation relation.
      First, if $\reg[3]_T = \sealed{\sigma_\var{ret\_\stk},\vsc_T''}$, then the return code will fail when the base address (a sealed capability has no base address, so the instruction returns $-1$) is compared to $\stkb$.
      Second, if $\reg[3]_T = \seal{\_,\_,\_}$, then the target execution fails when it attempts to splice this seal with $\vsc_T'$ (which we know is not a $\seal{}$ capability).
      Finally, $\reg[3]_T = ((\perm_\var{ret\_\stk},\lin_\var{ret\_\stk}),\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_)$ and $\npair[n''']{[\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk}]} \in \readCond{\lin_\var{ret\_\stk},W_{R,\rstk}''}$ is satisfied.
      This means that it is satisfied by some heap region, but by the memory satisfaction assumption $\stkb$ must be in the free stack part of the world.
      This means that the execution will fail that $\stkb$ check.

    \item $\reg_S^{(3)}(\rstk) = \stkptr{\perm_\var{ret\_\stk},\baddr_\var{ret\_\stk},\_,\_}$ and $\baddr_\var{ret\_\stk} \neq \stkb$\\
      Here the source side will fail the xjmp as the base address is not $\stkb$.
      Similarly on the target side, the return code will fail the $\stkb$ check.

    \item $\reg_S^{(3)}(\rstk) = \stkptr{\_,\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_}$ and $\baddr_\var{ret\_\stk} = \stkb$ and either $\eaddr_\var{ret\_\stk} +1 \neq \baddr_\stk' $ or $\perm_\var{ret\_\stk} \neq \rw$ or
      $\baddr_\var{ret\_\stk} > \eaddr_\var{ret\_\stk}$.\\
      In this case, the source configuration will fail as one of the conditions in $\var{xjumpResult}$ will not be met.
      On the target side, the splice will fail as either the two capabilities being spliced don't line up, the permissions don't match, or the range of authority is empty, respectively.

    \item $\reg_S^{(3)}(\rstk) = \stkptr{\perm_\var{ret\_\stk},\baddr_\var{ret\_\stk},\eaddr_\var{ret\_\stk},\_}$ and $\baddr_\var{ret\_\stk} = \stkb$ and $\eaddr_\var{ret\_\stk} +1 = \baddr_\stk' $ and $\perm_\var{ret\_\stk} = \rw$ and $\baddr_\var{ret\_\stk} \leq \eaddr_\var{ret\_\stk}$.
      \\
      We would like to show that $\ms_{\priv,S}^{(3)}$ is the top most stack frame and that $r'$ governs it.
      By the memory satisfaction assumption and the presence of $r'$ in $W_M''$ we know that $\stk^{(3)}$ is non-empty.
      By the memory satisfaction on the private stack, the following must be the case:
      \[
        \begin{array}{l}
          \stk^{(3)} = (\opc_0,\ms_0), \dots (\opc_m,\ms_m) \wedge \\
          \forall i \in \{0,\dots,m\} \ldotp (\dom(\ms_i) \neq \emptyset \wedge\\
          \quad \forall i < j \ldotp \forall a \in \dom(\ms_i) \ldotp \forall a' \in \dom(\ms_j) \ldotp \stkb < a < a')\\
        \end{array}
      \]

      Assume for contradiction $\ms_{\priv,S}^{(3)}$ is not the top frame. In that
      case $\dom(\ms_0) \neq \emptyset$ and $\forall a \in \dom(\ms_0) \ldotp
      \ldotp \stkb < a < b_\stk$ at the same time, we know
      \[
        \npair[n'']{(\stkptr{\rw,\stkb,\eaddr_\var{ret\_\stk},\_},((\rw,\linear),\stkb,\eaddr_\var{ret\_\stk},\_))}
        \in \lrv(W_{R,\rstk}'')
      \]
      which means that the free stack part of the world contains a region that at least governs $[\stkb,\eaddr_\var{ret\_\stk}]$.
      Combine this with $\eaddr_\var{ret\_\stk} +1 = \baddr_\stk' $, we can conclude that no such address can exist in $\ms_0$, so it must be empty, but this cannot be the case either.
      Therefore, the top stack frame must contain $\ms_{\priv,S}^{(3)}$.

      Further, due to the disjointedness required by memory satisfaction, it must be $r'$ that governs this stack frame.
      This also means that we have $\opc_0 =  \aaddr+\calllen$.
      With this, we have all the requirements for $\var{xjumpResult}$ satisfied on
      both sides which allows us to pick the necessary configurations:
      \begin{multline*}
        \Phi^{(4)}_S=\xjumpResult{r_1}{r_2}{(\ms_S^{(3)},\reg[3]_S,(\ms_{\priv,S}^{(3)},\aaddr+\calllen)
          :: \stk^{(3)}_\var{rest},\ms_\stk^{(3)})} =\\
        (\ms_S^{(3)},\reg[3]_S
        \arraycolsep=0pt
        \begin{array}[t]{l}
          \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen)} \\
          \updReg{\rdata}{0} \\
          \updReg{\rstk}{\stkptr{\rw,\stkb,e_\stk',\eaddr_\var{ret\_stk}+1}} \\
          \updReg{\rtmp{1}}{0} \\
          \updReg{\rtmp{2}}{0}
        \end{array}
        ,\stk^{(3)}_\var{rest},\ms_{\priv,S}^{(3)} \uplus \ms_\stk^{(3)})
      \end{multline*}
      and
      \begin{multline*}
        \Phi^{(4)}_T=\xjumpResult{r_1}{r_2}{(\ms_T^{(3)},\reg[3]_T)} =\\
        (\ms_T^{(3)},\reg[3]_S
        \arraycolsep=0pt
        \begin{array}[t]{l}
          \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\retoffset)} \\
          \updReg{\rdata}{((\rw,\linear),\stkb,\eaddr_\var{ret\_stk})}
        \end{array})
      \end{multline*}
      It now remains to show
      \[
        \npair[n''']{(\Phi^{(4)}_S,\Phi^{(4)}_T)} \in \lro
      \]
      Use Lemma~\ref{lem:lro-anti-red-gen} by which it suffices to show the
      following two things:
      \begin{itemize}
      \item
        \[
          \Phi^{(4)}_T \step[l] \Phi^{(5)}_T = (\ms_T^{(3)},\reg[3]_S
          \arraycolsep=0pt
          \begin{array}[t]{l}
            \updReg{\pcreg}{((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen)} \\
            \updReg{\rdata}{0} \\
            \updReg{\rstk}{((\rw,\linear),\stkb,e_\stk',\eaddr_\var{ret\_stk}+1)} \\
            \updReg{\rtmp{1}}{0} \\
            \updReg{\rtmp{2}}{0}
          \end{array})
        \]
        for some number of steps $l$. This follows immediately from the
        operational semantics.
      \item
        \[
          \npair[n''']{(\Phi^{(4)}_S,\Phi^{(5)}_T)} \in \lro
        \]
        For fresh $r_{b_\stk'}\dots r_{e_\stk'}$ and $W'''$ defined as
        \[
          W''' = W''[\priv.r' \mapsto \revoked,\free.r_{b_\stk'}\dots r_{e_\stk'}\mapsto \stdreg{\{b_\stk'\},\gc}{\spa} \dots \stdreg{\{e_\stk'\},\gc}{\spa}]
        \]
        and $W'''_R$ the same as $W'''$, but with the ownership of $W''_R$ as well as for the regions $r_{b_\stk'}\dots r_{e_\stk'}$,
        and $W'''_M$ the same as $W'''$ but with the ownership of $W''_M$,
        we show the following:
        \begin{enumproof}
        \item $\npair[n''']{(\Phi_S^{(4)}.\reg,\Phi_T^{(5)}.\reg)} \in \lrr(W'''_R)$
        \item $\memSat[n''']{\Phi_S^{(4)}.\mem,\Phi_S^{(4)}.\stk,\Phi_S^{(4)}.\ms_\stk,\Phi_T^{(5)}.\mem}{W'''_M}$ 
        \item $W''' \oplus W'''_R \oplus W'''_M$ defined
        \end{enumproof}

        Assuming the above, we use our assumption that Theorem~\ref{thm:ftlr} holds for all $n' < n$ to get
        \[
          \npair[n''']{(((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen),((\rx,\normal),\baddr,\eaddr,\aaddr+\calllen))} \in \lre(W''')
        \]
        Note that from assumption ``$\Phi_S$ reasonable up to $n$ steps'' and Lemma~\ref{lem:ec-reasonable-downwards-closed} and $n''' \le n'' < n - 1$ we get ``$\Phi_S$ reasonable up to $n'''+1$ steps'' from which it follows that ``$\Phi_S(\pcreg) + \calllen$ reasonable up to $n'''$ steps''.
        Using this along with the register-file safety and memory satisfaction,
        we get
        \[
          \npair[n''']{(\Phi^{(4)}_S,\Phi^{(5)}_T)} \in \lro
        \]
        as desired. We need to show the three things we skipped:

        Show:
        \[
          \npair[n''']{(\Phi_S^{(4)}.\reg,\Phi_T^{(5)}.\reg)} \in \lrr(W'''_R)
        \]
        We will split the world like in $\npair[n''']{(\reg_S^{(3)},\reg_T^{(3)})} \in \lrr(W)$, but where $r_\stk$ also get the ownership of $r_{b_\stk'}\dots r_{e_\stk'}$.
        We need to show the following
        \begin{itemize}
        \item Case $\rdata$, $\rtmp{1}$, $\rtmp{2}$:

          Trivial.
        \item Case $r \not\in \{\rdata,\rtmp{1},\rtmp{2},\pcreg,\rstk\}$:

          We have $\Phi^{(4)}_S.\reg(r) = \reg^{(3)}_S(r)$ and $\Phi^{(5)}_T.\reg(r) = \reg^{(3)}_T(r)$.
          We already know:
          \[\npair[n''']{(\reg^{(3)}_S(r),\reg^{(3)}_T(r))} \in \lrr(W''_{R,r}),\]
          This is true for some $W_{R,r}''$ which does not have the ownership of the regions that are revoked in $W_R'''$, so that we can take the corresponding $W_{R,r}'''$ and have $W_{R,r}''' \future W_{R,r}''$.
          From Lemma~\ref{lem:monotonicity}, we then get
          \[
            \npair[n''']{(\reg^{(3)}_S(r),\reg^{(3)}_T(r))} \in \lrr(W'''_{R,r})
          \]
          as desired.
        \item Case $\rstk$:

          For this case, we need to show
          \[
            \npair[n''']{[\stkb,e_\stk']} \in \stackReadCond{W'''_{R,\rstk}}
          \]
          and
          \[
            \npair[n''']{[\stkb,e_\stk']} \in \stackWriteCond{W'''_{R,\rstk}}
          \]
          For $W'''_{R,\rstk}$ that owns the same as $W''_{R,\rstk}$ as well as $r_{b_\stk'},\dots,r_{e_\stk'}$.

          For the first part, we use $\npair[n''']{(\reg_S^{(3)}(\rstk),\reg_T^{(3)}(\rstk))} \in \lrv(W_{R,\rstk}'')$ and the fact that the stack capability must have $\rw$ permission from which it follows that
          \[
            \npair[n''']{[\stkb,e_\var{ret\_stk}]} \in \stackReadCond{W''_{R,\rstk}}
          \]
          which gives us $S_\free \subseteq \addressable{\linear,\pwfree}$ and $R_\free : S_\free \fun \powerset{\nats}$ such that
          \begin{itemize}
          \item $\forall r \in S_\free \ldotp |R(r)| = 1$
          \item $\biguplus_{r \in S_\free} R(r) \subseteq [\stkb,e_\var{ret\_stk}]$
          \item $\forall r \in S_\free \ldotp \pwfree(r) \nsupeq \stdreg{R(r),\gc}{\spao}$
          \end{itemize}
          Now pick $S_\var{read} = S_\free \cup \{r_{b_\stk'},\dots,r_{e_\stk'}\}$ and
          \[
            R_\var{read}(r) =
            \begin{cases}
              R_\var{read}(r) & r \in S_\var{read} \\
              \{a\} & r \in \{r_{b_\stk'},\dots,r_{e_\stk'}\} \wedge r = r_a
            \end{cases}
          \]
          It is clearly the case that $\forall r \in S_\var{read} \ldotp |R_\var{read}(r)| = 1$ and $\biguplus_{r \in S_\var{read}} R(r) \subseteq [\stkb,e_\var{ret\_stk}]$.
          For $\forall r \in S_\var{free} \ldotp \pwfree(r) \nsupeq \stdreg{R(r),\gc}{\spao}$ it follows from $\forall r \in S_\free \ldotp \pwfree(r) \nsupeq \stdreg{R(r),\gc}{\spao}$ and $\pwfree(r) = \stdreg{R(r),\gc}{\spao}$ for $r \in \{r_{b_\stk'},\dots,r_{e_\stk'}\}$.

          The $\var{stackReadCondition}$ is shown in the same way, but we also use Lemma~\ref{lem:stdreg-singleton-addr-strat} to argue that the new regions are address-stratified.
        \end{itemize}

        Show:
        \begin{equation}
          \memSat[n''']{\ms^{(3)}_S,\Phi_S^{(4)}.\stk,\ms_\stk^{(3)} \uplus \ms_{\priv,S}^{(3)} ,\ms^{(3)}_T}{W'''_M}\label{eq:ftlr:case:last-mem-sat}
        \end{equation}

        From the assumption $\memSat[n''']{\ms^{(3)}_S,\ms^{(3)}_\stk, \stk^{(3)}, \ms^{(3)}_T}{W_M''}$, we know
        \begin{itemize}
        \item $\stk = (\addr + \calllen,\ms_{\priv,S}^{(3)})::(\opc_1,\ms_1):: \dots :: (\opc_m,\ms_m)$
        \item $\ms^{(3)}_S \uplus \ms^{(3)}_\stk \uplus \ms_{\priv,S}^{(3)} \uplus \ms_1 \uplus \dots \uplus \ms_m  \text{ is defined}$
        \item $W''_M = W_{\var{stack}}'' \oplus W_{\var{free\_stack}}'' \oplus W_{\var{heap}}''$
        \item $\ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}, \ms_{T,f}, \ms_{S,f}, \ms_S',\overline{\sigma}$ such that
          \begin{itemize}
          \item $\ms^{(3)}_S = \ms_{f,S} \uplus \ms_S'$
          \item $\ms^{(3)}_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus \ms_\var{T,heap} \uplus \ms_{T,f}$
          \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}''}$
          \item $\memSatFStack{\ms^{(3)}_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}''}$
          \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(\pwheap)(W_{\var{heap}}'')$
          \end{itemize}
        \end{itemize}
        We will pick the same things to show \ref{eq:ftlr:case:last-mem-sat} with a few changes.
        We have to show
        \begin{itemize}
        \item $\Phi_S^{(4)}.\stk = (\opc_1,\ms_1):: \dots :: (\opc_m,\ms_m)$

          By the memory satisfaction assumption and the change to the stack.
        \item $\ms^{(3)}_S \uplus \ms^{(3)}_\stk \uplus \ms_{\priv,S}^{(3)} \uplus \ms_1 \uplus \dots \uplus \ms_m \text{ is defined}$

          By the memory satisfaction assumption.
        \item $W'''_M = W_{\var{stack}}''' \oplus W_{\var{free\_stack}}''' \oplus W_{\var{heap}}'''$

          Define the new worlds to have the ownership of their $W_M''$ counterparts except $W_{\var{stack}}'''$ does not take ownership of the regions used for the safety of addresses $b_\stk',\dots,e_\stk'$.
          This ownership goes to $W_{\var{free\_stack}}'''$ instead.
        \item We need to pick partitions of $\ms^{(3)}_T$ and a frame for $\ms^{(3)}_S$.
          We pick the same as we get from the memory satisfaction assumption except we pick the free stack partition of the target memory to be $\ms_\var{T,free\_stack} \uplus \ms_{\priv,S}^{(3)}$ and the stack partition to be $\ms_\var{T,stack}\setminus \ms_\var{T,stack} | _{\dom(\ms_{\priv,S}^{(3)})}$
        \item $\ms^{(3)}_S = \ms_{f,S} \uplus \ms_S'$

          By assumption.
        \item $\ms^{(3)}_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus \ms_\var{T,heap} \uplus \ms_{T,f}$

          By assumption and the fact that the only change is that we moved part of the stack to the free stack.
        \item $\memSatStack{(\opc_1,\ms_1):: \dots :: (\opc_m,\ms_m),\ms_\var{T,stack}\setminus \ms_\var{T,stack} | _{\dom(\ms_{\priv,S}^{(3)})}}{W_{\var{stack}}'''}$

          Follows easily from the private stack satisfaction assumption.
          The distribution functions from the assumption are simply limited to forget about the now revoked region and extend the world partition to be on $W_M'''$, but with the same ownership as in the one we had in the assumption.
          All the new partitions are future worlds of the old ones as none of them owned the revoked region (it was owned by $W_R''$).
        \item $\memSatFStack{\ms^{(3)}_\stk \uplus \ms_{\priv,S}^{(3)},\ms_\var{T,free\_stack} \uplus \ms_\var{T,stack} | _{\dom(\ms_{\priv,S}^{(3)})}}{W_{\var{free\_stack}}'''}$

          From the $\memSatFStack{\ms^{(3)}_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}''}$ assumption we get $R_\ms : \dom(\activeReg{W_{\var{free\_stack}}''}) \fun \MemSeg \times \MemSeg$ and $R_W : \dom(\activeReg{W_{\var{free\_stack}}''}.\free) \fun \Worlds$ for which
          \begin{itemize}
          \item $\ms^{(3)}_\stk = \biguplus_{r \in \dom(\activeReg{W_{\var{free\_stack}}''.\free})} \pi_1(R_\ms(r))$
          \item $\ms_\var{T,free\_stack} = \biguplus_{r \in \dom(\activeReg{W_{\var{free\_stack}}''.\free})} \pi_2(R_\ms(r))$
          \item $\stkb \in \dom(\ms^{(3)}_\stk)$ and $\stkb \in \dom(\ms_\var{T,free\_stack})$
          \item $W_{\var{free\_stack}}'' \bigoplus_{r \in \dom(\activeReg{W_{\var{free\_stack}}''.\free})} R_W(r)$
          \item $\forall r \in \dom(\activeReg{W_{\var{free\_stack}}''.\free})\ldotp \npair[n''']{R_\ms(r)} \in W_{\var{free\_stack}}''.\free(r).H \; \xi^{-1}(R_W(r))$
          \end{itemize}
          Now pick
          \[
            R_\ms'(r) =
            \begin{cases}
              (\ms_{\priv,S}^{(3)}|_{\{a'\}} , \ms_\var{T,stack}|_{\{a'\}}) & r_{a'} \in \{r_{b_\stk'}\dots r_{e_\stk'}\}\\
              R_\ms(r) & \totherwise
            \end{cases}
          \]
          and
          \[
            R_W'(r) =
            \begin{cases}
              W'''_{a'} & r_{a'} \in \{r_{b_\stk'}\dots r_{e_\stk'}\} \\
              R_W(r)[\priv.r' \mapsto \revoked,\free.r_{b_\stk'}\dots r_{e_\stk'}\mapsto \stdreg{\{b_\stk'\},\gc}{\spa} \dots \stdreg{\{e_\stk'\},\gc}{\spa}]& \totherwise
            \end{cases}
          \]
          for $W'''_{a'}$ constructed as follows: $W_{\var{stack}}''$ is the part of the world given to the stack judgement in the assumption.
          This world is split into a number of parts to satisfy the memory interpretation of each frame.
          Say $W_{top,\var{stack}}''$ is used for the top stack frame in the assumption.
          The top stack frame is governed by a static region, so by definition it is split into parts that satisfy each of the addresses.
          That is for $a' \in \{b_\stk' \dots e_\stk'\}$, $W_{a'}''$ is the part that makes the value in memory satisfy the value relation.
          Now let $W_{a'}'''$ be $W'''$ but with the ownership of $W_{a'}''$

          It is easy to see that the $R_\ms'$ constructs the two memories, and
          from the assumption, we also get that the base stack address is in there.

          It remains to show
          \[
            \forall r \in \dom(\activeReg{W_{\var{free\_stack}}'''.\free}) \in \npair[n''']{R_\ms(r)} \in W_{\var{free\_stack}}'''.\free(r).H \; \xi^{-1}(R_W(r))
          \]
          for $r \in \dom(\activeReg{W_{\var{free\_stack}}'''.\free}) \setminus \{r_{b_\stk'}\dots r_{e_\stk'}\}$, it follows from monotonicity of the $H$ (memory interpretation) function.
          For $r_{a'} \in \{r_{b_\stk'}\dots r_{e_\stk'}\}$, we need to show
          \[
            \npair[n''']{(\ms_{\priv,S}^{(3)}(a') , \ms_\var{T,stack}|(a'))} \in \stdreg{\{a\},\gc}{\spa}.H (\xi^{-1}R_W(r_{a'}))
          \]
          which amounts to showing $\dom(\ms_{\priv,S}^{(3)}|_{\{a'\}}) = \dom(\ms_\var{T,stack}|_{\{a'\}}) \{a'\}$, which is the case, and
          \[
            \npair[n''']{(\ms_{\priv,S}^{(3)}(a') , \ms_\var{T,stack}|(a'))} \in \lrv (W_{a'}''')
          \]
          Which follows from Lemma~\ref{lem:monotonicity} and the fact that we have a memory satisfaction assumption in which $\ms_{\priv,S}^{(3)}$ is governed by a standard static region.

        \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(\pwheap)(W_{\var{heap}}''')$

          Follows by Lemma~\ref{lem:monotonicity} and the heap satisfaction assumption.
        \end{itemize}

        Argue:
        \[
          W''' \oplus W'''_R \oplus W'''_M \text{ is defined.}
        \]
        This follows from the assumption $W'' \oplus W''_R \oplus W''_M$ and the fact that each of the new worlds is constructed from one of the past worlds and only one of them claims the ownership of the new regions.
      \end{itemize}
    \end{itemize}


\end{description}
This concludes case \ref{case:ftlr:scall:reg}

  Case \ref{case:ftlr:scall:mem}:
  we need to show:
  \[
    \memSat[n-1]{\Phi_S''.\mem,\Phi_S''.\stk,\Phi_S''.\ms_\stk,\Phi_T''.\mem}{W_M'}
  \]
  which amounts to
  \[
    \memSat[n-1]{\Phi_S.\mem,((\aaddr+\calllen),\ms_{\stk\_\priv,S}) :: \Phi_S,\Phi_S.\ms_\stk - \Phi_S.\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]},\Phi_T''.\mem}{W_M'}
  \]
  for $\ms_{\stk\_\priv,S} = \Phi_S.\ms_\stk |_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}$.

  In order to show this, we will first show the following:
  \begin{itemize}
  \item $\baddr_\stk = \stkb$

    We know $\Phi_S$ is reasonable up to $n$ steps.
    Further, from $\callCond{\Phi_S,r_1,r_2,\offpc,\offsigma,a}$ and $b \leq a$ and $a + \calllen -1 \leq e$ and $[b,e] \subseteq \ta$ we can conclude that $\Phi_S$ points to $\src{\scall{\offpc,\offsigma}{r_1}{r_2}}$ in $\ta$.
    By the \emph{Guarantee stack base address before call} we then know $\Phi_S(r_\stk) = \stkptr{\_,\stkb,\_,\_}$.
  \end{itemize}

  By assumption we have
  $\memSat{\Phi_S.\mem,\Phi_S.\stk,\Phi_S.\ms_\stk,\Phi_T.\mem}{W_M}$ which
  gives us $\ms_\var{T,stack}, \ms_\var{T,free\_stack},$ $\ms_\var{T,heap},
  \ms_{T,f}, \ms_{S,f}, \ms_S', W_{M,\var{stack}}, W_{M,\var{free\_stack}},
  W_{M,\var{heap}}$ such that:
  \begin{itemize}
  \item $\Phi_S.\stk = (\opc_0, \ms_0) \dots (\opc_m,\ms_m)$
  \item $\ms_0 \uplus \dots \uplus \ms_m \uplus \Phi_S.\mem \uplus \Phi_S.\ms_\stk$
  \item $W_M = W_{M,\var{stack}} \oplus W_{M,\var{free\_stack}} \oplus W_{M,\var{heap}}$
  \item $\Phi_S.\mem = \ms_{f,S} \uplus \ms_S'$
  \item $\Phi_T.\mem = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\Phi_S.\stk,\ms_\var{T,stack}}{W_{M,\var{stack}}}$
  \item $\memSatFStack{\Phi_S.\ms_\stk,\ms_\var{T,free\_stack}}{W_{M,\var{free\_stack}}}$
  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(\pwheap[W_M])(W_{M,\var{heap}})$
  \end{itemize}

  In order to prove the memory satisfaction, we pick the same memories except for the following changes:
  \begin{itemize}
  \item The target free stack partition: $\ms_\var{T,free\_stack} \setminus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}$
  \item The target private stack partition: $\ms_\var{T,stack} \uplus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}$
  \end{itemize}
  and the worlds
  \begin{itemize}
  \item Free stack world: $W_{M,\var{free\_stack}}'$ is $W_{R,1}'$ with the ownership of $W_{M,\var{free\_stack}}$ except that it gives up any ownership that we used for the safety of the addresses $[\aaddr_\stk,\eaddr_\stk]$.
  \item Private stack world: $W_{M,\var{stack}}'$ is $W_{R,1}'$ with the ownership of $W_{M,\var{stack}}$ except that it takes the ownership that $W_{M,\var{free\_stack}}$ used for the safety of the addresses $[\aaddr_\stk,\eaddr_\stk]$.
  \item Heap world: $W_{M,\var{heap}}'$ is $W_{R,1}'$ with the ownership of $W_{M,\var{heap}}$ which gives us $W_{M,\var{heap}}' \future W_{M,\var{heap}}$.
  \end{itemize}
  We now need to show:
  \begin{itemize}
  \item $\stk = ((\aaddr+\calllen),\ms_{\stk\_\priv,S}) :: (\opc_0, \ms_0) \dots (\opc_m,\ms_m)$

    Trivial.
  \item $\ms_{\stk\_\priv,S} \uplus \ms_0 \uplus \dots \uplus \ms_m \uplus \Phi_S.\mem \uplus \Phi_S.\ms_\stk - \Phi_S.\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}$

    Follows by assumption and the fact that we have shuffled around some memory\footnote{Thanks to the register-file safety assumption we know for sure that the memory we remove from the free stack is actually there.}.
  \item $W_M' = W_{M,\var{stack}}' \oplus W_{M,\var{free\_stack}}' \oplus W_{M,\var{heap}}'$

    This follows by assumption and the fact that all ownership we have added to a world has been removed from another.
  \item $\Phi_S.\mem = \ms_{f,S} \uplus \ms_S'$

    By assumption.
  \item $\Phi_T.\mem = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42} \uplus \ms_\var{T,free\_stack} \setminus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]} \uplus \ms_\var{T,heap} \uplus \ms_{T,f}$

    Follows by assumption and the fact that we have shuffled around some memory\footnote{Thanks to the register-file safety assumption we know for sure that the memory we remove from the free stack is actually there.}.
  \item $\memSatStack{((\aaddr+\calllen),\ms_{\stk\_\priv,S}) :: \Phi_S,\ms_\var{T,stack} \uplus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}}{W_{M,\var{stack}}'}$:

    For most of the conditions, they follow from the previous stack satisfaction assumption.
    The only challenge is to argue that the new stack frame satisfies the conditions.
    First of all, we know $\ms_{\stk\_\priv,S}$ is non-empty as it at least contains address $\aaddr_\stk$.
    Next, we need to argue that
    \[
      \begin{array}{l}
        \forall i \in \{0,\dots,m\} \ldotp \\
        \quad \forall a \in \dom(\ms_{\stk\_\priv,S}) \ldotp \forall a' \in \dom(\ms_j) \ldotp \stkb < a < a') \wedge\\
      \end{array}
    \]
    The first bit, $\stkb < a$ for $a \in \dom(\ms_{\stk\_\priv,S})$ follows from the fact that $a_\stk$ is the smallest address of $a \in \dom(\ms_{\stk\_\priv,S})$ and by assumption $\stkb < a_\stk$.

    Now assume for contradiction that there exists $a' \in \dom(\ms_j)$ for some $j$ such that $a' \le a$ for some $a \in \dom(\ms_{\stk\_\priv,S})$.
    By assumption we have $\stkb < a'$ so $a' \in [\stkb+1,a] \subseteq [\stkb+1,a_\stk] \subseteq [\stkb,e_\stk]$ which means that $a'$ is an address governed by a stack pointer.
    By the register-safety assumption this must mean that it is an address of the free part of the stack.
    At the same time, it must be an address of the private stack because $\ms_j$ is part of the stack from the original configuration.
    This contradicts the initial memory satisfaction assumption as the different parts must be disjointed.

    From the stack satisfaction assumption, we get $R_\ms$ and $R_W$. Pick
    \[
      R_\ms'(r) =
      \begin{cases}
        (\ms_{\stk\_\priv,S}, (\aaddr+\calllen),\ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42})& \text{for $r = r_\var{priv\_stk}$}\\
        R_\ms(r) & \totherwise
      \end{cases}
    \]
    and for $R_W'$ pick
    \[
      R_W'(r) =
      \begin{cases}
        W_{M,\var{free\_stack},[\aaddr_\stk,\eaddr_\stk]}[\free.R^{-1}([\aaddr_\stk,\eaddr_\stk]) \mapsto \revoked][\priv.r_\var{priv\_stk} \mapsto (\stareg[(\ms_{\stk\_\priv,S},\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}),\gc]{\spa,\square},\aaddr+\calllen)]
        & \text{for $r = r_\var{priv\_stk}$} \\
        R_W(r)[\free.R^{-1}([\aaddr_\stk,\eaddr_\stk]) \mapsto \revoked][\priv.r_\var{priv\_stk} \mapsto (\stareg[(\ms_{\stk\_\priv,S},\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}),\gc]{\spa,\square},\aaddr+\calllen)] &
      \end{cases}
    \]
    where $W_{M,\var{free\_stack},[\aaddr_\stk,\eaddr_\stk]}$ is the world that the free stack assumption uses to satisfy that range of addresses.

    Most of the condition trivially holds. 
    % This follows in part by mono of the interpretation function and the worlds
    % picked are future worlds of the past worlds.
    The only one that requires some argumentation is
    \[
      \npair[n-1]{(\ms_{\stk\_\priv,S},\ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42})}
      \in
      \stareg[(\ms_{\stk\_\priv,S},\Phi_T''.\mem|_{[\aaddr_\stk,\eaddr_\stk]}),\gc]{\spa,\square}.H
      \; \xi^{-1}(R_W'(r_\var{priv\_stk}))
    \]
    Where $R_W'(r_\var{priv\_stk})$ is the part of $W_{M,\var{stack}}'$ with the ownership used for addresses $[\aaddr_\stk, \eaddr_\stk]$ in the memory satisfaction assumption.

    As we have the safe register-file assumption, we know that the stack capability is safe.
    This means that addresses $[\aaddr_\stk,\eaddr_\stk]$ must be part of the free stack.
    Further, $\Phi''_T.\mem = \Phi_T.\mem\update{\aaddr_\stk}{42}$ and $\ms_\var{T,free\_stack} \subseteq \Phi_T.\mem$ and $\dom(\ms_\var{T,free\_stack}) \supseteq [\aaddr_\stk,\eaddr_\stk]$ from which it follows that the memories are equal to the one of the static region.

    It remains to show
    \[
      \forall \aaddr \in [\aaddr_\stk,\eaddr_\stk] \ldotp \npair[n-1]{(\ms_{\stk\_\priv,S}(\aaddr),\ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}(\aaddr))} \in \lrv(W_{R,\aaddr}')
    \]
    for $\aaddr = \aaddr_\stk$ it is trivial as we have to show
    \[
      \npair[n-1]{(42,42)} \in \lrv(W_{R,\aaddr_\stk}')
    \]
    for $\aaddr \in [\aaddr_\stk+1,\eaddr_\stk]$ we need to show
    \[
      \npair[n-1]{(\ms_{\stk\_\priv,S}(\aaddr),\ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}(\aaddr))} \in \lrv(W_{R,\aaddr}')
    \]
    If we can show
    \[
      \npair[n-1]{(\Phi_S.\ms_\stk(\aaddr),\ms_\var{T,free\_stack}(\aaddr))} \in \lrv(W_{R,\aaddr})
    \]
    then we are done by monotonicity of $\lrv$.

    By assumption we know $\npair{(\Phi_S.\reg,\Phi_T.\reg)} \in \lrr(W_R)$ which entails $\npair{(\Phi_S.\reg(\rstk),\Phi_T.\reg(\rstk))} \in \lrr(W_{R,\rstk})$.
    We know $\Phi_S.\reg(\rstk) = \stkptr{\rw,\stkb,\eaddr_\stk,\aaddr_\stk}$, so by the definition of $\lrv$ we get
    \[
      \npair{[\stkb,\eaddr_\stk]} \in \stackReadCond{W_{R,\rstk}}
    \]
    which in turn gives us $S_{\rstk} \subseteq \addressable{\linear,\pwfree}$ and
    $R_{\rstk} : S_{\rstk} \fun \powerset{\nats}$ for which
    \begin{itemize}
    \item $\forall r \in S_{\rstk} \ldotp |R_{\rstk}(r)| = 1$
    \item $\uplus_{r \in S_{\rstk}} R_{\rstk}(r) \supseteq [\stkb,\eaddr_\stk]$
    \item $\forall r \in S_{\rstk} \ldotp W_{R,\rstk}(r).H \nsubeq \stdreg{R_{\rstk}(r),\gc}{\spao}$
    \end{itemize}
    Further, we know $\memSatFStack{\Phi_S.\ms_\stk,\ms_\var{T,free\_stack}}{W_{M,\var{free\_stack}}.\free}$ which means that we have $R_\ms : \dom(\activeReg{W_{M,\var{free\_stack}}}) \fun MemSeg \times \MemSeg$ and $R_W : \dom(W_{M,\var{free\_stack}}.\free) \fun \Worlds$.
    $R_W$ distributes the ownership of $W_{M,\var{free\_stack}}$ and $R_\ms$ partitions the memories.

    We know that all regions in $S_{\rstk}$ govern singleton memory segments, so $R_\ms$ must map to singleton memory segment pairs for $r \in S_{\rstk}$.
    Further, by definition of the free stack satisfaction for $r \in S_{\rstk}$ we have
    \[
      \npair{R_\ms(r)} \in W_{R,\rstk}(r).H \; \xi^{-1}(R_W(r))
    \]
    which entails
    \[
      \npair[n-1]{R_\ms(r)} \in \stdreg{R_{\rstk}(r),\gc}{\spao}.H \; \xi^{-1}(R_W(r))
    \]
    which entails
    \[
      \npair[n-1]{R_\ms(r)(a)} \in \lrv (R_W(r))
    \]
    for $a \in R_{\rstk(r)}$.

    Now this is exactly what we wanted to show because $R_W(r)$ is what we picked as $W_{R,\aaddr}$.
  \item $\memSatFStack{\Phi_S.\ms_\stk - \Phi_S.\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]},\ms_\var{T,free\_stack} \setminus \ms_\var{T,free\_stack}|_{[\aaddr_\stk,\eaddr_\stk]}}{W_{M,\var{free\_stack}}'}$:

    From the safety assumption on the stack capability, we can deduce a number of things:
    \begin{itemize}
    \item $[\aaddr_\stk,\eaddr_\stk]$ must have been part of the free stack
    \item for every address in $[\aaddr_\stk,\eaddr_\stk]$ there is a region for that singleton memory segment.
    \end{itemize}
    The first part means that we do indeed remove all of the memory we try to subtract.
    The latter means that we can reuse the same split of the remaining memory and the world ownership as we get from assumption $\memSatFStack{\Phi_S.\ms_\stk,\ms_\var{T,free\_stack}}{W_{M,\var{free\_stack}}}$.
    Using this, the result follows from monotonicity of the $H$ function.

  \item $\npair{(\overline{\sigma},\ms_S',\ms_\var{T,heap})} \in \lrheap(\pwheap[W_M'])(W_{M,\var{heap}}')$:

    Follows from Lemma~\ref{lem:heap-sat-unchanged-future}, the fact the the heap part of the world remains unchanged and $W_{M,\var{heap}}' \future W_{M,\var{heap}}$.
  \end{itemize}

  Case \ref{case:ftlr:move-cca-etc}:

  First show that
  \[
    \npair[n-1]{(((\rx,\normal),\baddr,\eaddr,\aaddr),((\rx,\normal),\baddr,\eaddr,\aaddr))} \in \lrvg{\trust}(\purePart{W_R})
  \]
  First observe that by Lemma~\ref{lem:purePart-oplus} $\purePart{W_R} = \purePart{W_\pcreg}$.
  Further, by assumption, Lemma~\ref{lem:downwards-closed}, Lemma~\ref{lem:purePart-oplus}, and Lemma~\ref{lem:non-linear-pure}, we have
  \[
    \npair[n-1]{[\baddr,\eaddr]} \in \xReadCond{}(\purePart{W_R})
  \]

  If $\trust = \trusted$, then by assumption we have $[\baddr,\eaddr] \subseteq \ta$ which means that all the conditions for are met for the capability pair to be in the trusted part of the value relation.

  If $\trust = \untrusted$, then we need to show that the capability pair is in the untrusted part of the value relation which means that we need to show:
  \begin{itemize}
  \item $\npair[n-1]{[\baddr,\eaddr]} \in \readCond{}(\normal,\purePart{W_R})$

    This follows by assumption, Lemma~\ref{lem:non-linear-pure}, Lemma~\ref{lem:purePart-oplus}, and Lemma~\ref{lem:downwards-closed}.
  \item $\npair[n-1]{[\baddr,\eaddr]} \in \xReadCond{}(\purePart{W_R})$

    We already showed this.
  \item $\npair[n-1]{[\baddr,\eaddr]} \in \execCond{}(\purePart{W_R})$

    To this end let $W' \future \purePart{W_R}$ and $n' < n-1$ and $\aaddr' \in [\baddr',\eaddr']$ be given, and show
    \[
      \npair[n']{(((\rx,\normal),\baddr',\eaddr',\aaddr'),((\rx,\normal),\baddr',\eaddr',\aaddr'))} \in \lre(W')
    \]
    This follows immediately from the FTLR: we know that $[b,e] \mathrel{\#} \ta$ since $\trust = \untrusted$ and we know that $n' < n - 1 < n$.
  \end{itemize}
  
  Now show
  \[
    \npair[n-1]{(\Phi_S'.\reg,\Phi_T'.\reg)} \in \lrrg{\trust}(W_R)
  \]
  Note that we know that $\Phi_S.\reg(\pcreg)$ is not linear (which will sometimes help to eliminate some cases).

  By assumption we have
  \[
    \npair[n]{(\Phi_S.\reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)
  \]
  which gives us $R_R : (\RegName \setminus \{\pcreg\}) \fun World$ such that $W_R = \bigoplus_{r\in \RegName \setminus \{\pcreg\}} R_R(r)$ and for all $r$ in $\RegName \setminus \{\pcreg\}$ we have $\npair[n]{(\Phi_S.\reg(r),\Phi_T.\reg(r))} \in \lrrg{\trust}(R_R(r))$.
  To this end, we need to consider each of cases \ref{case:ftlr:move-cca-etc:cca-normal}-\ref{case:ftlr:move-cca-etc:splice-seal}:
  \begin{itemize}
  \item Case \ref{case:ftlr:move-cca-etc:cca-normal}:

    Pick $R_R$ as the ownership distribution.
    For $r \neq r_1$ it follows by assumption and Lemma~\ref{lem:downwards-closed}.
    For $r = r_1$ it also follows by assumption and Lemma~\ref{lem:downwards-closed}, \ref{lem:cap-in-lrv-regardless-of-addr}, and \ref{lem:cap-in-lrv-mono-perm}.
  \item Case \ref{case:ftlr:move-cca-etc:cca-stack}:

    Pick $R_R$ as the ownership distribution.
    For $r \neq r_1$ it follows by assumption and Lemma~\ref{lem:downwards-closed}.
    For $r = r_1$ it also follows by assumption and Lemma~\ref{lem:downwards-closed}, \ref{lem:stkptr-in-lrv-regardless-of-addr}, and \ref{lem:stkptr-in-lrv-mono-perm}.
  \item Case \ref{case:ftlr:move-cca-etc:cca-seal}:

    Pick $R_R$ as the ownership distribution.
    For $r \neq r_1$ it follows by assumption and Lemma~\ref{lem:downwards-closed}.
    For $r = r_1$ it also follows by assumption and Lemma~\ref{lem:downwards-closed} and \ref{lem:seal-in-lrv-regardless-of-cur-seal}.

  \item Case \ref{case:ftlr:move-cca-etc:move}:

    Pick the ownership distribution based on the linearity of $w_2$: If $\isLinear{w_2}$, then pick
    \[
      R_R'(r) =
      \begin{cases}
        R_R(r_2) \oplus R_R(r_1) & r = r_1 \\
        \purePart{W_R}         & r = r_2 \\
        R_R(r)                 & \totherwise
      \end{cases}
    \]
    if $\neg \isLinear{w_2}$, then pick
    \[
      R_R'(r) = R_R(r)
    \]

    In the case where $\isLinear{w_2}$, we may assume $r_2 \neq \pcreg$. We need to show (assuming $r_1 \neq \pcreg$)
    \[
      \npair[n-1]{(\Phi_S'(r_1),\Phi_T'(r_1))} \in \lrvg{\trust}(R_R(r_2) \oplus R_R(r_1))
    \]
    which is 
    \[
      \npair[n-1]{(\Phi_S(r_2),\Phi_T(r_2))} \in \lrvg{\trust}(R_R(r_2) \oplus R_R(r_1))
    \]
    this follows by assumption and Lemma~\ref{lem:monotonicity} and~\ref{lem:oplus-future}.

    We also need to show
    \[
      \npair[n-1]{(\Phi_S'(r_2),\Phi_T'(r_2))} \in \lrvg{\trust}(\purePart{W_R})
    \]
    which is trivial as $\Phi_S'(r_2) = \Phi_T'(r_2) = 0$. 

    Finally for $r \neq r_1,r_2,\pcreg$ 
    \[
      \npair[n-1]{(\Phi_S'(r),\Phi_T'(r))} \in \lrvg{\trust}(R_R(r))
    \]
    Follows by assumption and Lemma~\ref{lem:downwards-closed}.

    In the case where $\neg \isLinear{w_2}$

    If $r_2 \neq \pcreg$, then for $r \neq r_1$
    \[
      \npair[n-1]{(\Phi_S'(r),\Phi_T'(r))} \in \lrvg{\trust}(R_R(r))
    \]
    Follows by assumption and Lemma~\ref{lem:downwards-closed}.
    
    For $r \neq r_1,r_2$
    \[
      \npair[n-1]{(\Phi_S'(r_1),\Phi_T'(r_1))} \in \lrvg{\trust}(R_R(r_1))
    \]
    amounts to
    \[
      \npair[n-1]{(\Phi_S(r_2),\Phi_T(r_2))} \in \lrvg{\trust}(R_R(r_1))
    \]
    By assumption and Lemma~\ref{lem:purePart-oplus} and \ref{lem:non-linear-pure}.

    If $r_2 = \pcreg$, show
    \[
      \npair[n-1]{(\Phi_S(\pcreg),\Phi_T(\pcreg))} \in \lrvg{\trust}(R_R(r_1))
    \]
    which follows from Lemma~\ref{lem:monotonicity} and \ref{lem:world-fut-purePart} and what we have proven about the pc.
  \item Case \ref{case:ftlr:move-cca-etc:move-eq}:
    
    Follows from Assumption and Lemma~\ref{lem:downwards-closed}.

  \item Case \ref{case:ftlr:move-cca-etc:cseal}:

    TODO
  \item Case \ref{case:ftlr:move-cca-etc:split-normal}:
    From $\npair{(\Phi_S(r_3),\Phi_S(r_3))} \in \lrvg{\trust}(R_R(r_3))$, Lemma~\ref{lem:splitting-safety-normal} gives us $W_1$, $W_2$ and $W_3$ such that $R_R(r_3) = W_1 \oplus W_2 \oplus W_3$ and $\npair{(w_1,w_1) \in \lrvg{\trust}(W_1)}$, $\npair{(w_2,w_2) \in \lrvg{\trust}(W_2)}$ and $\npair{(w_3,w_3) \in \lrvg{\trust}(W_3)}$.
    We take $R_R'(r_1) = W_1$, $R_R'(r_2) = W_2$ and $R_R'(r_3) = W_3 \oplus R_R(r_1) \oplus R_R(r_2)$ and $R_R' = R_R(r)$ elsewhere.

    By the above points, by assumption and using Lemma~\ref{lem:downwards-closed}, we then have for all $r$ that:
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]
  \item Case \ref{case:ftlr:move-cca-etc:split-seal}:
    In this case, we can take $R_R' = R_R$ and use Lemma~\ref{lem:purePart-oplus} to give us that all $\purePart{R_R(r)}$ are equal.
    For $r = r_1, r_2, r_3$, we then get easily by definition that
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]
    and for other registers, it follows by Lemma~\ref{lem:downwards-closed}.

  \item Case \ref{case:ftlr:move-cca-etc:split-stack}:

    From $\npair{(\Phi_S(r_3),\Phi_T(r_3))} \in \lrvg{\trust}(R_R(r_3))$, Lemma~\ref{lem:splitting-safety-stack} gives us $W_1$, $W_2$ and $W_3$ such that $R_R(r_3) = W_1 \oplus W_2 \oplus W_3$ and $\npair{(w_1,w_1) \in \lrvg{\trust}(W_1)}$, $\npair{(w_2,w_2) \in \lrvg{\trust}(W_2)}$ and $\npair{(w_3,w_3) \in \lrvg{\trust}(W_3)}$.
    We take $R_R'(r_1) = W_1$, $R_R'(r_2) = W_2$ and $R_R'(r_3) = W_3 \oplus R_R(r_1) \oplus R_R(r_2)$ and $R_R' = R_R(r)$ elsewhere.

    By the above points, by assumption and using Lemma~\ref{lem:downwards-closed}, we then have for all $r$ that:
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]

  \item Case \ref{case:ftlr:move-cca-etc:splice-stack}:

    From $\npair{(\Phi_S(r_2),\Phi_T(r_2))} \in \lrvg{\trust}(R_R(r_2))$ and $\npair{(\Phi_S(r_3),\Phi_T(r_3))} \in \lrvg{\trust}(R_R(r_3))$, Lemma~\ref{lem:splicing-safety-stack} tells us that $\npair{(w_1,w_1) \in \lrvg{\trust}(R_R(r_2)\oplus R_R(r_3))}$.
    Since $w_2 = w_2'=w_3=w_3'=0$, it's clear that 
    $\npair{(w_2,w_2') \in \lrvg{\trust}(R_R(r_1))}$ and $\npair{(w_3,w_3') \in \lrvg{\trust}(\purePart{R_R(r_3)})}$.
    We take $R_R'(r_1) = R_R(r_2)\oplus R_R(r_3)$, $R_R'(r_2) = R_R(r_1)$ and $R_R'(r_3) = \purePart{R_R(r_3)}$ and $R_R' = R_R(r)$ elsewhere.

    By the above points, by assumption and using Lemma~\ref{lem:downwards-closed}, we then have for all $r$ that:
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]

  \item Case \ref{case:ftlr:move-cca-etc:splice-normal}:

    From $\npair{(\Phi_S(r_2),\Phi_T(r_2))} \in \lrvg{\trust}(R_R(r_2))$ and $\npair{(\Phi_S(r_3),\Phi_T(r_3))} \in \lrvg{\trust}(R_R(r_3))$, Lemma~\ref{lem:splicing-safety-normal} gives us $W_1',W_2',W_3'$ such that $R_R(r_2)\oplus R_R(r_3) = W_1'\oplus W_2' \oplus W_3'$ and
    $\npair{(w_i,w_i) \in \lrvg{\trust}(W_i')}$ for $i = 1,2,3$.
    We take $R_R'(r_1) = W_1'\oplus R_R(r_1)$ (which is defined because $R_R(r_1) \oplus (R_R(r_2)\oplus R_R(r_3))$ is defined), $R_R'(r_2) = W_2'$ and $R_R'(r_3) = W_3'$ and $R_R' = R_R(r)$ elsewhere.

    By the above points, by assumption and using Lemma~\ref{lem:downwards-closed}, we then have for all $r$ that:
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]

  \item Case \label{case:ftlr:move-cca-etc:splice-seal}:

    In this case, we can take $R_R' = R_R$ and use Lemma~\ref{lem:purePart-oplus} to give us that all $\purePart{R_R(r)}$ are equal.
    For $r = r_1, r_2, r_3$, we then get easily by definition that
    \[
      \npair[n-1]{(\Phi_S'(r), \Phi_T'(r))} \in \lrvg{\trust}(R_R'(r))
    \]
    and for other registers, it follows by Lemma~\ref{lem:downwards-closed}.
  \end{itemize}


  By Lemma~\ref{lem:lro-anti-red-gen} it suffices to show
  \[
    \npair[n-1]{\Phi_S',\Phi_T'} \in \lro
  \]
  which follows from the induction hypothesis.
  In this case, the IH is applicable because we have the following:
  \begin{itemize}
  \item One of the following sets of requirements holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S'$ is reasonable up to $n-1$ steps and $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \untrusted$, $[b,e] \mathrel{\#} \ta$ and $\npair[n-1]{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}

    We know one of the following holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S$ is reasonable up to $n$ steps and $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \untrusted$, $[b,e] \mathrel{\#} \ta$ and $\npair{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}
    If the latter is the case, then the result follows by Lemma~\ref{lem:downwards-closed}.

    If the former holds, then it follows from Lemma~\ref{lem:ec-reasonable-antired}.

    \item TODO (the remaining cases)
  \end{itemize}

  Case \ref{case:ftlr:store-load-mem}:

  By Lemma~\ref{lem:lro-anti-red-gen} it suffices to show
  \[
    \npair[n-1]{\Phi_S',\Phi_T'} \in \lro
  \]

  First, we show that for some $W_R'$ and $W_M'$ such that $W_R \oplus W_M = W_R' \oplus W_M'$, we have that $\npair[n-1]{(\Phi_S'.\reg,\Phi_T'.\reg)} \in \lrrg{\trust}(W_R')$ and $\memSat[n-1]{\Phi_S'.\mem,\Phi_S'.\stk,\Phi_S'.\ms_\stk,\Phi_T'.\mem}{W_M'}$.
  We have that $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\mem.\aaddr}{w}}$ and $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\mem.\aaddr}{w'}}$ and we distinguish the following two cases:
  \begin{itemize}
  \item (store) $w_1 = w_1' = \Phi_S(r_1) = \Phi_T(r_1) =
    ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \writeAllowed{}$,
    and
    $\withinBounds{w_1}$, and
    $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $w_2 = \linCons{\Phi_S(r_2)}$, $w_2' = \linCons{\Phi_T(r_2)}$,  $r_2 \neq \pcreg$:

    Follows from Lemma~\ref{lem:store-reg-works}, redistributing ownership in the obvious way.

  \item (load) $w_2 = w_2' = \Phi_T(r_2) = \Phi_S(r_2) =
    ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \readAllowed{}$,
    $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and
    $w_1 = \Phi_S.\mem(\aaddr)$, and $w_1' = \Phi_T.\mem(\aaddr)$, and
    $w = \linCons{w_1}$, $w' = \linCons{w_1'}$, $\linConsPerm{\perm}{w_1}$, $\linConsPerm{\perm}{w_1'}$ and $r_1 \neq \pcreg$

    Follows from Lemma~\ref{lem:readcond-cap-works}, redistributing ownership in the obvious way.

  \end{itemize}

  By the induction hypothesis, it suffices to prove that:
  \begin{itemize}
  \item One of the following sets of requirements holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S'$ is reasonable up to $n$ steps and $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \untrusted$ and $[b,e] \mathrel{\#} \ta$ and $\npair{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}:

    Follows by the same assumption of this lemma.

  \item $\Phi_S'(\pcreg) = \Phi_T'(\pcreg) = ((\rx,\normal),\baddr,\eaddr,\_)$:

    Follows by definition of $\updPcAddr{}$ and the fact that stores from pc into memory and loads into pc are not allowed.

  \item $\npair[n-1]{[\baddr,\eaddr]} \in \xReadCond{W_\pcreg}$:

    Follows by the same assumption of this lemma, using Lemma~\ref{lem:downwards-closed}.

  \item $\npair[n-1]{(\Phi_S'.\reg,\Phi_T'.\reg)} \in \lrrg{\trust}(W_R')$:

    See above.

  \item $\memSat[n-1]{\Phi_S'.\mem,\Phi_S'.\stk,\Phi_S'.\ms_\stk,\Phi_T'.\mem}{W_M'}$:

    See above.

  \item $W_\pcreg \oplus W_R' \oplus W_M'$ is defined.

  \item Theorem~\ref{thm:ftlr} holds for all $n' < n-1$:

    Follows by the same assumption of this lemma.
  \end{itemize}

  Case \ref{case:ftlr:store-load-stack}

  By Lemma~\ref{lem:lro-anti-red-gen} it suffices to show
  \[
    \npair[n-1]{\Phi_S',\Phi_T'} \in \lro
  \]

  First, we show that for some $W_R'$ and $W_M'$ such that $W_R \oplus W_M = W_R' \oplus W_M'$, we have that $\npair[n-1]{(\Phi_S'.\reg,\Phi_T'.\reg)} \in \lrrg{\trust}(W_R')$ and $\memSat[n-1]{\Phi_S'.\mem,\Phi_S'.\stk,\Phi_S'.\ms_\stk,\Phi_T'.\mem}{W_M'}$.
  We have that $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\ms_\stk.\aaddr}{w}}$, $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\ms_\stk.\aaddr}{w'}}$ and we distinguish the following two cases:
  \begin{itemize}
  \item (store) $w_1 = \Phi_T(r_1) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $w_1' = \Phi_S(r_1) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \writeAllowed{}$, and $\withinBounds{w_1}$, and $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $w_2 = \linCons{\Phi_S(r_2)}$, $w_2' = \linCons{\Phi_T(r_2)}$:

        Follows from Lemma~\ref{lem:store-stack-works}, redistributing ownership in the obvious way.

  \item (load) $ w_2' = \Phi_T(r_2) =
        ((\perm,\linear),\baddr,\eaddr,\aaddr)$, and $w_2 = \Phi_S(r_2) =
        \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \readAllowed{}$,
        $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and $\aaddr \in
        \dom(\Phi.\ms_\stk)$, and $\aaddr \in \dom(\Phi.\ms_\stk)$, and\\
        $w_1 = \Phi_S.\ms_\stk(\aaddr)$, and $w_1' = \Phi_T.\ms_\stk(\aaddr)$, and $w = \linCons{w_1}$, $w' = \linCons{w_1'}$, $\linConsPerm{\perm,w_1}$ and $\linConsPerm{\perm,w_1'}$ and $r_1 \neq \pcreg$:

    Follows from Lemma~\ref{lem:load-stack-cap-works}, redistributing ownership in the obvious way.

  \end{itemize}

  By the induction hypothesis, it suffices to prove that:
  \begin{itemize}
  \item One of the following sets of requirements holds:
    \begin{itemize}
    \item $\trust = \trusted$, $\Phi_S'$ is reasonable up to $n$ steps and $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \untrusted$ and $[b,e] \mathrel{\#} \ta$ and $\npair{[\baddr,\eaddr]} \in \readCond{\normal,W_\pcreg}$
    \end{itemize}:

    Follows by the same assumption of this lemma.

  \item $\Phi_S'(\pcreg) = \Phi_T'(\pcreg) = ((\rx,\normal),\baddr,\eaddr,\_)$:

    Follows by definition of $\updPcAddr{}$ and the fact that stores from pc into memory and loads into pc are not allowed.

  \item $\npair[n-1]{[\baddr,\eaddr]} \in \xReadCond{W_\pcreg}$:

    Follows by the same assumption of this lemma, using Lemma~\ref{lem:downwards-closed}.

  \item $\npair[n-1]{(\Phi_S'.\reg,\Phi_T'.\reg)} \in \lrrg{\trust}(W_R')$:

    See above.

  \item $\memSat[n-1]{\Phi_S'.\mem,\Phi_S'.\stk,\Phi_S'.\ms_\stk,\Phi_T'.\mem}{W_M'}$:

    See above.

  \item $W_\pcreg \oplus W_R' \oplus W_M'$ is defined.

  \item Theorem~\ref{thm:ftlr} holds for all $n' < n-1$:

    Follows by the same assumption of this lemma.
  \end{itemize}

  Case \ref{case:ftlr:store-load-jump}

  TODO
\end{proof}

\begin{proof}[Proof of Theorem~\ref{thm:ftlr}]
  By complete induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
  Assume
  \begin{itemize}
  \item $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$
  \end{itemize}
  and one of the following sets of requirements holds:
  \begin{enumerate}[label={\roman*)}]
  \item \begin{itemize}
    \item $[\baddr,\eaddr] \subseteq \ta$
    \item ${((\rx,\normal),\baddr,\eaddr,\aaddr)}$ behaves reasonably up to $n$ steps.
    \end{itemize}
  \item
    \begin{itemize}
    \item $[\baddr,\eaddr] \mathrel{\#} \ta$
    \end{itemize}
  \end{enumerate}
and show
\[
\npair{(c,c)} \in \lre(W)
\]
For $c=((\rx,\normal),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is defined\label{item:worlds-def}
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\update{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\update{\pcreg}{c})$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S,\Phi_T)} \in \lro
\]

By Lemma~\ref{lem:ftlr-internal-lemma}, taking $\trust = \trusted$ iff $[b,e] \subseteq \ta$ and $\trust = \untrusted$ otherwise, it suffices to show that:
\begin{itemize}
\item If $\trust =\trusted$ then $ \Phi_S$ is reasonable up to $n'$ steps.

  We know by assumption that $c$ behaves reasonably up to $n$ steps.

  By definition, it suffices to show that $\reg_S(r)$ is reasonable up to $n$ steps in memory $\ms_S$ and free stack $\ms_\stk$ for $r \nequal \pcreg$ and that $\ms_S$, $\ms_\stk$ and $\stk$ are all disjoint.

  Take an $r \neq \pcreg$ and $\gc = (\ta,\stkb,\gsigrets,\gsigcloss)$.
  By Lemma~\ref{lem:untrusted-source-values-are-reasonable}, it suffices to prove the following:
  \begin{itemize}
  \item $\npair{(w,\_)} \in \lrv(W_w)$: follows from $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$.
  \item $\memSat{\ms_S,\stk,\ms_\stk,\_}{W_M}$: by assumption.
  \item $\purePart{W_w} \oplus \purePart{W_M}$ is defined: By Lemma~\ref{lem:purePart-oplus}
  \end{itemize}

\item $\trust = \trusted \vee \npair[n']{[\baddr,\eaddr]} \in \readCond{\lin,W}$:
  If $\trust =\ untrusted$ then we know that $[b,e] \mathrel{\#} \ta$, so that $\npair{[\baddr,\eaddr]} \in \readCond{\lin,W}$ follows by Lemma~\ref{lem:xReadCond-outside-ta-implies-readCond}.

\item $\Phi_S(\pcreg) = \Phi_T(\pcreg) = ((\rx,\lin),\baddr,\eaddr,\aaddr)$:
  We know that $\Phi_S(\pcreg) = \Phi_T(\pcreg) = c = ((\rx,\lin),\baddr,\eaddr,\aaddr)$. 

\item $\npair[n']{[\baddr,\eaddr]} \in \xReadCond{W}$:
  Follows from $\npair{[\baddr,\eaddr]} \in \xReadCond{W}$ using Lemma~\ref{lem:downwards-closed}.

\item $\npair[n']{(\Phi_S.\reg,\Phi_T.\reg)} \in \lrrg{\trust}(W_R)$:
  Follows directly from $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$  since $\lrr(W_R) \subseteq \lrrg{\trust}(W_R)$.

\item $\memSat[n']{\Phi_S.\mem,\Phi_S.\ms_\stk,\Phi_S.\stk,\Phi_T.\mem}{W_M}$:
  By assumption.

\item $W \oplus W_R \oplus W_M$ is defined:
  By assumption.

\item Theorem~\ref{thm:ftlr} holds for all $n'' < n'$:
  Follows from our induction hypothesis since $n' \le n$.

\end{itemize}
\end{proof}

\begin{lemma}
  \label{lem:stack-sat-unchanged-future}
  If $\pwfree = \pwfree[W']$ and $W' \future W$ and
  $\memSatFStack{\ms_\stk,\ms_T}{W}$, then $\memSatFStack{\ms_\stk,\ms_T}{W'}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:heap-sat-unchanged-future}
  If $\pwheap[\purePart{W}] = \pwheap[\purePart{W'}]$ and $W_{h}' \future W_h$ and $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in \lrheap(\pwheap[W])(W_h)$, then $\npair{(\overline{\sigma},\ms_S,\ms_T)} \in\lrheap(\pwheap[W'])(W_h')$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:stdreg-singleton-addr-strat}
  $\stdreg{\{*\},\gc}{v}$ is address-stratified.
\end{lemma}
\begin{proof}
  Trivial.
\end{proof}

\begin{lemma}[Unique return seals]
  \label{lem:unique-ret-seals}
  If
  \begin{itemize}
  \item $\mscode([\aaddr..\aaddr+\calllen-1]) = \overline{\scall{\offpc,\offsigma}{r_1}{r_2}}$
  \item $\mscode([\aaddr'..\aaddr'+\calllen-1]) = \overline{\scall{\offpc',\offsigma'}{r_1'}{r_2'}}$
  \item $\mscode(\aaddr + \offpc) = \seal{\sigma_b,\sigma_e,\sigma_b}$ and $\sigma = \sigma_b + \offsigma$
  \item $\mscode(\aaddr' + \offpc') = \seal{\sigma_b',\sigma_e',\sigma_b'}$ and $\sigma = \sigma_b' + \offsigma'$
  \item $\sigrets,\sigcloss \vdash_{\mathrm{comp-code}} \mscode$
  \end{itemize}
  then
  \[
    \aaddr = \aaddr'
  \]
  and $\offpc = \offpc'$ and $\offsigma = \offsigma'$ and $r_1 = r_1'$ and $r_2 = r_2'$ and $\sigma_b = \sigma_b'$ and $\sigma_e = \sigma_e'$.
\end{lemma}
\begin{proof}
  \lau{TODO}
\end{proof}

\begin{lemma}
  \label{lem:lrv-relates-linearity}
  For all $W$, $n$, $w_1$, $w_2$ if
  \begin{itemize}
  \item $\npair{(w_1,w_2)} \in \lrvg{\trust}(W)$
  \end{itemize}
  then
  \[
    \isLinear{w_1} \text{ iff } \isLinear{w_2}
  \]
\end{lemma}
\begin{proof}
  (Trivial) We consider the possible cases for $w_1$ and $w_2$
  \begin{itemize}
  \item Case $w_1,w_2 \in \ints$: By definition of $\isLinear{}$.
  \item Case $w_1 = \sealed{\sigma,\vsc_1}$ and $w_2 = \sealed{\sigma,\vsc_2}$:
    From the assumption $\npair[n]{(w_1,w_2)} \in \lrv(W)$ we get the desired result.
  \item Case $w_1 = \seal{\_,\_,\_}$ and $w_2 = \seal{\_,\_,\_}$: By definition of $\isLinear{}$.
  \item Case $w_1 = \stkptr{\_,\_,\_,\_}$ and $w_2 = ((\_,\linear),\_,\_,\_)$: By definition of $\isLinear{}$, stack pointers are linear.
  \item Case $w_1 = ((\_,\lin),\_,\_,\_)$ and $w_2 = ((\_,\lin),\_,\_,\_)$: By definition of $\isLinear{}$.
  \end{itemize}
  If $\trust = \trusted$, then there are two more cases to consider, but like the above cases, they are trivial.
\end{proof}

\begin{lemma}
  \label{lem:lincons-lrv}
  For all $W' \future W$, $n$, $w_1$, $w_2$
   if
    \begin{itemize}
    \item $\isLinear{w_1}$ or $\isLinear{w_2}$
    \end{itemize} or
    \begin{itemize}
    \item $\npair{(w_1,w_2)} \in \lrv(W)$
    \item $\nonLinear{w_1}$ or $\nonLinear{w_2}$
    \end{itemize}
    then
    \[
      \npair{(\linCons{w_1},\linCons{w_2})} \in \lrv(\purePart{W'})
    \]
\end{lemma}
\begin{proof}
  For the first set of assumptions, we can conclude
  $\isLinear{w_1}$ and $\isLinear{w_2}$ by Lemma~\ref{lem:lrv-relates-linearity} which means that we need to argue
  \[
    \npair{(0,0)} \in \lrv(\purePart{W'})
  \]
  which is trivially true.

  For the second set of assumptions, we can conclude $\nonLinear{w_1}$ and
  $\nonLinear{w_2}$ by Lemma~\ref{lem:lrv-relates-linearity} which means that we
  need to show $\npair{(w_1,w_2)} \in \lrv(\purePart{W'})$ which is true by
  assumption and Lemma~\ref{lem:monotonicity} and \ref{lem:non-linear-pure}.
\end{proof}

%%% Local Variables:
%%% TeX-master: "technical-report"
%%% End: