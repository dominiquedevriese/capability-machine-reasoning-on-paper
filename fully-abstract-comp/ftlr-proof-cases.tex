\subsection{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[non-expansiveness of relations]
  \label{lem:non-expansive}
  If $n' \leq n$, then
  \begin{itemize}
  \item If $\npair{(b,e)} \in \readCond{\lin,W}$, then $\npair[n']{(b,e)} \in \readCond{\lin,W}$.
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$, then also $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$.
  \end{itemize}
\end{lemma}

\begin{lemma}[World monotonicity of relations]
  \label{lem:monotonicity}
  For all $n$, $W' \future W$, we have that
  \begin{itemize}
  \item If $(w_1,w_2) \in H_\sigma~\sigma~W$, then $(w_1,w_2) \in H_\sigma~\sigma~W'$.
    \lau{This should hold for any valid $H_\sigma$, but we need to prove it for specific instantiations.}
  \item If $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in
    \lrv(W')$.
\end{itemize}
\end{lemma}

\begin{lemma}[$\lror$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_T \nstep[j]{} \Phi_T' \text{ and } \npair[n-j]{(\Phi_S,\Phi_T')} \in \lror,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lror
\]
\end{lemma}

\begin{lemma}[$\lrol$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_S \nstep[j]{\gc} \Phi_S' \text{ and } \npair[n-j]{(\Phi_S',\Phi_T)} \in \lrol,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lrol
\]
\end{lemma}


\dominique{9-3-2018: the below is a proposed generalisation of the above antireduction lemma  that I expect will hold (based on experience with similar LRs in the past).}
\begin{lemma}[$\lro$ closed under antireduction (generalised previous lemma)]
  For all $\Phi_S$, $\Phi_S'$, $\Phi_T$, $\Phi_T'$, $j_S,j_T$, $n$, if
  \begin{itemize}
  \item $\Phi_S \nstep[j_S]{\gc} \Phi_S'$
  \item $\Phi_T \nstep[j_T]{} \Phi_T'$
  \item $\npair{(\Phi_S',\Phi_T')} \in \lro$
\end{itemize}
then
\[
  \npair[n+\min(j_S,j_T)]{(\Phi_S,\Phi_T)} \in \lro
\]
\end{lemma}


\begin{lemma}[readCondition works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\readCond{l,W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_S(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\writeCond{l,W}$
  \end{itemize}
  Then $\memSat{(\ms_S[a\mapsto 0],\stk,\ms_\stk,\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\readCond{l,W}$, we get an $S \subseteq \addressable{\lin,
    \pwheap}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwheap(r)
  \nsubeq \stdreg{R(r),\gc}{\pur}$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwheap) =
  \dom(\pwheap[W_M])$ and $\pwheap(r) \oplus \pwheap[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\memSatHeap{\ms_S',\ms_\var{T,heap}}{W_\var{heap}}$.
  \end{itemize}

  From $\memSatHeap{\ms_S,\ms_\var{T,heap}}{W_\var{heap}}$, we get an
  $R_\ms : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,heap} = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_2(R_\ms(r))$,
  $\ms_S = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_1(R_\ms(r))$,
  $\exists R_W : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \World\ldotp$
  $W_\var{heap} = \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwheap[W_\var{heap}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwheap} \subseteq
  \activeReg{\pwheap[W_\var{heap}]}$, so $\npair{R_\ms(r)} \in
  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwheap(r) \nsubeq \stdreg{R(r),\gc}{\pur}$ and $W\oplus W_M = W \oplus (W_\var{heap} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that
  also $\pwheap[W_\var{heap}](r) \nsubeq \stdreg{R(r),\gc}{\pur}$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.\dominique{have we defined $\nsubeq$ somewhere?}

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}}' \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{heap}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{heap}}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    R_W(r) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
      W_\var{heap} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\writeCond{l,W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwheap} \subseteq \activeReg{\pwheap[W_\var{heap}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ such that
  for all $r \in S'$, $\pwheap(r) \nsupeq \stdreg{R'(r),\gc}{\pur}$ and
  $\pwheap(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwheap[W_\var{heap}](r') \nsupeq \stdreg{R'(r'),\gc}{\pur}$ and
  $\pwheap[W_\var{heap}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $\dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwheap[W_\var{heap}](r).H \; \xi^{-1}(W_r')$ because $\pwheap[W_\var{heap}](r)$ is address-stratified and $\pwheap[W_\var{heap}](r) \nsupeq \stdreg{R'(r),\gc}{\pur}$.

  From this, it follows that $\memSatHeap{\ms_S\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{heap}'}$ and finally $\memSat{(\ms_S\update{a}{0},\stk,\ms_\stk,\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[stackReadCondition works]
  \label{lem:stackreadcond-stackwritecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\stackReadCond{W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\stackWriteCond{W}$
  \end{itemize}
  Then $\memSat{(\ms_S,\stk,\ms_\stk[a\mapsto 0],\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\stackReadCond{W}$, we get an $S \subseteq \addressable{\lin,
    \pwfree}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwfree(r)
  \nsubeq \stdreg{R(r),\gc}{\pur}$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwfree) =
  \dom(\pwfree[W_M])$ and $\pwfree(r) \oplus \pwfree[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\memSatHeap{\ms_S',\ms_\var{T,heap}}{W_\var{heap}}$.
  \end{itemize}

  From $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$, we get an
  $R_\ms : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,free\_stack} = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_2(R_\ms(r))$,
  $\ms_\stk = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_1(R_\ms(r))$,
  $\stkb \in \dom(\ms_\var{T,free\_stack}) \wedge \stkb \in \dom(\ms_\stk)$,
  $\exists R_W : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \World\ldotp$
  $W_\var{free\_stack} = \oplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwfree[W_\var{free\_stack}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwfree} \subseteq
  \activeReg{\pwfree[W_\var{free\_stack}]}$, so $\npair{R_\ms(r)} \in
  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwfree(r) \nsubeq \stdreg{R(r),\gc}{\pur}$ and $W\oplus W_M = W \oplus (W_\var{free\_stack} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that
  also $\pwfree[W_\var{free\_stack}](r) \nsubeq \stdreg{R(r),\gc}{\pur}$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.\dominique{have we defined $\nsubeq$ somewhere?}

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}')$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{free\_stack}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_\var{heap}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_{\var{heap}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    R_W(r) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{free\_stack}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
    &=
      W_\var{free\_stack} \oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\stackWriteCond{W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwfree} \subseteq \activeReg{\pwheap[W_\var{free\_stack}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ and
  for all $r \in S'$, $\pwfree(r) \nsupeq \stdreg{R'(r),\gc}{\pur}$ and
  $\pwfree(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwfree[W_\var{free\_stack}](r') \nsupeq \stdreg{R'(r'),\gc}{\pur}$ and
  $\pwfree[W_\var{free\_stack}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $ \dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(W_r')$ because $\pwfree[W_\var{free\_stack}](r)$ is address-stratified and $\pwfree[W_\var{free\_stack}](r) \nsupeq \stdreg{R'(r),\gc}{\pur}$.

  From this, it follows that $\memSatFStack{\ms_\stk\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{free\_stack}'}$ and finally $\memSat{(\ms_S,\stk,\ms_\stk\update{a}{0},\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[purePart is idempotent]
  For all $W$, $\mathit{purePart}( \purePart{W} ) = \purePart{W}$
  \label{lem:purePart-idempotent}
\end{lemma}
\begin{proof}
  Follows easily from the definition.
\end{proof}

\begin{lemma}[non-linear words are pure]
  \label{lem:non-linear-pure}
  If $\npair{(w_1,w_2)} \in \lrv(H_\sigma,W)$ and ($\nonLinear{w_1}$ or $\nonLinear{w_2}$), then
  $\npair{(w_1,w_2)} \in \lrv(H_\sigma,\purePart{W})$.
\end{lemma}
\begin{proof}
  Follows easily by inspecting the definitions of $\lrv$, $\readCond[]{}$, $\addressable{}$, $\writeCond[]{}$, $\execCond[]{}$ and $\xReadCond[]{}$ and using Lemma~\ref{lem:purePart-idempotent}.
\end{proof}

\begin{lemma}[load from regular capability works]
  \label{lem:readcond-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$, $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrv(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, $\perm \in \readAllowed{}$ and $\perm' \in \readAllowed{}$, we get that $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$.

  Lemma~\ref{lem:readcond-writecond-work} then gives us a $W'$ and $W_M'$ such that $W_M = W' \oplus W_M'$ and $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$.
  
  It remains to prove that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_S(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm,\perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrv(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \writeCond{\lin,W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:non-expansive}, we then get that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.

  \item case $\neg\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = \ms_S(\aaddr)$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by non-expansiveness of memory satisfaction, i.e. Lemma~\ref{lem:non-expansive}.
  \end{itemize}
\end{proof}

\begin{lemma}[load from stack capability works]
  \label{lem:load-stack-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item ($\aaddr \in [\baddr,\eaddr]$ or $\aaddr' \in [\baddr',\eaddr']$)
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, ($\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$), we get that $\perm = \perm'$, $\lin' = \linear$, $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \stackReadCond{W}$.

  From Lemma~\ref{lem:stackreadcond-stackwritecond-work}, we then get that $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  

  It remains to prove that $\memSat{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_\stk(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm = \perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \stackWriteCond{W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:non-expansive}, we then get that $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{0},\ms_T\update{\aaddr'}{0})}{W_M'}$.

  \item case $\neg\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = \ms_\stk(\aaddr)$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by non-expansiveness of memory satisfaction, i.e. Lemma~\ref{lem:non-expansive}.
  \end{itemize}
\end{proof}

\subsection{FTLR proof}
By induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
\begin{proof}
  Assume
  \begin{itemize}
  \item $\trust = \trusted \vee \npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$
  \item $\npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W}$
  \end{itemize}
  and one of the following sets of requirements holds:
  \begin{enumerate}[label={\roman*)}]
  \item \begin{itemize}
    \item $W \vdash_{(\ta,\stkb)} (\mscode,\_,\_,\_,\sigrets,\sigcloss)$
    \item $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \trusted$
    \item For all $\npair{\stpair{\reg}{\reg}} \in \lrrtrusted(W)$ and $\memSat{\src{\ms_S},\src{\ms_\stk},\src{\stk},\ms_T}{W}$ and $\ms_f$, we have $\src{\Phi} = (\src{\ms_S} \uplus \ms_f, \src{reg_S}, \src{\stk}, \src{\ms_\stk})$ and 
      \begin{itemize}           
      \item $\src{\Phi}$ checks $\stkb$ before calls in $\ta$ for $n$ steps (Definition~\ref{def:check-stack-addr-before-call}).
      \item $\src{\Phi}$ uses link seals properly in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:use-return-seals-call}).
      \item $\src{\Phi}$ handle trusted seals properly in $\ta$ with components parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:handle-trusted-seals-properly}).
      \item $\src{\Phi}$ does not store link seals and code capabilities in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:never-store-seal-code-cap}).
      \end{itemize}
    \end{itemize}
  \item
    \begin{itemize}
    \item $[\baddr,\eaddr] \mathrel{\#} \ta$
    \item $\trust = \untrusted$
    \end{itemize}
  \end{enumerate}
and show
\[
\npair{(c,c)} \in \lreg{\trust}(W)
\]
For $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrrg{\trust}(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is well-defined\label{item:worlds-def}
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\updReg{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\updReg{\pcreg}{c})$
\end{itemize}
and pick
\begin{itemize}
\item $\Phi_S' = \Phi_S\updReg{\pcreg}{c}$
\item $\Phi_T' = \Phi_T\updReg{\pcreg}{c}$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S',\Phi_T')} \in \lro
\]
In order to do this, we first, we prove that one of the following holds:
\begin{itemize}
\item $\Phi_S \step \failed$ and $\Phi_T \step\failed$
\item $\Phi_S \step \halted$ and $\Phi_T \step\halted$
\item All of the following hold:
  \begin{itemize}
  \item $\callCond{\Phi_S,r_1,r_2,\aaddr}$
  \item $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$
  \item $\exec{\Phi_S(\pcreg)}$
  \item for all $i = 0..\calllen-1$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i) \in \ints$.
  \item TODO: other useful info
  \end{itemize}
\item All of the following hold: (includes simple cases: gettype, geta, getb,
  gete, getp, getl, lt, plus, minus, one case of move that can be handled uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r}{z}} \neq \failed$
  \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r}{z}} \neq \failed$
  \item $z \in \ints$
  \end{itemize}
\item All of the following hold: (includes cap-manipulation cases: move, cca, restrict, seta2b, cseal, split, splice, that can be handled mostly uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1\cdots r_k}{w_1\cdots w_k}}\neq \failed$
  \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1\cdots r_k}{w_1'\cdots w_k'}} \neq \failed$
  \item One of the following holds:
    \begin{itemize}
    \item (restrict,cca,seta2b) $w_1 = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $w_1' = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi_T(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k = 1$
    \item (restrict,cca,seta2b) $w_1 = \stkptr{\perm',\baddr,\eaddr,\aaddr'}$, $w_1' = ((\perm',\linear),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $\Phi_T(r_1) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k = 1$
    \item (cca,seta2b) $w_1 = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma,\sigma'}$, $w_1' = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma,\sigma'}$, $\Phi_S(r_1) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma,\sigma'}$ and $\Phi_T(r_1) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma,\sigma'}$, $k = 1$
    \item (move) $w_1 = \Phi_S(r_1)$, $w_1' = \Phi_S(r_1)$, and
      $\isLinear{w_1} \Rightarrow w_2 = w_2' = 0$, and $\neg
      \isLinear{w_1} \Rightarrow (w_2 = \Phi_S(r_2) \wedge w_2' = \Phi_T(r_2)$)
      and $k = 2$.
    \item (cseal) $w_1 = \sealed{\sigma,\Phi_S(r_1)}$, $w_1' = \sealed{\sigma,\Phi_T(r_1)}$, $\Phi_S(r_2) = \Phi_T(r_2) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $k=1$
    \item (split) $\Phi_T(r_3) = \Phi_S(r_3) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$, $w_1 = w_1' = ((\perm,\lin),\baddr,n,\aaddr)$, $w_2 = w_2' = ((\perm,\lin),n+1,\eaddr,\aaddr)$, $k=2$.
    \item (split) $\Phi_T(r_3) = \Phi_S(r_3) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $\sigma_\baddr \leq n$, $n < \sigma_\eaddr$, $w_1 = w_1' = \seal{\sigma_\baddr,n,\sigma}$, $w_2 = w_2' = \seal{n+1,\sigma_\eaddr,\sigma}$, $k=2$.
    \item (split) $\Phi_S(r_3) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $\Phi_T(r_3) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$, $w_1 = \stkptr{\perm,\baddr,n,\aaddr}$, $w_1' = ((\perm,\linear),\baddr,n,\aaddr)$, $w_2 = \stkptr{\perm,n+1,\eaddr,\aaddr}$, $w_2' = ((\perm,\linear),n+1,\eaddr,\aaddr)$, $k=2$.
    \item (splice) $\Phi_T(r_2) = ((\perm,\linear),\baddr_2,\eaddr_2,\_)$,
      $\Phi_S(r_2) = \stkptr{\perm,\baddr_2,\eaddr_2,\_}$, and
      $\Phi_T(r_3) = ((\perm,\linear),\eaddr_2+1,\eaddr_3,\aaddr_3)$,
      $\Phi_S(r_3) = \stkptr{\perm,\eaddr_2+1,\eaddr_3,\aaddr_3}$, and
      $\baddr_2 \leq \eaddr_2$, and
      $\eaddr_2+1 \leq \eaddr_3$, and
      $w_1=((\perm,\linear),\baddr_2,\eaddr_3,\aaddr_3)$, $w_1'=
      \stkptr{\perm,\baddr_2,\eaddr_3,\aaddr_3}$, and
      $w_2 = w_2' = w_3 = w_3' = 0$, and
      $k=3$
    \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) =
      ((\perm,\lin),\baddr_2,\eaddr_2,\_)$, and
      $\Phi_T(r_3) = \Phi_S(r_3) = ((\perm,\lin),\eaddr_2+1,\eaddr_3,\aaddr_3)$,
      and
      $\baddr_2 \leq \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
      $w_1=w_1'=((\perm,\lin),\baddr_2,\eaddr_3,\aaddr_3)$, and
      $\lin = \linear \Rightarrow w_2 = w_2' = w_3 = w_3' = 0$, and
      $\lin = \normal \Rightarrow (w_2 = w_2' = \Phi_T(r_2) \text{ and } w_3 =
      w_3' = \Phi_T(r_3))$, and $k=3$
    \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) = \seal{\sigma_{\baddr,2},\sigma_{\eaddr,2},\_}$, and $\Phi_T(r_3) = \Phi_S(r_3) = \seal{\sigma_{\eaddr,2}+1,\sigma_{\eaddr,3},\sigma_{\aaddr,3}}$, and $\sigma_{\baddr,2} \leq \sigma_{\eaddr,2}$, and $\sigma_{\eaddr,2} + 1 \leq \sigma_{\eaddr,3}$and $w_1 = w_1' = \seal{\sigma_{\baddr,2}, \sigma_{\eaddr,3}, \sigma}$
      \end{itemize}
  \end{itemize}
\item All of the following hold: (includes memory-manipulation cases: store, load, that can be handled mostly uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' =
    \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\mem.\aaddr}{w}}$
  \item $\Phi_T' =
    \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\mem.\aaddr}{w'}}$
  \item One of the following hold:
    \begin{itemize}
    \item (store) $w_1 = w_1' = \Phi_S(r_1) = \Phi_T(r_1) =
      ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \writeAllowed{}$,
      and
      $\withinBounds{w_1}$, and\\
      $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
      w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
      \text{ and } w_2' = \Phi_T(r_2))$.
    \item (load) $w_2 = w_2' = \Phi_T(r_2) = \Phi_S(r_2) =
      ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \readAllowed{}$,
      $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and \\
      $w_1 = \Phi_S.\mem(\aaddr)$, and $w_1' = \Phi_T.\mem(\aaddr)$, and \\
      $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
      $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
    \end{itemize}
  \end{itemize}
\item All of the following hold: (includes memory-manipulation cases: store, load, that can be handled mostly uniformly (stack))
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' =
    \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\ms_\stk.\aaddr}{w}}$
  \item $\Phi_T' =
    \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\ms_\stk.\aaddr}{w'}}$
  \item One of the following hold:
    \begin{itemize}
    \item (store) $w_1 = \Phi_T(r_1) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $w_1' =  \Phi_S(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \writeAllowed{}$,
      and
      $\withinBounds{w_1}$, and\\
      $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
      w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
      \text{ and } w_2' = \Phi_T(r_2))$.
    \item (load) $ w_2' = \Phi_T(r_2) =
      ((\perm,\linear),\baddr,\eaddr,\aaddr)$, and $w_2 = \Phi_S(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \readAllowed{}$,
      $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and $\aaddr \in
      \dom(\Phi.\ms_\stk)$, and $\aaddr \in \dom(\Phi.\ms_\stk)$, and\\
      $w_1 = \Phi_S.\ms_\stk(\aaddr)$, and $w_1' = \Phi_T.\ms_\stk(\aaddr)$, and \\
      $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
      $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
    \end{itemize}
  \end{itemize}

\item All of the following hold: (includes control-flow manipulation cases: jmp, jnz, xjmp, that can be handled mostly uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item One of the following holds
    \begin{itemize}
    \item(jnz) $\Phi_S' = \updPcAddr{\Phi_S}$ and $\Phi_T' = \updPcAddr{\Phi_T}$
    \item(jmp,jnz) $\Phi_S' = \Phi_S\updReg{\pcreg,r_1}{\Phi_S(r_1),w_1}$ and $\Phi_T' =
      \Phi_T\updReg{\pcreg,r_1'}{\Phi_T(r_1),w_1'}$ and 
      $\isLinear{\Phi_S(r_1)} \Rightarrow w_1 = w_1' = 0$ and
      $\neg \isLinear{\Phi_S(r_1)} \Rightarrow (w_1 = \Phi_S(r_1) \text{ and }
      w_1' = \Phi_T(r_1))$
    \item(xjmp) $\Phi_S(r_1) = \sealed{\sigma,c_1}$ and $\Phi_S(r_2) =
      \sealed{\sigma,c_2}$ and $\Phi_T(r_1) = \sealed{\sigma,c_1'}$ and
      $\Phi_T(r_2) = \sealed{\sigma,c_2'}$ and $\Phi_S'(r_1,r_2) =
      \linCons{c_1},\linCons{c_2}$ and $\Phi_T'(r_1,r_2) =
      \linCons{c_1'},\linCons{c_2'}$ and\\
      $c_1' \neq \retptrc(\_)$ and $c_2' \neq \retptrd(\_)$ and
        $\nonExec{c_\data}$ and $\Phi_T'(\pcreg,\rdata) = c_1',c_2'$ and
      one of the following hold:
      \begin{itemize}
      \item $c_1 \neq \retptrc(\_)$ and $c_2 \neq \retptrd(\_)$ and
        $\nonExec{c_\data}$ and $\Phi_S'(\pcreg,\rdata) = c_1,c_2$.
      \item $c_1 = \retptrc(\baddr,\eaddr,\aaddr)$, and $c_2 =
        \retptrd(\aaddr_\stk,\eaddr_{\stk,\priv})$ and $\Phi(r_\stk) =
        \stkptr{\rw,\stkb,\eaddr_\stk,\_}$ and $\Phi_S.\stk = \stk_\var{frame}
        :: (\aaddr,\ms_{\stk,\priv})$ and
        $\dom(\ms_{\stk,\priv} = [\eaddr_\stk+1,\eaddr_{\stk,\priv}])$ and
        $\Phi_S'.\ms_\stk = \ms_{\stk,\priv} \uplus \Phi_S.\ms_\stk$ and
        $\Phi_S'.\stk = \stk$ and
        \[
          \begin{split}
\Phi_S' = \Phi_S&[\pcreg \mapsto ((\rx,\normal),\baddr,\eaddr,\aaddr)]\\
            &[\rstk \mapsto
            \stkptr{\rw,\stkb,\eaddr_{\stk,\priv},e_\stk+1}] \\
            &[\rdata,\rtmp{1},\rtmp{2},r_2 \mapsto 0, 0, 0, 0]
          \end{split}
        \]
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{proof}

%%% Local Variables:
%%% TeX-master: "technical-report"
%%% End: