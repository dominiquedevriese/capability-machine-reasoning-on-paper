\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}

\usepackage[svgnames]{xcolor}

\input{preamble}

\title{FTLR proof cases}

\begin{document}

\maketitle
\section{Lemmas}
In this section, I have listed lemmas that seem to be necessary for the FTLR proof.
\begin{lemma}[non-expansiveness of relations]
  \label{lem:non-expansive}
  If $n' \leq n$, then
  \begin{itemize}
  \item If $\npair{(b,e)} \in \readCond{\lin,W}$, then $\npair[n']{(b,e)} \in \readCond{\lin,W}$.
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$, then also $\memSat[n']{(\ms_S,\stk,\ms_\stk,\ms_T)}{W}$.
  \end{itemize}
\end{lemma}

\begin{lemma}[World monotonicity of relations]
  \label{lem:monotonicity}
  For all $n$, $W' \future W$, we have that
  \begin{itemize}
  \item If $(w_1,w_2) \in H_\sigma~\sigma~W$, then $(w_1,w_2) \in H_\sigma~\sigma~W'$.
    \lau{This should hold for any valid $H_\sigma$, but we need to prove it for specific instantiations.}
  \item If $\npair{(w_1,w_2)} \in \lrv(W)$, then $\npair{(w_1,w_2)} \in
    \lrv(W')$.
\end{itemize}
\end{lemma}

\begin{lemma}[$\lror$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_T \nstep[j]{} \Phi_T' \text{ and } \npair[n-j]{(\Phi_S,\Phi_T')} \in \lror,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lror
\]
\end{lemma}

\begin{lemma}[$\lrol$ closed under target language antireduction]
  For all $\Phi_S$, $\Phi_T$, $\Phi_T'$, $j$, $n$, if
\[
  \Phi_S \nstep[j]{\gc} \Phi_S' \text{ and } \npair[n-j]{(\Phi_S',\Phi_T)} \in \lrol,
\]
then
\[
  \npair{(\Phi_S,\Phi_T)} \in \lrol
\]
\end{lemma}


\dominique{9-3-2018: the below is a proposed generalisation of the above antireduction lemma  that I expect will hold (based on experience with similar LRs in the past).}
\begin{lemma}[$\lro$ closed under antireduction (generalised previous lemma)]
  For all $\Phi_S$, $\Phi_S'$, $\Phi_T$, $\Phi_T'$, $j_S,J_T$, $n$, if
  \begin{itemize}
  \item $\Phi_S \nstep[j_S]{\gc} \Phi_S'$
  \item $\Phi_T \nstep[j_T]{} \Phi_T'$
  \item $\npair{(\Phi_S',\Phi_T')} \in \lro$
\end{itemize}
then
\[
  \npair[n+\min(j_S,j_T)]{(\Phi_S,\Phi_T)} \in \lro
\]
\end{lemma}


\begin{lemma}[readCondition works]
  \label{lem:readcond-writecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\readCond{l,W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_S(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\writeCond{l,W}$
  \end{itemize}
  Then $\memSat{(\ms_S[a\mapsto 0],\stk,\ms_\stk,\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\readCond{l,W}$, we get an $S \subseteq \addressable{\lin,
    \pwheap}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwheap(r)
  \nsubeq \stdreg{R(r),\gc}{\pur}$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwheap) =
  \dom(\pwheap[W_M])$ and $\pwheap(r) \oplus \pwheap[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\memSatHeap{\ms_S',\ms_\var{T,heap}}{W_\var{heap}}$.
  \end{itemize}

  From $\memSatHeap{\ms_S,\ms_\var{T,heap}}{W_\var{heap}}$, we get an
  $R_\ms : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,heap} = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_2(R_\ms(r))$,
  $\ms_S = \biguplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} \pi_1(R_\ms(r))$,
  $\exists R_W : \dom(\activeReg{\pwheap[W_\var{heap}]}) \fun \World\ldotp$
  $W_\var{heap} = \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwheap[W_\var{heap}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwheap} \subseteq
  \activeReg{\pwheap[W_\var{heap}]}$, so $\npair{R_\ms(r)} \in
  \pwheap[W_\var{heap}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwheap(r) \nsubeq \stdreg{R(r),\gc}{\pur}$ and $W\oplus W_M = W \oplus (W_\var{heap} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that
  also $\pwheap[W_\var{heap}](r) \nsubeq \stdreg{R(r),\gc}{\pur}$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.\dominique{have we defined $\nsubeq$ somewhere?}

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}}' \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{heap}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{heap}}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    R_W(r) \oplus W_\var{heap}'\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{heap}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
    &=
      W_\var{heap} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\writeCond{l,W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwheap} \subseteq \activeReg{\pwheap[W_\var{heap}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ such that
  for all $r \in S'$, $\pwheap(r) \nsupeq \stdreg{R'(r),\gc}{\pur}$ and
  $\pwheap(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwheap[W_\var{heap}](r') \nsupeq \stdreg{R'(r'),\gc}{\pur}$ and
  $\pwheap[W_\var{heap}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $\dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwheap[W_\var{heap}](r).H \; \xi^{-1}(W_r')$ because $\pwheap[W_\var{heap}](r)$ is address-stratified and $\pwheap[W_\var{heap}](r) \nsupeq \stdreg{R'(r),\gc}{\pur}$.

  From this, it follows that $\memSatHeap{\ms_S\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{heap}'}$ and finally $\memSat{(\ms_S\update{a}{0},\stk,\ms_\stk,\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[stackReadCondition works]
  \label{lem:stackreadcond-stackwritecond-work}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $\npair{(b,e)}\in\stackReadCond{W}$
  \item $a \in [b,e]$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \end{itemize}
  Then $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  Additionally, if
  \begin{itemize}
  \item $\npair{(b,e)}\in\stackWriteCond{W}$
  \end{itemize}
  Then $\memSat{(\ms_S,\stk,\ms_\stk[a\mapsto 0],\ms_T[a\mapsto 0])}{W_M'}$.
\end{lemma}
\begin{proof}
  From $\npair{(b,e)}\in\stackReadCond{W}$, we get an $S \subseteq \addressable{\lin,
    \pwfree}$, an $R : S \rightarrow \powerset{\nats}$ with $\biguplus_{r \in S} R(r) \supseteq [\baddr,\eaddr]$ and $\pwfree(r)
  \nsubeq \stdreg{R(r),\gc}{\pur}$ for all $r \in S$.

  Since $a \in [b,e]$, there is a unique $r \in S$ such that $a \in R(r)$.

  Since $W \oplus W_M$ is defined, we have that $r \in \dom(\pwfree) =
  \dom(\pwfree[W_M])$ and $\pwfree(r) \oplus \pwfree[W_M](r)$ is defined.

  From $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$, we get that
  $\stk = (\opc_0,\ms_0):: \dots :: (\opc_m,\ms_m)$,
  $\ms_S \uplus \ms_\stk \uplus \ms_0 \uplus \dots \uplus \ms_m$ is defined,
  $W_M = W_{\var{stack}} \oplus W_{\var{free\_stack}} \oplus W_{\var{heap}}$ and
  $\exists \ms_\var{T,stack}, \ms_\var{T,free\_stack}, \ms_\var{T,heap}$, $\ms_{T,f}$, $\ms_{S,f}$, $\ms_S'$ such that
  \begin{itemize}
  \item $\ms_S =\ms_{S,f} \uplus \ms_S'$
  \item $\ms_T = \ms_\var{T,stack} \uplus \ms_\var{T,free\_stack} \uplus
    \ms_\var{T,heap} \uplus \ms_{T,f}$
  \item $\memSatStack{\stk,\ms_\var{T,stack}}{W_{\var{stack}}}$
  \item $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$
  \item $\memSatHeap{\ms_S',\ms_\var{T,heap}}{W_\var{heap}}$.
  \end{itemize}

  From $\memSatFStack{\ms_\stk,\ms_\var{T,free\_stack}}{W_{\var{free\_stack}}}$, we get an
  $R_\ms : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \MemSeg \times \MemSeg$,
  $\ms_\var{T,free\_stack} = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_2(R_\ms(r))$,
  $\ms_\stk = \biguplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} \pi_1(R_\ms(r))$,
  $\stkb \in \dom(\ms_\var{T,free\_stack}) \wedge \stkb \in \dom(\ms_\stk)$,
  $\exists R_W : \dom(\activeReg{\pwfree[W_\var{free\_stack}]}) \fun \World\ldotp$
  $W_\var{free\_stack} = \oplus_{r \in \dom(\activeReg{\pwfree[W_\var{free\_stack}]})} R_W(r)$,
  $\forall r \in \activeReg{\pwfree[W_\var{free\_stack}]}$, we have that
  $\npair{R_\ms(r)} \in  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.

  We have that $r \in \addressable{\lin, \pwfree} \subseteq
  \activeReg{\pwfree[W_\var{free\_stack}]}$, so $\npair{R_\ms(r)} \in
  \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(R_W(r))$.
  Because $\pwfree(r) \nsubeq \stdreg{R(r),\gc}{\pur}$ and $W\oplus W_M = W \oplus (W_\var{free\_stack} \oplus W_\var{free\_stack} \oplus W_\var{stack})$ is defined, it follows that
  also $\pwfree[W_\var{free\_stack}](r) \nsubeq \stdreg{R(r),\gc}{\pur}$. This
  means that also $\npair{R_\ms(r)} \in
  H^{\mathrm{std}}_{R(r)}\; \xi^{-1}(R_W(r))$.\dominique{have we defined $\nsubeq$ somewhere?}

  From this, it follows that $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r)$ and we get a $S : R(r) \fun \World$ with $\xi(\xi^{-1}(R_W(r))) = \oplus_{\aaddr \in R(r)} S(\aaddr)$ and $\forall \aaddr \in R(r),n' < n \ldotp \npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$.

  Since $\aaddr \in R(r)$ and $n' < n$, we have that $\npair[n']{(\ms_\stk(\aaddr),\ms_T(\aaddr))} \in \lrv(S(\aaddr))$ and
  we can take $W_M' = W_r' \oplus W_{\var{heap}} \oplus (W_{\var{stack}} \oplus W_{\var{free\_stack}}')$ with $W_r' = \oplus_{\aaddr \in (R(r)\setminus \{\aaddr\})} S(\aaddr)$ and $W_\var{free\_stack}' = \oplus_{r' \in (\dom(\activeReg{\pwheap[W_\var{heap}]})\setminus \{r\})} R_W(r')$, and get
  \begin{align*}
    S(\aaddr) \oplus W_M'
    &=S(\aaddr) \oplus (W_r' \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_\var{heap}))\\
    &=
    \oplus_{\aaddr \in R(r)} S(\aaddr) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}}\oplus W_{\var{heap}})\\
    &=
    \xi(\xi^{-1}(R_W(r))) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    R_W(r) \oplus W_{\var{free\_stack}}' \oplus (W_{\var{stack}} \oplus W_\var{heap})\\
    &=
    \oplus_{r \in \dom(\activeReg{\pwheap[W_\var{free\_stack}]})} R_W(r)\oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
    &=
      W_\var{free\_stack} \oplus (W_{\var{stack}} \oplus W_{\var{heap}})\\
      &= W_M
  \end{align*}

  Additionally, if $\npair{(b,e)}\in\stackWriteCond{W}$, then
  we get an $S'\subseteq \addressable{\lin, \pwfree} \subseteq \activeReg{\pwheap[W_\var{free\_stack}]}$, an $R' : S' \fun \powerset{\nats}$ such that $\biguplus_{r \in S'} R'(r) \supseteq [\baddr,\eaddr]$ and
  for all $r \in S'$, $\pwfree(r) \nsupeq \stdreg{R'(r),\gc}{\pur}$ and
  $\pwfree(r) \text{ is address-stratified}$.

  Since $a \in [b,e]$, there is an $r' \in S'$ such that $a \in R'(r')$ .
  
  Because $W \oplus W_M$ is defined, it follows that also 
  $\pwfree[W_\var{free\_stack}](r') \nsupeq \stdreg{R'(r'),\gc}{\pur}$ and
  $\pwfree[W_\var{free\_stack}](r') \text{ is address-stratified}$.

  It follows that $r = r'$ because $\dom(R_\ms(r).1) = \dom(R_\ms(r).2) = R(r) \ni a$ and $ \dom(R_\ms(r').2) = \dom(R_\ms(r').1) = R'(r') \ni a$ and all the $R_\ms(r).1$ and $R_\ms(r).2$ are disjoint.

  We have that $\npair{(R_\ms(r).1\update{a}{0},R_\ms(r).2\update{a}{0})} \in \pwfree[W_\var{free\_stack}](r).H \; \xi^{-1}(W_r')$ because $\pwfree[W_\var{free\_stack}](r)$ is address-stratified and $\pwfree[W_\var{free\_stack}](r) \nsupeq \stdreg{R'(r),\gc}{\pur}$.

  From this, it follows that $\memSatFStack{\ms_\stk\update{a}{0},\ms_\var{T,heap}\update{a}{0}}{W_r' \oplus W_\var{free\_stack}'}$ and finally $\memSat{(\ms_S,\stk,\ms_\stk\update{a}{0},\ms_T\update{a}{0})}{W_M'}$.
\end{proof}

\begin{lemma}[purePart is idempotent]
  For all $W$, $\mathit{purePart}( \purePart{W} ) = \purePart{W}$
  \label{lem:purePart-idempotent}
\end{lemma}
\begin{proof}
  Follows easily from the definition.
\end{proof}

\begin{lemma}[non-linear words are pure]
  \label{lem:non-linear-pure}
  If $\npair{(w_1,w_2)} \in \lrv(H_\sigma,W)$ and ($\nonLinear{w_1}$ or $\nonLinear{w_2}$), then
  $\npair{(w_1,w_2)} \in \lrv(H_\sigma,\purePart{W})$.
\end{lemma}
\begin{proof}
  Follows easily by inspecting the definitions of $\lrv$, $\readCond[]{}$, $\addressable{}$, $\writeCond[]{}$, $\execCond[]{}$ and $\xReadCond[]{}$ and using Lemma~\ref{lem:purePart-idempotent}.
\end{proof}

\begin{lemma}[load from regular capability works]
  \label{lem:readcond-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$, $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrv(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \item $\aaddr \in [\baddr,\eaddr]$
  \item $\aaddr' \in [\baddr',\eaddr']$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, $\perm \in \readAllowed{}$ and $\perm' \in \readAllowed{}$, we get that $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$.

  Lemma~\ref{lem:readcond-writecond-work} then gives us a $W'$ and $W_M'$ such that $W_M = W' \oplus W_M'$ and $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))} \in \lrv(W')$.
  
  It remains to prove that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_S(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm,\perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrv(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \writeCond{\lin,W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:non-expansive}, we then get that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$.

  \item case $\neg\isLinear{\ms_S(\aaddr)}$: then $\linCons{\ms_S(\aaddr)} = \ms_S(\aaddr)$ and it follows from $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr'))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by non-expansiveness of memory satisfaction, i.e. Lemma~\ref{lem:non-expansive}.
  \end{itemize}
\end{proof}

\begin{lemma}[load from stack capability works]
  \label{lem:load-stack-cap-works}
  If
  \begin{itemize}
  \item $\memSat{(\ms_S,\stk,\ms_\stk,\ms_T)}{W_M}$
  \item $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$
  \item $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$
  \item $\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$
  \item $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$
  \item $W \oplus W_M$ is defined
  \item $n' < n$
  \item ($\aaddr \in [\baddr,\eaddr]$ or $\aaddr' \in [\baddr',\eaddr']$)
  \item $w_S = \linCons{\ms_S(\aaddr)}$, $w_T = \linCons{\ms_T(\aaddr')}$
  \item $\linConsPerm{\perm}{\ms_S(\aaddr)}$, $\linConsPerm{\perm'}{\ms_T(\aaddr')}$
  \end{itemize}
  Then $\exists W', W_M'\ldotp$
  \begin{itemize}
  \item $W_M = W' \oplus W_M'$
  \item $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$
  \item $\npair[n']{(\ms_\stk(a),\ms_T(a))} \in \lrv(W')$
  \end{itemize}
\end{lemma}
\begin{proof}
  From $\npair{(c,c')}\in\lrv(H_\sigma,W)$ with $c = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $c' = ((\perm',\lin'),\baddr',\eaddr',\aaddr')$, ($\perm \in \readAllowed{}$ or $\perm' \in \readAllowed{}$), we get that $\perm = \perm'$, $\lin' = \linear$, $\baddr = \baddr'$, $\eaddr = \eaddr'$ and $\aaddr = \aaddr'$ and $\npair{(\baddr,\eaddr)} \in \stackReadCond{W}$.

  From Lemma~\ref{lem:stackreadcond-stackwritecond-work}, we then get that $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.
  

  It remains to prove that $\memSat{(\ms_S,\stk,\ms_\stk\update{\aaddr}{w_S},\ms_T\update{\aaddr'}{w_T})}{W_M'}$.
  We have to distinguish the case that $\isLinear{\ms_\stk(\aaddr)}$ and the opposite case.
  \begin{itemize}
  \item case $\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = 0$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = 0$. 
    From $\linConsPerm{\perm}{\ms_S(\aaddr)}$ and $\linConsPerm{\perm'}{\ms_T(\aaddr')}$, we then also get that $\perm = \perm' \in \writeAllowed{}$ and from $\npair{(c,c')}\in\lrvg{\trust}(H_\sigma,W)$, it then follows that $\npair{(\baddr,eaddr)} \in \stackWriteCond{W}$.
    From the ``Additionally, if..'' case in Lemma~\ref{lem:readcond-writecond-work} with Lemma~\ref{lem:non-expansive}, we then get that $\memSat[n']{(\ms_S,\stk,\ms_\stk\update{\aaddr}{0},\ms_T\update{\aaddr'}{0})}{W_M'}$.

  \item case $\neg\isLinear{\ms_\stk(\aaddr)}$: then $\linCons{\ms_\stk(\aaddr)} = \ms_\stk(\aaddr)$ and it follows from $\npair[n']{(\ms_\stk(a),\ms_T(a))}\in\lrv(H_\sigma,W)$ that also $\neg\isLinear{\ms_T(\aaddr')}$ \dominique{Do we need a lemma for this?} and $\linCons{\ms_T(\aaddr')} = \ms_T(\aaddr')$.
    The fact that $\memSat[n']{(\ms_S\update{\aaddr}{w_S},\stk,\ms_\stk,\ms_T\update{\aaddr'}{w_T})}{W_M'}$ then follows simply by non-expansiveness of memory satisfaction, i.e. Lemma~\ref{lem:non-expansive}.
  \end{itemize}
\end{proof}

\section{FTLR proof}
By induction over $n$\footnote{if $n=0$, then we have a contradiction with $\Phi_S\term[i]$ and $\Phi_T\term[i]$ when we get to $\lro$.}.
\begin{proof}
  Assume
  \begin{itemize}
  \item $\trust = \trusted \vee \npair{(\baddr,\eaddr)} \in \readCond{\lin,W}$
  \item $\npair{(\baddr,\eaddr)} \in \xReadCond{\lin,W}$
  \end{itemize}
  and one of the following sets of requirements holds:
  \begin{enumerate}[label={\roman*)}]
  \item \begin{itemize}
    \item $W \vdash_{(\ta,\stkb)} (\mscode,\_,\_,\_,\sigrets,\sigcloss)$
    \item $[\baddr,\eaddr] \subseteq \dom(\mscode) = \ta$
    \item $\trust = \trusted$
    \item For all $\npair{\stpair{\reg}{\reg}} \in \lrrtrusted(W)$ and $\memSat{\src{\ms_S},\src{\ms_\stk},\src{\stk},\ms_T}{W}$ and $\ms_f$, we have $\src{\Phi} = (\src{\ms_S} \uplus \ms_f, \src{reg_S}, \src{\stk}, \src{\ms_\stk})$ and 
      \begin{itemize}           
      \item $\src{\Phi}$ checks $\stkb$ before calls in $\ta$ for $n$ steps (Definition~\ref{def:check-stack-addr-before-call}).
      \item $\src{\Phi}$ uses link seals properly in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:use-return-seals-call}).
      \item $\src{\Phi}$ handle trusted seals properly in $\ta$ with components parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:handle-trusted-seals-properly}).
      \item $\src{\Phi}$ does not store link seals and code capabilities in $\ta$ with component parameters $\sigrets$ and $\sigcloss$ for $n$ steps (Definition~\ref{def:never-store-seal-code-cap}).
      \end{itemize}
    \end{itemize}
  \item
    \begin{itemize}
    \item $[\baddr,\eaddr] \mathrel{\#} \ta$
    \item $\trust = \untrusted$
    \end{itemize}
  \end{enumerate}
and show
\[
\npair{((\rx,\lin),\baddr,\eaddr,\aaddr),
       ((\rx,\lin),\baddr,\eaddr,\aaddr)} \in \lreg{\trust}(W)
\]
We write $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$.\\

Let $n' \leq n$ be given and assume
\begin{enumerate}
\item $\npair[n']{\stpair{\reg}{\reg}} \in \lrrg{\trust}(W_R)$ \label{item:reg-ass}
\item $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$\label{item:mem-ass}
\item $W \oplus W_R \oplus W_M$ is well-defined\label{item:worlds-def}
\end{enumerate}
Further let
\begin{itemize}
\item $\Phi_S = (\ms_S,\reg_S\updReg{\pcreg}{c},\stk,\ms_\stk)$
\item $\Phi_T = (\ms_T,\reg_T\updReg{\pcreg}{c})$
\end{itemize}
and pick
\begin{itemize}
\item $\Phi_S' = \xjumpResult{c}{c}{\Phi_S}$
\item $\Phi_T' = \xjumpResult{c}{c}{\Phi_T}$
\end{itemize}
and show
\[
  \npair[n']{(\Phi_S',\Phi_T')} \in \lro
\]
In order to do this, we first, we prove that one of the following holds:
\begin{itemize}
\item $\Phi_S \step \failed$ and $\Phi_T \step\failed$
\item $\Phi_S \step \halted$ and $\Phi_T \step\halted$
\item All of the following hold:
  \begin{itemize}
  \item $\callCond{\Phi_S,r_1,r_2,\aaddr}$
  \item $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$
  \item $\exec{\Phi_S(\pcreg)}$
  \item for all $i = 0..\calllen-1$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i) \in \ints$.
  \item TODO: other useful info
  \end{itemize}
\item All of the following hold: (includes simple cases: gettype, geta, getb, gete, getp, getl, lt, plus, minus, that can be handled uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r}{z}} \neq \failed$
  \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r}{z}} \neq \failed$
  \item $z \in \ints$
  \end{itemize}
\item All of the following hold: (includes cap-manipulation cases: move, cca, restrict, seta2b, cseal, split, splice, that can be handled mostly uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' = \updPcAddr{\Phi_S\updReg{r_1\cdots r_k}{w_1\cdots w_k}}\neq \failed$
  \item $\Phi_T' = \updPcAddr{\Phi_T\updReg{r_1\cdots r_k}{w_1'\cdots w_k'}} \neq \failed$
  \item One of the following holds:
    \begin{itemize}
    \item (restrict,cca,seta2b) $w_1 = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $w_1' = ((\perm',\lin),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi_T(r_1) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k = 1$
    \item (restrict,cca,seta2b) $w_1 = \stkptr{\perm',\baddr,\eaddr,\aaddr'}$, $w_1' = ((\perm',\linear),\baddr,\eaddr,\aaddr')$, $\Phi_S(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$ and $\Phi_T(r_1) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$ and $\perm' \sqsubseteq\perm$, $k = 1$
    \item (move) $w_1 = \Phi_S(r_1)$, $w_1' = \Phi_S(r_1)$, and
      $\isLinear{w_1} \Rightarrow w_2 = w_2' = 0$, and $\neg
      \isLinear{w_1} \Rightarrow (w_2 = \Phi_S(r_2) \wedge w_2' = \Phi_T(r_2)$)
      and $k = 2$.
    \item (cseal) $w_1 = \sealed{\sigma,\Phi_S(r_1)}$, $w_1' = \sealed{\sigma,\Phi_T(r_1)}$, $\Phi_S(r_2) = \Phi_T(r_2) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $k=1$
    \item (split) $\Phi_T(r_3) = \Phi_S(r_3) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$, $w_1 = w_1' = ((\perm,\lin),\baddr,n,\aaddr)$, $w_2 = w_2' = ((\perm,\lin),n+1,\eaddr,\aaddr)$, $k=2$.
    \item (split) $\Phi_T(r_3) = \Phi_S(r_3) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$, $\sigma_\baddr \leq n$, $n < \sigma_\eaddr$, $w_1 = w_1' = \seal{\sigma_\baddr,n,\sigma}$, $w_2 = w_2' = \seal{n+1,\sigma_\eaddr,\sigma}$, $k=2$.
    \item (split) $\Phi_S(r_3) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $\Phi_T(r_3) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $\baddr \leq n$, $n < \eaddr$, $w_1 = \stkptr{\perm,\baddr,n,\aaddr}$, $w_1' = ((\perm,\linear),\baddr,n,\aaddr)$, $w_2 = \stkptr{\perm,n+1,\eaddr,\aaddr}$, $w_2' = ((\perm,\linear),n+1,\eaddr,\aaddr)$, $k=2$.
    \item (splice) $\Phi_T(r_2) = ((\perm,\linear),\baddr_2,\eaddr_2,\_)$,
      $\Phi_S(r_2) = \stkptr{\perm,\baddr_2,\eaddr_2,\_}$, and
      $\Phi_T(r_3) = ((\perm,\linear),\eaddr_2+1,\eaddr_3,\aaddr_3)$,
      $\Phi_S(r_3) = \stkptr{\perm,\eaddr_2+1,\eaddr_3,\aaddr_3}$, and
      $\baddr_2 \leq \eaddr_2$, and
      $\eaddr_2+1 \leq \eaddr_3$, and
      $w_1=((\perm,\linear),\baddr_2,\eaddr_3,\aaddr_3)$, $w_1'=
      \stkptr{\perm,\baddr_2,\eaddr_3,\aaddr_3}$, and
      $w_2 = w_2' = w_3 = w_3' = 0$, and
      $k=3$
    \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) =
      ((\perm,\lin),\baddr_2,\eaddr_2,\_)$, and
      $\Phi_T(r_3) = \Phi_S(r_3) = ((\perm,\lin),\eaddr_2+1,\eaddr_3,\aaddr_3)$,
      and
      $\baddr_2 \leq \eaddr_2$, and $\eaddr_2+1 \leq \eaddr_3$, and
      $w_1=w_1'=((\perm,\lin),\baddr_2,\eaddr_3,\aaddr_3)$, and
      $\lin = \linear \Rightarrow w_2 = w_2' = w_3 = w_3' = 0$, and
      $\lin = \normal \Rightarrow (w_2 = w_2' = \Phi_T(r_2) \text{ and } w_3 =
      w_3' = \Phi_T(r_3))$, and $k=3$
    \item (splice) $\Phi_T(r_2) = \Phi_S(r_2) = \seal{\sigma_{\baddr,2},\sigma_{\eaddr,2},\_}$, and $\Phi_T(r_3) = \Phi_S(r_3) = \seal{\sigma_{\eaddr,2}+1,\sigma_{\eaddr,3},\sigma_{\aaddr,3}}$, and $\sigma_{\baddr,2} \leq \sigma_{\eaddr,2}$, and $\sigma_{\eaddr,2} + 1 \leq \sigma_{\eaddr,3}$and $w_1 = w_1' = \seal{\sigma_{\baddr,2}, \sigma_{\eaddr,3}, \sigma}$
      \end{itemize}
  \end{itemize}
\item All of the following hold: (includes memory-manipulation cases: store, load, that can be handled mostly uniformly)
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' =
    \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\mem.\aaddr}{w}}$
  \item $\Phi_T' =
    \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\mem.\aaddr}{w'}}$
  \item One of the following hold:
    \begin{itemize}
    \item (store) $w_1 = w_1' = \Phi_S(r_1) = \Phi_T(r_1) =
      ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \writeAllowed{}$,
      and
      $\withinBounds{w_1}$, and\\
      $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
      w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
      \text{ and } w_2' = \Phi_T(r_2))$.
    \item (load) $w_2 = w_2' = \Phi_T(r_2) = \Phi_S(r_2) =
      ((\perm,\lin),\baddr,\eaddr,\aaddr)$, and $\perm \in \readAllowed{}$,
      $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and \\
      $w_1 = \Phi_S.\mem(\aaddr)$, and $w_1' = \Phi_T.\mem(\aaddr)$, and \\
      $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
      $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
    \end{itemize}
  \end{itemize}
\item All of the following hold: (includes memory-manipulation cases: store, load, that can be handled mostly uniformly (stack))
  \begin{itemize}
  \item $\Phi_S \step \Phi_S'$
  \item $\Phi_T \step \Phi_T'$
  \item $\Phi_S' =
    \updPcAddr{\Phi_S\updReg{r_1,r_2}{w_1,w_2}\update{\ms_\stk.\aaddr}{w}}$
  \item $\Phi_T' =
    \updPcAddr{\Phi_T\updReg{r_1',r_2'}{w_1',w_2'}\update{\ms_\stk.\aaddr}{w'}}$
  \item One of the following hold:
    \begin{itemize}
    \item (store) $w_1 = \Phi_T(r_1) = ((\perm,\linear),\baddr,\eaddr,\aaddr)$, $w_1' =  \Phi_S(r_1) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \writeAllowed{}$,
      and
      $\withinBounds{w_1}$, and\\
      $w = \Phi_S(r_2)$, and $w' = \Phi_T(r_2)$, and $\isLinear{w} \Rightarrow
      w_2 = w_2' = 0$, and $\neg \isLinear{w} \Rightarrow (w_2 = \Phi_S(r_2)
      \text{ and } w_2' = \Phi_T(r_2))$.
    \item (load) $ w_2' = \Phi_T(r_2) =
      ((\perm,\linear),\baddr,\eaddr,\aaddr)$, and $w_2 = \Phi_S(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, and $\perm \in \readAllowed{}$,
      $\withinBounds{((\perm,\lin),\baddr,\eaddr,\aaddr)}$, and $\aaddr \in
      \dom(\Phi.\ms_\stk)$, and $\aaddr \in \dom(\Phi.\ms_\stk)$, and\\
      $w_1 = \Phi_S.\ms_\stk(\aaddr)$, and $w_1' = \Phi_T.\ms_\stk(\aaddr)$, and \\
      $\isLinear{w_1} \Rightarrow w = w' = 0$, and \\
      $\neg \isLinear{w_1} \Rightarrow w = w_1 \text{ and } w' = w_1'$
    \end{itemize}
  \end{itemize}


\item All of the following hold: (includes memory-manipulation cases: jmp, jnz, xjmp, that can be handled mostly uniformly)
  \begin{itemize}
  \item 
  \end{itemize}
\end{itemize}

Now assume that one of the configurations terminates etc.

\subsubsection*{Assuming source machine terminates}
First show the former of the two, assume $\Phi_S\term[i]$.
Since $\Phi_S \neq \halted$, we have that $1 \leq i \leq n'$.

We know that $\Phi_S(\pcreg) = \Phi_T(\pcreg) = c$, $c=((\rx,\lin),\baddr,\eaddr,\aaddr)$, $\npair{(\baddr,\eaddr)}\in \readCond{\lin,W}$ and $\npair{(\baddr,\eaddr)}\in \xReadCond{\lin,W}$.
From Lemma~\ref{lem:readcond-writecond-work}, using Lemma~\ref{lem:non-expansive}, $\memSat[n']{\ms_S,\stk,\ms_\stk,\ms_T}{W_M}$ (from assumption~\ref{item:mem-ass}) and $W \oplus W_R \oplus W_M$ is well-defined (assumption~\ref{item:worlds-def}), we get (for any $a' \in [\baddr,\eaddr]$) that $\npair[n'-1]{(\ms_S(a'),\ms_T(a'))} \in \lrv(W')$ for some $W'$ such that $W_M = W' \oplus W_M'$.

Since $\Phi_S \neq \halted$ and $\Phi_S\term[i]$, it must take a next execution step and $\Phi_S \not\step\failed$. 
This is only possible if one of the following holds:
\begin{itemize}
\item $\callCond{\Phi_S,r_1,r_2,\aaddr}$ and
  $\baddr \leq \aaddr \tand \aaddr + \calllen-1 \leq \eaddr$ and 
  $\exec{\Phi_S(\pcreg)}$.

  In this case, we have for all $i = 0..\calllen-1$ that $\npair[n']{(\ms_S(\aaddr+i),\ms_T(\aaddr+i))} \in \lrv(W')$ for some $W'$, and also $\ms_S(\aaddr+i) \in \ints$, so by definition of $\lrv$, $\ms_T(\aaddr+i) = \ms_S(\aaddr+i)$.
\item ($\src{(\neg\callCond{\Phi_S,r_1,r_2,\aaddr}}$ or $\src{\eaddr < \aaddr + \calllen-1) \tand}$) and
  $\withinBounds{\Phi_S(\pcreg)}$ and $\exec{\Phi_S(\pcreg)}$.

  In this case, we have that $\npair[n']{(\ms_S(\aaddr),\ms_T(\aaddr))} \in \lrv(W')$ for some $W'$, and also $\ms_S(\aaddr) \in \ints$ (since $\Phi_S \not\step\failed$), so by definition of $\lrv$, we have that $\ms_T(\aaddr) = \ms_S(\aaddr)$.
\end{itemize}

We now consider the first step of $\Phi_S \term[i]$ (we have already mentioned that $i \geq 1$).
The possible instructions that could have been executed are:
\begin{enumerate}
\item $\tfail$
\item $\thalt$
\item $\tjmp{\trg{r_1}}$
\item $\tjnz{\trg{r_1}}{\trg{\rn}}$
\item $\tisptr{\trg{r_1}}{\trg{r_2}}$
\item $\tgeta{\trg{r_1}}{\trg{r_2}}$
\item $\tgetb{\trg{r_1}}{\trg{r_2}}$
\item $\tgetp{\trg{r_1}}{\trg{r_2}}$
\item $\tgetlin{\trg{r_1}}{\trg{r_2}}$
\item $\tmove{\trg{r_1}}{\trg{\rn}}$
\item $\tstore{\trg{r_1}}{\trg{r_2}}$
\item $\tload{\trg{r_1}}{\trg{r_2}}$
\item $\tcca{\trg{r_1}}{\trg{\rn}}$
\item $\trestrict{\trg{r_1}}{\trg{r_2}}{\trg{\rn}}$
\item $\tlt{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tplus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tminus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$
\item $\tsetatob{\trg{r_1}}{\trg{r_2}}$
\item $\txjmp{\trg{r_1}}{\trg{r_1}}$
\item $\tcseal{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\tsplice{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$
\item $\scall[o]{}{r_1}{r_2}$
\end{enumerate}

\paragraph{Case: $\protect\tfail$}
Contradiction, because then $\Phi_S \step \failed \not\nstep[i-1] \halted$.

\paragraph{Case: $\protect\thalt$}
In this case $\Phi_S \step \halted$.
We've seen above that $\ms_T(\aaddr) = \ms_S(\aaddr)$, so because $\decInstr{}$ is shared by source and target, we have that $\Phi_T \step\halted$.

\paragraph{Case: $\protect\tjmp{\trg{r_1}}$}

\paragraph{Case: $\protect\tjnz{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tisptr{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\protect\tgeta{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgetb{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgete{\trg{r_1}}{\trg{r_2}}\mid$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tgetlin{\trg{r_1}}{\trg{r_2}}$}
Similar to the case for $\tisptr{\trg{r_1}}{\trg{r_2}}$.

\paragraph{Case: $\protect\tmove{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tstore{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\protect\tload{\trg{r_1}}{\trg{r_2}}$}
Since $\Phi_S\not\step\failed$, we have that $\Phi_S \step \Phi_S' \term[i-1]$ and one of the following cases hold: 
\begin{itemize}
\item \[\Phi_S' = \updPcAddr{\Phi\update{\mem.a}{w_2}\updReg{r_1}{w}}\]
  with $\Phi(r_2) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ 
  $\perm \in \readAllowed{}$, $\withinBounds{\Phi(r_2)}$, $w = \Phi.\mem(a)$ and $w_2 = \linCons{w}$ and $\linConsPerm{w,\perm}$
\item \[\Phi_S' = \updPcAddr{\Phi \update{\ms_\stk.a}{w_2}\updReg{r_1}{w}}\]
  with $\Phi(r_2) = \stkptr{\perm,\baddr,\eaddr,\aaddr}$, $\perm \in \readAllowed{}$, $\withinBounds{\Phi(r_2)}$, $\aaddr \in \dom(\Phi.\ms_\stk)$, $w = \Phi.\ms_\stk(a)$ and $w_2 = \linCons{w}$ and $\linConsPerm{w,\perm}$
\end{itemize}

\paragraph{Case: $\protect\tcca{\trg{r_1}}{\trg{\rn}}$}

\paragraph{Case: $\protect\trestrict{\trg{r_1}}{\trg{r_2}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tlt{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tplus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tminus{\trg{r_1}}{\trg{\rn}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsetatob{\trg{r_1}}{\trg{r_2}}$}

\paragraph{Case: $\scall[o]{}{r_1}{r_2}$}
\dominique{Adapt to new treatment of $H_\sigma$ as non-global}
In case $\scall[o]{}{r_1}{r_2}$ is the first step of the execution. We can assume $r_1,r_2 \neq \pcreg$ as this would cause the execution to fail\footnote{Assuming $\pcreg$ was one of the two registers, then the step relation would reqiure the register to contain an executable capability while the call semantics would require there to be a sealed capability.}\footnote{{\color{red} TODO:} We still have to consider what happens if the temp register is jumped to.}. By assumption \ref{item:reg-ass}, $\npair[n']{\stpair{\reg}{\reg}} \in \lrr(W_R)$ which in particular means that for suitable $W_{R,1}$ and $W_{R,2}$
\[
  \npair[n']{(\src{\reg_S}(r_i),\reg_T(r_i))} \in \lrv(W_{r,1}) \text{ for i = 1,2}
\]
We can further deduce that $\src{\reg_S}(r_i)$ for $i=1,2$ are sealed capabilities as the execution would otherwise fail. This gives us
\[
  \begin{array}{l}
    \forall W' \future W_{R,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}.
\]
At this point, we need to pick a suitable $W' \future W_{R,1}$. To this end, we need to know a bit about $W_{R,1}$. From the operational semantics and in particular the semantics of $\scall{}{}{}{}$, we know $\Phi_S(\rstk) = \stkptr{\rw,\baddr_\stk,\eaddr_\stk,\aaddr_\stk}$ and by assumption $\npair[n']{(\src{\reg_S(\rstk)},\trg{\reg_T(\rstk)})} \in \lrv(W_{R,\stk})$. From this we can conclude that there is a stack region (specifically a spatially owned region) $r$ for which $\pwfree[W_{R,\stk}](r) \nequal[n'-1] \stdreg{[\baddr_\stk',\eaddr_\stk'],\gc}{\spa}$ where $[\baddr_\stk',\eaddr_\stk'] \supseteq [\baddr_\stk,\eaddr_\stk]$\footnote{Actually concluding this involves knowing that $W_{R,\stk}$ is ``well-formed'' which we use the heap satisfaction assumption to conclude. Perhaps a notion of well-formed worlds would be good along with a couple of lemmas that use it to make this reasoning once and for all.}. As $W_{R,\stk} \oplus W_{R,1}$ is well-formed, $\pwfree[W_{R,1}](r)$ must be a similar spatial region to the one in $W_{R,\stk}$.
\dominique{How do we know $r_1 \neq \rstk$? Exclude in syntax?}
We pick $W'$ to be
\[
  \begin{array}{r l}
    W' = W     & \update{\mathrm{free}.r}{\revoked}\\
               & \update{\mathrm{free}.x}{\stdreg{[\baddr_\stk',\aaddr_\stk -1],\gc}{\spa}}\\
               & \update{\mathrm{priv}.y}{(\stdreg{[\aaddr_\stk,\eaddr_\stk],\gc}{\spa},\opc)}\\
               & \update{\mathrm{free}.z}{\stdreg{[\eaddr_\stk+1,\eaddr_\stk'],\gc}{\spa}}
  \end{array}
\]
\dominique{16-3-2018: shouldn't $W'$ be defined as a modification of $W_{R,1}$ rather than $W$?}
\lau{12-03-2018: Write what $\opc$ is.}
where $x$, $y$, and $z$ are fresh region names in the respective part of the world. To indicate similar worlds to $W'$ with the same ownership as another world well-defined w.r.t. $W$, we write $W'_{R,1}$ with the same spatially owned region as $W_{R,1}$. Using the private part of the future world relation, it is easy to see that $W'$ is a future world of $W_{R,1}$ (by the operational semantics $\baddr_\stk < \aaddr_\stk \leq \eaddr_\stk$, so the new region at $y$ is non-empty). Using Lemma~\ref{lem:monotonicity}, we get
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W'_{R,2}
\]
which we use to get:
\dominique{instantiate $n''$ to something?}
\[
  \npair[n'']{(\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2))} \in \lrexj(W_{R,1}' \oplus W_{R,2}')
\]
In order to use this, we need to pick a register-file pair and suitable memories. We pick a $\Phi_S$ in $\lrexj$, so the $\Phi_S'$ in $\lrexj$ becomes the $\Phi_S'$ we assumed $\Phi_S$ steps to. Specifically
\[
  \Phi_S.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_S(r_1)}}\\
    \update{r_2}{\linCons{\Phi_S(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk}\\
    \update{\rretc}{c_{\ret,c}}\\
    \update{\rretd}{c_{\ret,d}}\\
    \update{\rtmp{1}}{0}\\
  \end{array}
\]
where
\begin{itemize}
\item $c_\stk = \stkptr{\rw,\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1}$
\item $c_{\ret,c} = \retptrc(\sigma',(\perm,\lin),\baddr,\eaddr,\aaddr+\calllen))$
\item $c_{\ret,d} = \retptrd(\sigma',(\aaddr_\stk,\eaddr_\stk))$
\end{itemize}
and
$\ms_S,((\opc,\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}\update{\aaddr_\stk}{42}) :: \stk),\ms_\stk-\ms_\stk|_{[\aaddr_\stk,\eaddr_\stk]}$

For the target side, we pick the register-file
\[
  \Phi_T.\reg
  \begin{array}[t]{l}
    \update{r_1}{\linCons{\Phi_T(r_1)}}\\
    \update{r_2}{\linCons{\Phi_T(r_2)}}\\
    \update{\pcreg}{0} \\
    \update{\rdata}{0} \\
    \update{\rstk}{c_\stk'}\\
    \update{\rretc}{c_{\ret,c}'}\\
    \update{\rretd}{c_{\ret,d}'}\\
    \update{\rtmp{1}}{0}\\
  \end{array}  
\]
where
\begin{itemize}
\item $c_\stk' = ((\rw,\linear),\baddr_\stk,\aaddr_\stk-1,\aaddr_\stk-1)$
\item $c_{\ret,c}' = \sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)}$
\item $c_{\ret,d}' = \sealed{\sigma',((\rw,\linear),\aaddr_\stk,\eaddr_\stk,\aaddr_\stk-1)}$
\end{itemize}
\lau{We do not actually check the linearity of the stack, but it should have been checked that the base address actually is the stack base address which would give us that it is linear. This is not an assumption we have formally stated at the moment!}
and the same memory
\[
  \Phi_T.\ms_T\update{\aaddr_\stk}{42}
\]
We have to argue (1) that this register-file pair is in the register-file relation for a world $W_R'$ with the same ownership as $W_R$ and regions $x$ and $y$ are owned, and (2) the memory-pair satisfies the memory satisfaction relation for a world $W_M'$ (i.e. with the same ownership as $W_M$).
 
Let's start with (2). Here we use that we took a standard region and replaced by three standard regions. This means that when we split up the memory, we can reuse the same splitting of memory and world (w.r.t memory) except for the memory segment that previously satsfied the standard region in question. This memory segment, we split in three, so each piece fit with one of the new regions.

For (1), we need to consider the contents of all registers. For the registers that were not overwritten, their safety follows from the register-file relation assumption we start with along with monotonicity and non-expansiveness of the value relation. This is also the case for $r_i$, $i=1,2$ if the capability is linear and it is trivial otherwise (as it is $0$). $\rtmp{1}$ is also trivial as it is $0$. This leaves $\rstk$, $\rretc$, and $\rretd$.

For $\rstk$, we make sure the $x$ region is owned in the world we use. Now we use that we had a standard region governing the stack to get that everything on there is in the value relation. We then use the monotonicity of the value relation to conclude that everything is in the value relation in this future world which satisfies the read and write condition.

For $\rretc$ we pick $W'$ as our world. It should be the case that $H_\sigma \; \sigma' \; W''_o$ only contains one \emph{executable} pair, namely the one we consider. Let $W'' \future W$, $n''<n'$, and $(c_S',\vsc_T') \in H_\sigma \; \sigma' \; W''_o$ be given and show
\[
  \npair[n'']{(c_{\ret,c},c_S',\sealed{\sigma',((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots)},\sealed{\sigma',\vsc_T})} \in \lrexj(W'')
\]
Here we can assume $(c_S',\vsc_T') \in H_\sigma \; \sigma' \;W''_o$ is a data capability pair\footnote{if it is not, then the execution would fail. Further, the other case we would have to consider ($c_{\reg,c}$ as the data capability) would also fail.}.\footnote{{\color{red}This suggest that $H_\sigma$ should accept only stack capabilities and specifically non-empty ones.}}

{\color{DarkRed}
  A this point, we would like to use the induction hypothesis with the assumptions we get from $\lrexj$. That is, we use the induction hypothesis to (hopefully) get

\[
  \npair[n'']{((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen-\dots),((\perm,\lin),\baddr,\eaddr,\aaddr+\calllen)} \in \lre(W'')
\]
(notice that the target has ``caught up'' here.) The assumptions we get from $\lrexj(W'')$ are not synced, so this would indicate that we need the target side to catch up.
}

\paragraph{Case: $\protect\txjmp{r_1}{r_2}$} 
\dominique{Adapt to new treatment of $H_\sigma$ as non-global}
In the case $\txjmp{r_1}{r_2}$\footnote{$\pcreg$ is a corner case here. It will fail contradicting previous assumption of termination.} was executed, we know that $\Phi_S(r_1)$ and $\Phi_S(r_2)$ either points to two sealed capabilities or a return pointer pair (all other cases result in $\Phi_S \step \failed$ contradicting $\Phi_S\term[i]$). From assumption \ref{item:reg-ass} we know
\[
  \npair[n']{(\Phi_S(r_i), \Phi_T(r_i))} \in \lrv(W_{R,i}) \text{ for $i = 1,2$}
\]
where $W_{R,i}$ are partitions of the partitioning of $W_R$ we get from assumption \ref{item:reg-ass}. From the previous observation w.r.t. $\Phi_S(r_1)$ and $\Phi_S(r_2)$, we know that we are in the "sealed capability case" of $\lrv$. This in particular gives us that
\[
  \begin{array}{l}
    \forall W' \future W_{r,1}, W_o, n'' < n', (c_S,c_T) \in H_\sigma \; \sigma \; W_o \ldotp \\
    \quad \npair[n'']{\Phi_S(r_1),c_S,\Phi_T(r_1),\sealed{\sigma,c_T}} \in \lrexj(W' \oplus W_o) \wedge \dots
  \end{array}
\]
and
\[
  (\Phi_S(r_2), \vsc_{T,2}) \in H_\sigma \; \sigma \; W_{R,2}
\]
where $\Phi_T(r_2) = \sealed{\sigma,\vsc_{T,2}}$.
Now use the former with $W'=W_{R,1}$, $W_o = W_{R,2}$, and $n'' = i-1$ to get
\[
  \npair[i-1]{\Phi_S(r_1),\Phi_S(r_2),\Phi_T(r_1),\Phi_T(r_2)} \in \lrexj(W_{R,1} \oplus W_{R,2}) 
\]
Using $\lrexj$, we want to ``start from'' configuration pair $(\Phi_S,\Phi_T)$ and end up in $(\Phi_S',\Phi_T')$ where
\begin{itemize}
\item $\Phi_S' = \xjumpResult{\Phi_S(r_1)}{\Phi_S(r_2)}{\Phi_S}$
\item $\Phi_T' = \xjumpResult{\Phi_T(r_1)}{\Phi_T(r_2)}{\Phi_T}$
\end{itemize}
so we simply pick the same memory as in $\Phi_S,\Phi_T$ and the same register file but with $r_1$ and $r_2$ cleared if $\Phi(r_i)$ is linear, respectively. Using $W_M$ memory satisfaction follows from assumption \ref{item:mem-ass}. Using $W_R$ with all the ownership of regions owned by $W_{R,i}$, $i =1,2$ stripped, the register-file satisfaction follows from \ref{item:reg-ass}. Finally the $\npair[i-1]{[(\Phi_S(r_1),\Phi_T(r_1)),(\Phi_S(r_2),\Phi_T(r_2))]}\in\lrp(W_{R,1},W_{R,2})$ follows from the $\lrv$ assumption. Finally the consistency of the worlds we use follows easily.

All in all, this allows us to conclude
\[
  \npair[i-1]{\Phi_S',\Phi_T'} \in \lro
\]
From the assumption $\Phi_S\term[i]$, we get $\Phi'_S\term[i-1]$ which we use with the above to conclude $\Phi_T' \term$. By the operational semantics of $\txjmp{r_1}{r_2}$, $\Phi_T \step \Phi_T'$ with which we conclude $\Phi_T \term$.

% Now show
% \[
%   \Phi_T \term[i] \Rightarrow \Phi_S \term
% \]

\paragraph{Case: $\protect\tcseal{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$}

\paragraph{Case: $\protect\tsplit{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}{\trg{\rn}}$}

\paragraph{Case: $\protect\tsplice{\trg{r_1}}{\trg{r_2}}{\trg{r_3}}$}

\subsubsection*{Assuming target machine terminates}
\dominique{I suspect it would be more economical to not treat this case separately from the above (source machine terminates), but rather prove both results simultaneously by induction on the length of the terminating execution.}
\paragraph{Case: }
In the case  is the first step of the execution,


\end{proof}

\begin{lemma}[call lemma]
  
\end{lemma}

\section{TODO/Notes}
\begin{itemize}
\item Boundary crossing can occur on jump, xjump, call \emph{and} step!
  \begin{itemize}
  \item Make a lemma for updatePc that handles the latter once and for all. Maybe make a general lemma for all boundary crossings
    \begin{itemize}
    \item updatePc special case
    \item argue about boundary crossing, trusted/untrusted, sanity conditions
    \end{itemize}
  \end{itemize}
\item Lemma about call
\end{itemize}
\end{document}
