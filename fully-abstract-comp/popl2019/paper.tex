%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
% \acmJournal{PACMPL}
% \acmVolume{1}
% \acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
% \acmArticle{1}
% \acmYear{2018}
% \acmMonth{1}
% \acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
% \startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear
\usepackage[utf8]{inputenc}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


% %% Some recommended packages.
% \usepackage{booktabs}   %% For formal tables:
%                         %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{wrapfig}

\usepackage{placeins}

\usepackage{todonotes}

\input{preamble-illu}

\input{../preamble}
% Paper specific redefinitions of commands
\renewcommand{\MemSeg}{\shareddom{MemSeg}}
\renewcommand{\Reg}{\shareddom{RegFile}}
\renewcommand{\RegName}{\shareddom{RegName}}
\renewcommand{\decInstr}[1]{\plainfun{decode}{#1}}
\renewcommand{\updPcAddr}[1]{\plainfun{updPc}{#1}}
\renewcommand{\linCons}[1]{\plainfun{linClear}{#1}}
\renewcommand{\nonExec}[1]{\plainfun{nonExec}{#1}}
\renewcommand{\perm}{\var{p}}
\renewcommand{\SealableCaps}{\shareddom{Sealables}}
\renewcommand{\Cap}{\shareddom{NatTok}}

\newcommand{\xjmpres}[1]{\plainfun{xjmpRes}{#1}}

\newcommand{\trgcm}{\textsc{LCM}}
\newcommand{\srccm}{\textsc{oLCM}}

\begin{document}

%% Title information
\title{\stktokens{}: Enforcing Well-bracketed Control Flow and Stack Encapsulation using Linear Capabilities}
% \titlenote{with title note}
% \subtitle{Fully abstract overlay semantics}
% \subtitlenote{with subtitle note}

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

\author{Lau Skorstengaard}
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \institution{Aarhus~University}
  \country{Denmark}                    %% \country is recommended
}
\email{lask@cs.au.dk}

%% Author with two affiliations and emails.
\author{Dominique Devriese}
\orcid{0000-0002-3862-6856}             %% \orcid is optional
\affiliation{
  \institution{KU~Leuven}           %% \institution is required
  \country{Belgium}                   %% \country is recommended
}
\email{dominique.devriese@cs.kuleuven.be}         %% \email is recommended

\author{Lars Birkedal}
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \institution{Aarhus~University}
  \country{Denmark}                    %% \country is recommended
}
\email{birkedal@cs.au.dk}

\begin{abstract}
  We propose and study \stktokens{}: a new calling convention that provably enforces well-bracketed control flow and local state encapsulation on a capability machine.
  The calling convention is based on linear capabilities, a type of capabilities that are prevented from being duplicated by the hardware.
  In addition to designing and formalising this new calling convention, we also contribute a new way to formalise and prove that it effectively enforces well-bracketed control flow and local state encapsulation, using what we call a fully abstract overlay semantics.
\end{abstract}


% %% 2012 ACM Computing Classification System (CSS) concepts
% %% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


\keywords{fully abstract compilation, secure compilation, capability machines, linear capabilities, well-bracketed control flow, stack frame encapsulation, overlay semantics}


\maketitle


\section{Introduction}
\label{sec:introduction}
Secure compilers preserve source-language (security-relevant) properties even when the compiled code interacts with arbitrary target-language components.
Generally, properties that hold in the source language but not in the target language need to be somehow enforced by the compiler.
Two properties that hold in many high-level source languages, but not in the assembly languages they are compiled to, are well-bracketed control flow and encapsulation of local state.

Well-bracketed control flow (WBCF) expresses that invoked functions must either return to their callers, invoke other functions themselves or diverge, and generally holds in programming languages that do not offer a primitive form of continuations. 
At the assembly level, this property does not hold immediately. 
Invoked functions get direct access to return pointers that they are supposed to jump to a single time at the end of their execution.
There is, however, no guarantee that untrusted assembly code respects this intended usage.
Particularly, a function may invoke return pointers from other stack frames than its own: either frames higher in the call stack or ones that no longer exist as they have already returned. 

Local state encapsulation (LSE) is the guarantee that when a function invokes another function, its local variables (saved on its stack frame) will not have been read or modified when the invoked function returns.
At the assembly level, this property also does not hold immediately.
The calling function's local variables are stored on the stack during the invocation, and functions are not supposed to touch stack frames other than their own.
However, untrusted assembly code is free to ignore this requirement and read or overwrite the local state of other stack frames.
To enforce these properties, target language security primitives are needed that can be used to prevent untrusted code from misbehaving, without imposing too much overhead on well-behaved code.
The virtual-memory based security primitives on commodity processors do not seem sufficiently fine-grained to efficiently support this.
More suitable security primitives are offered by a type of CPUs known as capability machines \citep{levy_capability-based_1984,watson_cheri:_2015}.
These processors use tagged memory to enforce a strict separation between integers and {\itshape capabilities}: pointers that carry authority.
Capabilities come in different flavours.
Memory capabilities allow reading from and writing to a block of memory.
Additionally, capability machines offer some form of {\itshape object capabilities} that represent low-level encapsulated closures, i.e. a piece of code coupled with private state that it gains access to upon invocation.
The concrete mechanics of object capabilities varies between different capability machines.
% KJAA: This 'sealed' and 'common seal' business is unclear to me.
On a recent capability machine called CHERI, for example, they take the form of pairs of capabilities that represent the code and data parts of the closure.
Each of the two capabilities are sealed with a common seal which make them opaque.
The hardware transparently unseals the pair upon invocation~\citep{watson_capability_2015}.

To enforce WBCF and LSE on a capability machine, there are essentially two approaches.
A first approach uses separate stacks for distrusting components, and a central, trusted stack manager component that mediates cross-component invocations.
This idea has been applied in CheriBSD (an operating system built on CHERI)~\citep{watson_capability_2015}, but it is not without downsides.
First, it scales poorly to large amounts of distrusting components, because of the need to reserve separate stack space for all components.
Also, in the presence of higher-order values (e.g. function pointers, objects etc.), the stack manager needs to be able to decide which component a higher-order value belongs to in order to provide it the right stack pointer upon invocation.
It is not clear how this can be done efficiently in the presence of large amounts of components.
Finally, this approach does not allow passing stack references between components.

A more scalable approach retains a single stack that is shared between components.
Enforcing WBCF and LSE in this approach requires a way to temporarily provide stack and return capabilities to an untrusted component, and to revoke them after it returns.
While capability revocation is expensive in general, some capability machines offer restricted forms of revocation that can be implemented efficiently.
For example, CHERI offers a form of {\itshape local} capabilities that, briefly, can only be stored in registers or on the stack, but not in other parts of memory.
\citet{skorstengaard_reasoning_2017} has demonstrated that by making the stack and return pointer local, and by introducing a number of security checks and measures, the two properties can be guaranteed.
% KJAA: 'Boundary crossing' is new here.
However, a problem with this approach is that revoking the local stack and return capabilities on every security boundary crossing requires clearing the entire unused part of the stack, an operation that may be prohibitively expensive.

In this work, we propose and study \stktokens{}: an alternative calling convention that enforces WBCF and LSE with a single shared stack.
Instead of CHERI's local capabilities, it builds on {\itshape linear} capabilities; a new form of capabilities that has not been previously described in the published literature.\footnote{Although they have been mentioned in some technical documents.}
% KJAA: Perhaps make it clear by who and when/where?
These capabilities are non-duplicable, enforced by the hardware.
We propose to make stack and return pointers linear and require components to hand them out in cross-component invocations and to return them in returns.
The non-duplicability of linear capabilities together with some security checks allow us to guarantee WBCF and LSE without large overhead on boundary crossings, particularly without the need for clearing large blocks of memory.

A second contribution of this work is the way in which we formulate these two properties, using a technique we call {\itshape fully abstract overlay semantics}.
Formulations in previous work are either partial and not suitable for reasoning~\cite{abadi_control-flow_2005} or lacked evidence of generality~\cite{skorstengaard_reasoning_2017}.
Our new formulation starts from the premise that security results for a calling convention should be reusable as part of a larger proof of a secure compiler.
To accomodate this, we define a second operational semantics for our target language, with a native well-bracketed stack and primitive ways to do calls and returns.
This well-behaved semantics guarantees WBCF and LSE natively for components using our calling convention.
As such, these components can be sure that they will only ever interact with other well-behaved components that respect our desired properties.
To express security of our calling convention, we then show that considering the same components in the original semantics does not give adversaries additional ways to interact with them. 
More formally, we show that mapping a component in the well-behaved semantics to the same component in the original semantics is fully abstract~\cite{abadi_protection_1999}, i.e. that components are indistinguishable to arbitrary adversaries in the well-behaved language iff they are indistinguishable to arbitrary adversaries in the original language.

This approach expresses what it means to enforce our desirable properties in a general way, and makes it clear that we can support a very general class of programs.
Additionally, formulating security of a calling convention in this way makes it potentially reusable in a larger security proof of a full compiler.
The idea is that security of such a compiler could be verified by proving fully abstract compilation with respect to the well-behaved semantics of the target language, so that the proof can rely on native well-bracketedness and local stack frame encapsulation.
This independent result could then be composed with our result to obtain security of the compiler targeting the real target language, by transitivity of full abstraction.

\todo[inline]{Add itemized contributions}

\paragraph{Outline} Blabla

% \begin{acks}                            %% acks environment is optional
%                                         %% contents suppressed with 'anonymous'
%   %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%   %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%   %% acknowledge financial support and will be used by metadata
%   %% extraction tools.
%   This material is based upon work supported by the
%   \grantsponsor{GS100000001}{National Science
%     Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%   No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%   No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%   conclusions or recommendations expressed in this material are those
%   of the author and do not necessarily reflect the views of the
%   National Science Foundation.
% \end{acks}

\section{A Capability Machine with Sealing and Linear Capabilities}
\label{sec:cap-mach-w-seal-and-lin}
\begin{figure}[tb]
  \centering
  \[
  \arraycolsep=1.4pt
  \begin{array}{rrcl l rrcl}
   \addrbnf,\basebnf \in & \Addr & \defeq & \nats & \phantom{mak} & \sealbasebnf, \sigma \in & \Seal & \defeq & \nats\\
    \aendbnf \in & \Addr \cup \{\infty \} & & & & \sealendbnf \in & \Seal \cup \{\infty \}& &\\
    \permbnf \in& \Perm & \defbnf & \rwx \mid \rx \mid \rw \mid \ro \mid \noperm & & &\linbnf & \defbnf & \linear \mid \normal\\
    \vsc \in &\SealableCaps&\defbnf & \multicolumn{6}{l}{((\permbnf,\linbnf),\basebnf,\aendbnf,\addrbnf) \mid \seal{\sealbasebnf,\sealendbnf,\sigma}}\\
    c \in&\Caps& \defbnf &  \SealableCaps \mid \sealed{\sigma,\scbnf} & & w \in &\Word & \defeq & \ints \uplus \Caps\\ 
    r \in& \RegName & \defbnf & \multicolumn{6}{l}{\pcreg \mid \rretd \mid \rretc \mid \rstk \mid \rdata \mid \rtmp{1} \mid \rtmp{2} \mid \dots} \\
    \reg \in &\Reg & \defeq & \RegName \fun \Word & & \mem \in&\Mem & \defeq & \Addr \fun \Word\\
    &\MemSeg & \defeq & \Addr \parfun \Word & & \Phi \in & \ExecConf & \defeq & \Mem \times \Reg\\
    &\Conf & \defeq & \multicolumn{6}{l}{\ExecConf \cup \{\failed\} \cup \{\halted\} }
  \end{array}
\]
\[
  \arraycolsep=1.4pt
\begin{array}{rcl}
\multicolumn{3}{l}{    \arraycolsep=0pt
      \com{r} \in  \tRegName \hspace{2.5cm}   \com{\rn} \defbnf \com{r} \mid \nats
}\\
  \Instr &\defbnf & \tjmp{\com{r}} \mid \tjnz{\com{r}}{\com{\rn}} \mid \tmove{\com{r}}{\com{\rn}} \mid \tload{\com{r}}{\com{r}} \mid \tstore{\com{r}}{\com{r}} \mid \tplus{\com{r}}{\com{\rn}}{\com{\rn}} \mid \tminus{\com{r}}{\com{\rn}}{\com{\rn}} \mid\\
         & & \tlt{\com{r}}{\com{\rn}}{\com{\rn}} \mid \tisptr{\com{r}}{\com{r}} \mid\tgetp{\com{r}}{\com{r}} \mid \tgetlin{\com{r}}{\com{r}} \mid \tgetb{\com{r}}{\com{r}} \mid \tgete{\com{r}}{\com{r}} \mid \tgeta{\com{r}}{\com{r}}  \mid \\
  & & \tcca{\com{r}}{\com{n\rn}} \mid \tsetatob{\com{r}} \mid \trestrict{\com{r}}{\com{\rn}} \mid \tcseal{\com{r}}{\com{r}} \mid \txjmp{\com{r}}{\com{r}} \mid  \tsplit{\com{r}}{\com{r}}{\com{r}}{\com{\rn}} \mid\\ 
      & & \tsplice{\com{r}}{\com{r}}{\com{r}} \mid \tfail \mid \thalt 
\end{array}
\]
  \caption{The syntax of our capbility machine with seals and linera capbilities.}
  \label{fig:target-syntax}
\end{figure}
% Brief intro to section and this cap machine:
% Cap machine inspired by CHERI, but with linear capabilities
In this section, we introduce a simple but representative capability machine with linear capabilities.
We will later introduce a capability machine similar to the one in this section, so to easily distinguish the two, we will call this one \trgcm{} (Linear Capability Machine).
\trgcm{} is mainly inspired by CHERI~\citep{watson_cheri:_2015} with linear capabilities as the main exception.
In order to avoid details uninteresting to the focus of this work, \trgcm{} assumes an infinite address space and unbounded integers.
\lau{Do we have a good reason to assume an infinite address space for this work?
  We do not model malloc, so we do not need to worry about what happens when malloc runs out of memory.}

%%% Capabilities
The concept of a capability is the cornerstone of any capability machine.
In its simplest form, a capability is a permission and a range of authority.
The permission dictates the operations the capability can be used for, and the range of authority specifies the range of memory it can act upon.
% Permissions and Range of authority
The capabilities of \trgcm{} are of the form $((\var{perm},\var{lin}),\var{base},\var{end},\var{addr})$ (as defined in Figure~\ref{fig:target-syntax} along with the rest of the syntax of \trgcm{}) where $\var{perm}$ is the permission and $[\var{base},\var{end}]$ is the range of authority.
\trgcm{} only has memory capabilities, and we limit them to a number of sensible permissions making the available permissions: read-write-execute ($\rwx$), read-write ($\rw$), read-execute ($\rx$), read-only ($\ro$), and null-permission ($\noperm$).
We define the preorder $\le$ on permissions as illustrated in Figure~\ref{fig:perm-hier}.
% Pointer and linearity
In addition to the two basic things, the capabilities also have a current address $\addr$ and a linearity $\lin$. The linearity of a capability can either be $\linear$ or $\normal$ where $\normal$ corresponds to a traditional capability.
% What is linear capabilities, split/splice
A linear capability is a capability with no alias that cannot be duplicated.
This is enforced dynamically on the capability machine, so when a linear capability is moved between registers or stored to memory, the source register is cleared, and when a linear capability is read from memory, the source address is cleared. We will see this later in this section when we get to the operational semantics.

\begin{wrapfigure}{r}{0.33\linewidth}
  \centering
  \begin{tikzpicture}[main node/.style={}]
    \node[main node] (rwx) {$\rwx$};
    \node[main node] (rx) [below right of=rwx] {$\rx$};

    \node[main node] (rw) [below left of=rwx,] {$\rw$};
    \node[main node] (r) [below right of=rw] {$\readonly$};
    \node[main node] (0) [below of=r] {$\noperm$};

    \path[every node/.style={font=\sffamily\small}]

    (rw) edge (r)
    (r) edge (0)

    (rwx) edge (rx)

    (rw) edge (rwx)
    (r) edge (rx);
  \end{tikzpicture}

  \caption{Permission hierarchy}
  \label{fig:perm-hier}
\end{wrapfigure}

%%% Seals
Any reasonable capability machine needs a way to setup boundaries between security domains as well as a way to cross the boundaries in a way where each domain retains their authority.
%The M-Machine~\citep{Dally1997Memo59} inspired capability machine in \citet{skorstengaard_reasoning_2017} uses enter-capabilities to achieve this.
On \trgcm{} we have sealed capabilities to achieve this.
Syntactically, sealed capabilities add two things to the capability machine: Sets of seals $\seal{\sigma_\var{base},\sigma_\var{end},\sigma}$ and sealed capabilities $\sealed{\sigma,\vsc}$.
% seals
A set of seals consists of a range of available seals $[\sigma_\var{base},\sigma_\var{end}]$ and the current seal $\sigma$ that is represented by a natural number.
% sealed caps
A sealed capability consists of a sealable $\vsc$ and the seal $\sigma$ it has been sealed with.
The sealables are sets of seals and capabilities, and we refer to the set of them as $\SealableCaps$.
The system native tokens on \trgcm{} are the sealables and the sealed capabilities and we refer to this set as $\Cap$.

%%% Domains
The words on \trgcm{} are the system native tokens in $\Cap$ and data which is represented by $\ints$.
We assume a finite set $\RegName$ of register names that at least contains registers $\pcreg$, $\rretd$, $\rretc$, $\rstk$, $\rdata$, $\rtmp{1}$, and $\rtmp{2}$, and we define register files as a function from register names to words.
A memory is a full memory and a memory segment is part of a memory.
Both are defined as functions from addresses, defined as the natural numbers, to words, but the memory segment functions only need to be partial.
$\trgcm{}$ has two terminated configurations $\halted$ and $\failed$ that respectively signify a successful execution and an execution with an attempt to break the capability machine guarantees.
An executable configuration is a register file and memory pair. 

\begin{figure}[p]
  \centering
  \[
    \begin{array}{l}
    \Phi \step
  \begin{cases}
    \sem{\decInstr{\Phi.\mem(\aaddr)}}(\Phi) &
    \arraycolsep=0pt
      \begin{array}[t]{l}
        \text{if }\Phi(\pcreg) = ((\perm,\_),\baddr,\eaddr,\aaddr) \wedge
        \baddr \le \aaddr \le \eaddr \wedge \perm \in \{\rwx,\rx\}
      \end{array} \\
      \failed & \totherwise
  \end{cases}\\
  \updPcAddr{\Phi} =
  \begin{cases}
    \Phi\updReg{\pcreg}{w} & \Phi(\pcreg) = ((\perm,\lin),\baddr,\eaddr,\aaddr) \wedge w = ((\perm,\lin),\baddr,\eaddr,\aaddr+1)\\
    \Phi  & \totherwise
  \end{cases}\\
  \linCons{w} =
  \begin{cases}
    0 & \isLinear{w} \\
    w & \totherwise
  \end{cases}\\
  \xjmpres{c_1,c_2,\Phi} =
  \begin{cases}
    \Phi\updReg{\pcreg}{c_1}\updReg{\rdata}{c_2} & \nonExec{c_2} \\
    \failed & \totherwise
  \end{cases}
  \end{array}
\]
  \begin{tabular}{|>{$}c<{$}|>{$}p{3.4cm}<{$}|>{\raggedright\arraybackslash}p{7cm}|}
    \hline
    i \in \Instr                                 & \sem{i}(\Phi) & Conditions\\
    \hline
    \halt                                        & \halted & \\
    \hline
    \fail                                        & \failed & \\
    % \hline
    % \move{r}{\rn}                                & \updPcAddr{\Phi\updReg{r}{\rn}} & $\rn \in \ints$\\
    \hline
    \move{r}{\rn}                                & \updPcAddr{\Phi\updReg{\rn,r}{w_1,w_2}} & $\rn \in \RegName$ and $w_1 = \Phi(\rn)$ and $w_2 = \linCons{\rn}$ \\
    \hline
    \load{r_1}{r_2}                              & \updPcAddr{\Phi\updReg{r_1}{w_1}\update{\mem.\aaddr}{w_\aaddr}} & $\Phi(r_2) = ((\perm,\_),\baddr,\eaddr,\aaddr)$ and $\baddr \le \aaddr \le \eaddr$ and $\perm \in \{\rwx,\rw,\rx,\ro\}$ and $w_1 = \Phi.\mem(\aaddr)$ and $w_a = \linCons{w_1}$ and $\isLinear{w_1} \Rightarrow \perm \in \{\rwx,\rw\}$\\
    \hline
    \store{r_1}{r_2}                             & \updPcAddr{\Phi\updReg{r_2}{w_2}\update{\mem.\aaddr}{\Phi(r_2)}} & $\Phi(r_1) = ((\perm,\_),\baddr,\eaddr,\aaddr)$ and $\perm \in \{\rwx,\rw\}$ and $\baddr \le \aaddr \le \eaddr$ and $w_2 = \linCons{\Phi(r_2)}$\\
    \hline
    \geta{r_1}{r_2}                              & \updPcAddr{\Phi\updReg{r_1}{w}} & If $\Phi(r_2) = ((\_,\_),\_,\_,\aaddr)$ or $\Phi(r_2) = \seal{\_,\_,\aaddr}$, then $w = \aaddr$ and otherwise $w = -1$\\
    \hline
    \cca{r}{\rn}                                 &\updPcAddr{\Phi\updReg{r}{w}} & $\Phi(\rn) = n \in \ints$ and either $\Phi(r) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ or $\Phi(r) = (\sigma_\baddr,\sigma_\eaddr,\sigma)$ and $w = ((\perm,\lin),\baddr,\eaddr,\aaddr + n)$ or $w = (\sigma_\baddr,\sigma_\eaddr,\sigma+n)$, respectively \\
    \hline
    \jmp{r}    &\Phi\updReg{r,\pcreg}{w,\Phi(r)} & $w = \linCons{\Phi(r)}$\\
    \hline
    \xjmp{r_1}{r_2}                              & \Phi' & $\Phi(r_1) = \sealed{\sigma,c_1}$ and $\Phi(r_2) = \sealed{\sigma,c_2}$ and $w_1 = \linCons{c_1}$ and $w_2 = \linCons{c_2}$ and $\Phi' = \xjmpres{c_1,c_2,\Phi\updReg{r_1,r_2}{w_1,w_2}}$  \\
    \hline
    \tsplit{r_1}{r_2}{r_3}{\rn}                  & \updPcAddr{\Phi\updReg{r_3,r_1,r_2}{w,c_1,c_2}} & $\Phi(r_3) = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $\Phi(\rn) = n \in \nats$ and $\baddr \le n < \eaddr$ and $c_1 = ((\perm,\lin),\baddr,n,\aaddr)$ and $c_2 = ((\perm,\lin),n+1,\eaddr,\aaddr)$ and $w = \linCons{\Phi(r_1)}$\\
    \hline
    \splice{r_1}{r_2}{r_3}                       & \updPcAddr{\Phi\updReg{r_2,r_3,r_1}{w_2,w_3,c}}& $\Phi(r_2) = ((\perm,\lin),\baddr,n,\_)$ and $\Phi(r_3) = ((\perm,\lin),n+1,\eaddr,\aaddr)$ and $\baddr \le n < \eaddr$ and $c = ((\perm,\lin),\baddr,\eaddr,\aaddr)$ and $w_2,w_3 = \linCons{\Phi(r_2),\Phi(r_3)}$\\
    \hline
    \cseal{r_1}{r_2}                             & \updPcAddr{\Phi\updReg{r_1}{\vsc}} & $\Phi(r_1) \in \SealableCaps$ and $\Phi(r_2) = \seal{\sigma_\baddr,\sigma_\eaddr,\sigma}$ and $\sigma_\baddr \le \sigma \le \sigma_\eaddr$ and $\vsc = \sealed{\sigma,\Phi(r_1)}$ \\
    \hline
    \multicolumn{3}{|c|}{\dots} \\
    \hline
    \_                                           & \failed & \totherwise \\
    \hline
  \end{tabular}
\caption{An excerpt of the operational semantics of our capability machine with sealing and linear capabilities.}
  \label{fig:target-op-sem}
\end{figure}
% syntax (instructions)
\trgcm{}'s instruction set is somewhat basic with the instructions one expects on most low-level machine as well as capability machine specific instructions.
The instructions that can be considered standard are: unconditional and a conditional jump (\texttt{jmp} and \texttt{jnz}), copy between registers (\texttt{move}), instructions that load from memory and store to memory (\texttt{load} and \texttt{store}), and arithmetic operations (\texttt{plus}, \texttt{minus}, and \texttt{lt}).
The simplest of the capability machine specific instructions simply inspect system native tokens or project one of their fields.
These are \texttt{gettype} (for getting the type of a system token) and \texttt{getp}, \texttt{getl}, \texttt{getb}, \texttt{gete}, and \texttt{geta} (for projecting permission, linearity, base, end, and current address(/seal), respectively).
There are two instructions for manipulating the current address(/seal) of a capability(/set of seals): \texttt{cca} changes the current address(/seal) of a capability(/set of seals) by some offset, and \texttt{seta2b} set the current address(/seal) of a capability(/set of seals) to the base address(/seal).
The \texttt{restrict} instruction reduces the permission of a capability according to the permission order $\le$.
Generally speaking, a capability machine needs an instruction for reducing the range of authority of an capability.
Because \trgcm{} has linear capabilities the instruction for this splits the capability in two rather than reducing the range of authority (instruction \texttt{split}).
\trgcm{} also has an instruction that does the inverse of this, so a linear capability, or any capability for that matter, that has been split can be restored (\texttt{splice}).
\trgcm{} has instructions for sealing sealables (\texttt{cseal}) and unsealing pairs of sealed capabilities (\texttt{xjmp}).
Finally, \trgcm{} has instructions to signal whether an execution was successful or not (\texttt{halt} and \texttt{fail}).

% opsem
The operational semantics of \trgcm{} is displayed in Figure~\ref{fig:target-op-sem}.
The operational semantics is defined in terms of a step relation that executes the next instruction in an executable configuration $\Phi$ which results in a new executable configuration or one of the two terminated configurations.
The executed instruction is determined by the capability in $\pcreg$ register, i.e.\ $\Phi(\pcreg)$ (we write $\Phi(r)$ to mean $\Phi.\reg(r)$).
In order for the machine to take a step, the capability in the $\pcreg$ must have a permission that allows execution, and the current address of the capability must be within the range of addresses where the capability can operate.
If both things are satisfied, then the word pointed to by the capability is decoded to an instruction which is interpreted relatively to $\Phi$.
The interpretation of some of the instructions are also displayed in Figure~\ref{fig:target-op-sem}.
In order to step through a program in memory, most of the interpretations use the function $\updPcAddr{}$ which simply updates the capability in the $\pcreg$ to point to the next memory address.
The instructions that stop execution or change the flow of execution do not use $\updPcAddr{}$.
For instance, the \texttt{halt} and \texttt{fail} instructions are simply interpreted as the $\halted$ and $\failed$ configurations, respectively, and they do not use $\updPcAddr{}$.

% move w/ lin
The \texttt{move} instruction simply moves a word from one register to another.
It is, however, complicated slightly by the presence of the non-duplicable linear capabilities.
This means that when a linear capability is moved, the source register should be cleared.
To take care of this and prevent duplicating the operational semantics, we use the function $\linCons{}$ that returns $0$ for linear capabilities and is the identity for all other words.
When the \texttt{move} instruction is performed, the source register $r_2$ is overwritten with $\linCons{\Phi(r_2)}$ which clears the register if the contents was linear and leaves it unchanged otherwise.

% load w/ lin (and store)
The \texttt{store} and \texttt{load} instructions are fairly standard: They require a capability with permission to either write or read depending on the operation, they check that the capability points within the range of authority, and they clear the source of a linear capability transfer.
Linear capabilities introduce one complication for \texttt{load} as it needs to clear the loaded memory address when it contains a linear capability in order to not duplicate the capability.
Clearing a memory address corresponds to writing $0$ to the memory, but in order to write to memory we need to provide a capability with write-permission.
This means that to load a linear capability from memory, we have to use a capability with read and write permission.

% geta, cca
The instructions \texttt{geta} and \texttt{cca} are fairly simple: \texttt{geta} projects the current address or current seal from a capability or a set of seals, respectively, and it returns the error value $-1$ for data and sealed capabilities.
The \texttt{cca} instruction changes the current address or seal of a capability or set of seals, respectively, by a given offset.
By making an in-place update, the instruction does not need to take special care in order to maintain linearity.
The \texttt{jmp} instruction is a fairly simple jump that just sets the $\pcreg$-register.

%% Sealing
The operational side of the sealing in \trgcm{} consists of two instructions: \texttt{cseal} for sealing a capability and \texttt{xjmp} for unsealing a pair of capabilities.
% cseal
Given a sealable $\vsc$ and a set of seals where the current seal $\sigma$ is within the range of available seals, the \texttt{cseal} instruction seals $\vsc$ with $\sigma$.
% xjmp
Apart from dealing with linearity, \texttt{xjmp} takes a pair of sealed capabilities unseals them and put one in the $\pcreg$ register and the other in the $\rdata$ register, but only if they are sealed with the same seal and the data capability (the capability placed in $\rdata$) is non-executable.
A pair of sealed capabilities can be seen as a closure where the code capability (the capability placed in $\pcreg$) is the program and the data capability is the local environment of the closure.
Because of the opacity of sealed capability, the creator of the closure can be sure that execution will start where the code capability points and only in an environment with the related data, i.e.\ sealed with the same seal.
Some care should be taken when sealing as reuse of the same seal for multiple closures would make it possible to jump to the code of one capability with the environment of another.
% xjmp to unseal
\trgcm{} does not have an instruction for unsealing single sealed capabilities directly (using the seal that was used to do the sealing), but it can be (partially) simulated using \texttt{xjmp}.

% split/splice
Instructions for reducing the authority of capabilities are commonplace on capability machines as they allow us to limit what a capability can do before it is passed away.
For normal capabilities, reduction of authority can be done without actually giving up any authority if the capability is duplicated first.
With linear capabilities authority cannot be preserved in this fashion as they are non-duplicable.
In order to make a lossless reduction of the range of authority, \trgcm{} provides special hardware support in the form of \texttt{split} and \texttt{splice}.
The \texttt{split} instruction takes a capability with range of authority $[\var{base},\var{end}]$ and an address $n$ and creates two new capabilities one with $[\var{base},n]$ as its range of authority and the other with $[n+1,\var{end}]$ as it range of authority.
Everything else, i.e.\ permission, linearity and current address, is copied without change to the new capabilities.
With \texttt{split} we can reduce the range of authority of a linear capability without losing any authority as we retain it in the other capability.
However, if we only have \texttt{split}, then in some sense splitting a capability is not completely lossless as we may have authority over the same range of addresses, but we have that authority in two capabilities rather than just one.
In order to make up for this, we have a \texttt{splice} instruction that essentially does the inverse of \texttt{split}.
Namely given two capabilities with adjacent ranges of authority and the same permissions and linearity, it splices them together into one capability.
The two instructions work in the same way for seal sets.
We do not provide special support for lossless reduction of capability permissions, but this could probably be achieved with more fine-grained permissions.
This would also allow linear capabilities to have aliases, but only by linear capabilities with disjointed permissions.


At this time, the executable configuration is our only way to specify the state of the capability machine.
We would, however, much prefer a notion of a program that only describe the essential parts of an entity on the machine and only later instrument the program with whatever necessary to make it into an executable configuration.
In later sections, we describe different entities on the capability machine that interact with each other.
In order for them to interact, we need to be able to link them together and to this end, we introduce a notion of a component.
A component is basically a program with open ends in the form of imports.
A component also have exports allowing other programs to link with them.
We define the notion of a component in Figure~\ref{fig:target-component-and-linking}.
% Structure
A base component $\comp_0$ consists of the following: a code memory segment, a data memory segment, a list of imported symbols, a list of exported symbols, two lists specifying the available seals seals\footnote{We will return to the seals in later sections.}, and a set of all the linear addresses.
The import list specifies where in memory imports should be placed, and imports are matched to exports via their symbols.
The exports are words associated with a symbol.
%base = library
A base component can be seen as library implementations because it does not specify a main entry point of execution.
Components are either a library component or a base component with a main in the form of a pair of sealed capabilities which can be seen as a program that still needs to be linked with libraries.
% Linking .
Components are combined into new components by linking them together.
Libraries can be linked together and incomplete programs can be linked with libraries, but two incomplete programs cannot be linked with each other.
Two components can be linked when their memories, seals, and linear addresses disjointed.
They are combined by taking the union of each of their constituents.
For every import that is satisfied by an export of the other component, in the sense that they have the same symbol, the data memory is updated to have the exported word on the imported address.
The satisfied imports are removed from the import list in the resulting linked component and the exports are updated to be the exports of the two components.
In Figure~\ref{fig:target-component-and-linking}, $\bowtie$ defines linking.
\todo[inline]{Add better separation between component and linking in figure.}

% Programs
We can now define the notion of a program as well as a context.
\begin{definition}[Programs and Contexts]
  \label{def:program-and-context}
  We define a \emph{program} to be a component $(\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})$ with an empty import list.

  A \emph{context} for a component $\var{comp}$ is another component $\var{comp}'$ such that $\var{comp} \bowtie \var{comp}'$ is a program.
\end{definition}
% Getting an executable from a component - postpone this to later, but mention:
% write xor exec
In Section~\ref{sec:form-secur-with}, we will get back to what a program is instrumented with in order to create an executable configuration. \todo[inline]{Make sure we got back to this!}
We will, however, at this point mention that all programs will be instrumented with the Write-XOR-Execute,\todo[inline]{Do we have a reference for this?} i.e.\ there will only be read-execute capabilities for the code and read-write capabilities for the data.
%Further, we will only consider a specific class of well-formed components, but we will get back to this.

Some simplifications has been made in this presentation of \trgcm{} in this section. We refer to the accompanying technical report\citep{technical_report} for all details.
\begin{figure}[htb]
  \centering
  \[
    \begin{array}{rl c rl c rl}
    s &\in \Symbol & \phantom{make} &
    \mathrm{import} &\mathrel{::=} a \mapsfrom s & \phantom{make} &
    \mathrm{export} &\mathrel{::=} s \mapsto w\\
    \var{comp}_0 & \multicolumn{7}{l}{\mathrel{::=} (\mscode,\msdata,\overline{\mathrm{import}},\overline{\mathrm{export}},\sigrets,\sigcloss,A_\linear)}\\
    \var{comp} & \multicolumn{7}{l}{\mathrel{::=} \var{comp}_0 \mid  (\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d})}
  \end{array}
\]
\begin{mathpar}
  \inference{
    \var{comp}_1 = (\mscode[1], \msdata[1], \overline{\var{import}_1}, \overline{\var{export}_1}, \sigrets[1], \sigcloss[1],A_{\linear,1})\\
    \var{comp}_2 = (\mscode[2], \msdata[2], \overline{\var{import}_2}, \overline{\var{export}_2}, \sigrets[2], \sigcloss[2],A_{\linear,2})\\
    \var{comp}_3 = (\mscode[3], \msdata[3], \overline{\var{import}_3}, \overline{\var{export}_3}, \sigrets[3], \sigcloss[3],A_{\linear,3})\\
    \mscode[3] = \mscode[1] \uplus \mscode[2] \\
    \msdata[3] = (\msdata[1] \uplus \msdata[2])[a \mapsto w \mid (a \mapsfrom s) \in (\overline{\var{import}_1} \cup \overline{\var{import}_2}), (s \mapsto w) \in \overline{\var{export}}_3] \\
    \overline{\var{export}_3} = \overline{\var{export}_1} \cup \overline{\var{export}_2}&
    \overline{\var{import}_3} = \{ a \mapsfrom s \in (\overline{\var{import}_1} \cup \overline{\var{import}_2}) \mid s \mapsto \_ \not\in \overline{\var{export}_3} \}\\
    \sigrets[3] = \sigrets[1] \uplus \sigrets[2] &
    \sigcloss[3] = \sigcloss[1] \uplus \sigcloss[2] &
    A_{\linear,3} = A_{\linear,1} \uplus A_{\linear,2}\\
    \dom(\mscode[3]) \mathrel{\#} \dom(\msdata[3]) & \sigrets[3] \mathrel{\#} \sigcloss[3]
  } {
    \var{comp}_3 = \var{comp}_1 \bowtie \var{comp}_2
  }
  \and
  \inference{
    \var{comp}_0'' = \var{comp}_0 \bowtie \var{comp}_0'
  }{
    (\var{comp}_0'',c_{\mathrm{main},c}, c_{\mathrm{main},d}) = \var{comp}_0 \bowtie (\var{comp}_0',c_{\mathrm{main},c}, c_{\mathrm{main},d}) = (\var{comp}_0,c_{\mathrm{main},c}, c_{\mathrm{main},d}) \bowtie \var{comp}_0'
  }
\end{mathpar}
% \begin{definition}[Initial execution configuration]
%   \begin{mathpar}
%     \inference{
%       c_{\mathrm{main},c} = \sealed{\sigma_1, c_{\mathrm{main},c}'} &
%       c_{\mathrm{main},d} = \sealed{\sigma_2, c_{\mathrm{main},d}'} &
%       \sigma_1 = \sigma_2\\
%       \nonExec{c_{\mathrm{main},d}'}&
%       \reg(\pcreg) = c_{\mathrm{main},c}' & 
%       \reg(\rdata) = c_{\mathrm{main},d}' \\
%       \src{\reg(\rstk) = \stkptr{\rw,\baddr_\stk,\eaddr_\stk,\eaddr_\stk}} & 
%       \trg{\reg(\rstk) = ((\rw,\linear),\baddr_\stk,\eaddr_\stk,\eaddr_\stk)} \\
%       \reg(\RegName \setminus \{\pcreg,\rdata,\rstk\}) = 0\\
%       \range{\ms_\stk} = \{0\}&
%       \mem = \mscode \uplus \msdata \trg{\;\uplus\; \ms_\stk} \\
%       [\baddr_\stk,\eaddr_\stk] = \dom(\ms_\stk ) \mathrel{\#} (\dom(\mscode) \cup \dom(\msdata)) &
%       \overline{\var{import}} = \emptyset
%     }{
%       ((\mscode, \msdata, \overline{\var{import}}, \overline{\var{export}}, \sigrets, \sigcloss,A_\linear),  c_{\mathrm{main},c}, c_{\mathrm{main},d}) \rightsquigarrow (\mem, \reg\src{, \emptyset, \ms_\stk})
%     }
%   \end{mathpar}
% \end{definition}
% \begin{definition}[Plugging a program into a context]
%   When $\var{comp'}$ is a context for component $\var{comp}$ and $\var{comp}' \bowtie \var{comp} \rightsquigarrow \Phi$, 
%   then we write $\plug{\var{comp'}}{\var{comp}}$ for the execution configuration $\Phi$.
% \end{definition}
  \caption{Components and linking of components}
  \label{fig:target-component-and-linking}
\end{figure}

%\FloatBarrier
% \begin{itemize}
% \item present our \emph{target language} and its operational semantics (excerpts)
% \item mention roughly what components look like
% \end{itemize}
\section{Linear Stack and Return Capabilities}
\todo[inline]{Make sealed capabilities more clear in figures.}
In this section, we introduce our calling convention \stktokens{} that insures LSE and WBCF.
We will gradually explain each of the security measures \stktokens{} take and motivate them with the attacks they prevent.

\begin{figure}
  \centering
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      % Stack pointer 1
      \begin{scope}
        \clip (4.6,4) rectangle (9,13);
        \capbracebot{(4.6,4)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 1}
      \end{scope}
      Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \capbrace{(5.2,9)}{(5.2,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

      \draw[red,thick,->] (4.5,10) to[out=0,in=50] node[midway,right] {} (7.5,7.3);
      \draw[red,thick,->] (7,7.3) to[out=115,in=0] node[midway,right] {} (4.5,8);
    \end{tikzpicture}
    \caption{An adversary uses a previous stack frame's stack pointer.}
    \label{fig:stack-ptr-abuse}
  \end{subfigure}
  \begin{subfigure}{0.18\linewidth}
    \phantom{testtestes}
  \end{subfigure}
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}
      \fill[red,draw=red,opacity=.4] (-.1,3.9) rectangle (4.6,9.1);
      \draw[red,thick,->] (4.5,10.5) to[out=0,in=0] node[midway,right,align=center] {return\\ to wrong\\ return ptr} (4.5,3);
    \end{tikzpicture}
    \caption{An adversary jumps to a previous stack frame's stack pointer.}
    \label{fig:ret-ptr-abuse}
  \end{subfigure}
  
  \caption{Possible ways to abuse stack and return capabilities}
  \label{fig:stack-ret-ptr-abuse}
\end{figure}

\stktokens{} is based on a traditional single stack, shared between all components.
As we are on a capability machine, it is natural to add some extra protection to stack and return pointers.
First, we replace stack pointers with stack capabilities.
When a new stack frame is created, the caller provisions it with a stack capability, restricted to the appropriate range, i.e.\ it does not cover the caller's stack frame.
Return pointers, on the other hand, are replaced by a pair of sealed return capabilities.
% KJAA: Again with the sealed pair. Again, this idea is unclear.
They form an opaque closure that the callee can only jump to, and the caller's data becomes available to the caller's return code. 

%informally explain how an adversary may try to abuse stack and return caps
While the above adds extra protection, it is not sufficient to enforce WBCF and LSE.
The caller provides the adversary with a stack capability and a return pair that they are supposed to use for the call, but the adversary can store the provided capabilities on the heap in order to use them later.
Figure~\ref{fig:stack-ret-ptr-abuse} illustrates two examples of this.
In both examples our component and some adversarial component have been taking turns calling each other, so the stack now contains four stack frames alternating between ours and theirs.
The figure on the left (Figure~\ref{fig:stack-ptr-abuse}) illustrates how we try to ensure LSE by restricting the stack capability to the unused part before every call to the adversary.
However, restricting the stack capability does not help when we in the first call give access to the part of the stack where our second stack frame will reside as nothing prevents the adversary from duplicating and storing the stack pointer.
Generally speaking, we have no reason to ever trust a stack capability received from a component we do not trust as that stack capability may have been duplicated and stored for later use.
In the figure on the right (Figure~\ref{fig:ret-ptr-abuse}), we have given the adversary two pairs of sealed return capabilities, one in each of the two calls to the adversarial component.
The adversary may have stored the pair of sealed return capabilities from the first call in order to use it in the second call where they are not allowed to use it.
The figure illustrates how the adversarial code uses the return pair from the first call to return from the second call and thus break WBCF.

\todo[inline]{If target cap. machine is introduced before this section, then revisit/delete this section.}
% Informally explain how we prevent this using linear capabilities
As the examples illustrate, the standard memory and object-like capabilities (sealed capabilities) do not provide sufficient guarantees to enforce LSE and WBCF.
The two properties can, however, be enforced with a calling convention that utilizes the guarantees of linear capabilities.

% Stack capability linear
The linear capabilities are put to use by requiring the stack capability to be linear.
On call, the caller splits the stack capability in two, such that they have a capability for their local stack frame and a capability for the unused part of the stack.
The stack capability for their local stack frame is sealed and used as the data part of the sealed return pair, and the stack capability for the remainder of the stack is given to the callee.
% Prevention of left attack non-aliasing of linear capabilities - token like (ensuring LSE)
Because the stack capability is linear the caller knows that the capability for their local stack frame cannot have an alias.
This means that an adversary will need the stack capability the caller produced in order to access their local data.
While the caller gives the capability to the adversary, it is only after the caller seals it which makes the capability opaque.
This is illustrated in Figure~\ref{fig:stack-ptr-abuse-prev} and prevents the issue illustrated in Figure~\ref{fig:stack-ptr-abuse}.

% Prevention of attack 2
In a traditional calling convention with a single stack, the stack serves as a call stack keeping track of the order calls where made in and thus in which order they should be returned to.
A caller pushes a stack frame to the stack on call and a callee pops a stack frame from the stack upon return.
However without any enforcement, there is nothing to prevent a callee from returning from an arbitrary call on the call stack.
This is exactly what the adversary does in Figure~\ref{fig:ret-ptr-abuse} when they skip two stack frames.
In the presence of adversarial code, we need some enforcement mechanism that allows us to make sure that the order of the call stack is kept.
One way to enforce this would be to hand out a token on call that can only be used when the caller's stack frame is on top of the call stack.
The callee would have to provide this token on return to prove that it is allowed to return to the caller, and on return the token would be taken back by the caller to prevent it from being spent multiple times.
As it turns out, the stack capability for the unused part of the stack can be used as such a token in the following way:
On return the callee has to give back the stack capability they were given on invocation.
When the caller receives a stack capability back on return, they need to check that this token is actually spendable, i.e.\ check whether their stack frame is on top of the call stack.
They do this by attempting to restore the stack capability from before the call by splicing the return token with the stack capability for the local stack frame which at this point has been unsealed again.
If the splice is successful, then the caller knows that the two capabilities are adjacent. On the other hand, if the splice fails, then they are alerted to the fact that their stack frame may not be the topmost.
\stktokens{} uses this approach, and as illustrated in Figure~\ref{fig:ret-ptr-abuse-prev} it prevents the issue in Figure~\ref{fig:ret-ptr-abuse} as the adversary does not return a spendable token when they return.
\begin{figure}
  \centering
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      \lincapbrace{(4.6,2)}{(4.6,4)}{data return\\\footnotesize cap. 1}

      % Stack pointer 1
      \lincapbrace{(4.6,4)}{(4.6,7)}{adv. stack\\\footnotesize cap. 1}
      % return cap
      \lincapbrace{(4.6,7)}{(4.6,9)}{data return\\\footnotesize cap. 2}
     %  Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \lincapbrace{(4.6,9)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

    \end{tikzpicture}
    \caption{The non-duplicable linear stack capability for the trusted code's
      stack frame and the opacity of sealed capabilities ensures LSE.}
    \label{fig:stack-ptr-abuse-prev}
  \end{subfigure}
  \begin{subfigure}{0.18\linewidth}
    \phantom{testtestes}
  \end{subfigure}
  \begin{subfigure}{0.4\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)} {\footnotesize Adv. stack frame 1}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted \\ \footnotesize stack frame 2}
      \actadv{(0,9)}{(4.5,12)} {\footnotesize Adv. stack frame 2}

      \lincapbrace{(4.6,2)}{(4.6,4)}{data return\\\footnotesize cap. 1}

     %  Stack pointer 2
      \begin{scope}
        \clip (4.8,4) rectangle (9,13);
        \lincapbrace{(4.6,9)}{(4.6,13.5)}{adv. stack\\\footnotesize cap. 2}
      \end{scope}

      \redcross{(5,4)}
    \end{tikzpicture}
    \caption{The trusted caller fails to splice the stack capability returned by
    the adversary with the capability for the trusted caller's local stack frame.}
    \label{fig:ret-ptr-abuse-prev}
  \end{subfigure}
  \caption{}
\end{figure}

% Non-empty trusted stack frames.
In order for a call to have a presence on the call stack, its stack frame must be non-empty.
If we could have empty stack frames on the call stack, then it would be impossible to tell whether the topmost non-empty stack frame has an empty stack frame on top of it.
Non-empty stack frames come naturally in traditional C-like calling convention as they keep track of old stack pointers and old program counters on the stack, but in \stktokens{} these things are part of the return pair which means that a caller with no local data may only need an empty stack frame.
This means that a caller using \stktokens{} needs to take care that their stack frame is non-empty in order to reserve their spot in the return order.
There is also a more practical reason for a \stktokens{} caller to make sure their stack frame is non-empty: They need a bit of the stack capability in order to perform the splice that verifies the validity of the return token.

% known stack base
% + more
At this point, the caller checks that the return token is adjacent to the stack capability for the caller's local stack frame and they have the means to do so.
However, this does not make sure that the caller's stack frame is on top of the call stack.
The issue is that stack frames may not be tightly packed leaving space between stack frames in memory.
An adversarial callee may even intentionally leave a bit of space in memory above the caller's stack frame, so that they later can return out of order by returning the bit of the return token for the bit of memory left above the caller's stack frame.
This is illustrated in Figure~\ref{fig:stk-base-abuse}: In Figure~\ref{fig:stack-base-abuse-a}, a trusted caller has called an adversarial callee.
The adversary calls the trusted code back, but first they split the return token in two and store on the heap the part for the memory adjacent to the trusted caller's call frame (Figure~\ref{fig:stack-base-abuse-b}).
The trusted caller calls the adversary back using the precautions we have described so far (Figure~\ref{fig:stack-base-abuse-c}).
At this point (Figure~\ref{fig:stack-base-abuse-b})), the adversary has access to a partial return token adjacent to the trusted caller's first stack frame which allows the adversary to return from this call breaking WBCF.
For the caller to be sure that there are no hidden stack frames above its own, they need to make sure that the return token is exactly the same as the one they passed to the callee.
In \stktokens{}, the caller verifies the validity of the return token by checking whether the base address\footnote{The stack grows downwards in the address space} of a returned token corresponds to the base address of the return token they gave to the callee.
In the scenario we just sketched, the caller would be alerted to the attempt to break WBCF when the base address check of the return token fails in Figure~\ref{fig:stack-base-abuse-d}.

% Where do we get the stack pointer from, how can we know it is linear
% The other attack.
% KJAA: It is unclear to me what 'at this point' refers to.
At this point, the caller is able to verify whether a return token is spendable which allows them to decide whether they have the topmost stack frame on a call stack.
However, in order to have WBCF there should only be one call stack, so the caller should also be able to verify that they have the top stack frame on the call stack used by all well-behaved components.
In case a trusted component did not start the execution on the machine, i.e.\ they were called by another component, then the trusted component has no way to be sure whether the stack capability passed to them corresponds to the one and only call stack.
To illustrate how an adversarial component can break WBCF by using multiple different stack capabilities consider this example: An adversary calls a trusted component with a callback and some linear capability that they claim is the stack capability.
The trusted component executes using the stack capability given to them and at some point they invoke the callback, creating return tokens and so on.
The adversary stores the return pair and return token and calls another trusted component but with a new callback and a new linear capability that they claim is the stack capability.
Again, this trusted component also executes using the stack capability given to them and at some point they too invoke the callback, taking all the precautions we have described so far.
At this point, the adversary has everything they need to return from either of the two callbacks.
Specifically, they could return from the first callback invocation before they have returned from the second, breaking WBCF.
From a high-level perspective, the problem is that both trusted components will be able to verify that they have the top stack frame on the call stack.
They are both correct as the adversarial component has created two call stacks, one for each of the components.
In order to solve this problem, the well-behaved code needs to somehow agree on the call stack.
We do this by statically deciding on a global base address for the stack which is used for the entirety of the execution.
A caller makes sure that they are using the correct stack by checking that the base address of the stack capability they receive corresponds to the global stack base address.
This also means that on every return, the caller will check whether the return token's base address is equal to the global stack address.

Having a globally decided stack address also solves another challenge.
Namely, the stack capability has to be linear in order for a caller to use it as a token, so a caller has to make sure that a capability is in fact linear when it is proposed as the stack capability by an untrusted source.
This is, however, implicitly checked when the caller checks that the stack capability governs the global stack base address.
The reason is that the stack capability needs to start execution as a linear capability which means that the capability that governs the global stack base address to begin with is linear.
Due to the non-duplicability of linear capability and the fact that they cannot become non-linear during execution, the caller knows that if they have a capability that governs the global stack base address, then it must be linear.

% Return pointers/return seals
The return pointer in the StackToken scheme is a pair of sealed capabilities where the code part of the pair is the old program counter, and the data part is the stack capability for the local stack frame of the caller.
Both of the capabilities in the pair are of course sealed with the same seal.
% One seal per return point
All call points need to be associated with a unique seal (a return seal) that is only used to seal the capabilities in the return pair for that particular call point.
The return seal is what associates the stack frame on the call stack with a specific call point in a program, so if we allowed return seals to be reused, it would be possible to return to a different call point than the one that caused the stack frame to be pushed on the call stack which would break WBCF.
For similar reasons, we cannot allow return seals to be used to seal closures.
% Don't be stupid
Return seals should never be leaked to adversarial code as this would allow them to unseal the local stack frame of a caller breaking LSE.
This goes for direct leaks, such as leaving a seal in a register or writing it to adversarial memory, as well as indirect leaks, where a capability for reading a return seal (either directly or indirectly) from memory is leaked.

% Note about them vs us, we do nothing that they couldn't do
In the description of the StackToken calling scheme, it has sometimes been in terms of ``them vs us''.
This may have created the impression of an asymmetric calling convention that places a special status on trusted components allowing them to protect themselves against adversaries.
However, \stktokens{} is a modular calling scheme no restriction is put on adversarial components that we do not expect trusted components to meet.
This means that any component can ensure WBCF and LSE by employing \stktokens{}.
% KJAA: ^-- Assuming that there is a global stack address capability, no? Can I "suddenly" begin to impose \stktokens{}?

% Summary of CC
In the this section, we have described our proposed calling convention, \stktokens{}.
In this paragraph we summarize it:
\begin{description}
\item[Check the base address of the stack capability before and after calls] 
\item[Make sure that local stack frames are non-empty]
\item[Create token and data return capability on call] split the stack capability in two to get a stack capability for you local stack frame and a stack capability for the unused part of the stack. The stack capability for your local stack frame is sealed and used for the data part of the return pair.
\item[Create code return capability on call] Seal the old program pointer.
\item[Reasonable use of seals] return seals are only used to seal old program pointers, all return seals are only used for one call site, and return seals are not leaked.
\end{description}

\begin{figure}
  \centering
  \begin{subfigure}{0.23\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \draw (-0.5,13) node {\footnotesize 0};
      \draw (-0.5,12.5) edge[thin,-latex] (-0.5,11);
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \actadv{(0,4)}{(4.5,7)}{}

      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
      \lincapbracebot{(4.6,4)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-a}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \inactadv{(0,4)}{(4.5,7)}{\footnotesize Kept by adv.}
      \node[opacity=0.5,rotate=-45] at (2.25,10) {\footnotesize Sent to trusted};
      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \lincapbrace{(4.6,4)}{(4.6,7)}{}
      
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
      \lincapbracebot{(4.6,7)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-b}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \inactsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}
      \actadv{(0,4)}{(4.5,7)}{\footnotesize Kept by adv.}
      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted\\ \footnotesize stack frame 2}
      \node[opacity=0.5,rotate=-45] at (2.25,11) {\footnotesize Returned to adv.};
      \lincapbrace{(4.6,2)}{(4.6,4)}{}
      \lincapbrace{(4.6,4)}{(4.6,7)}{}
      \lincapbrace{(4.6,7)}{(4.6,9)}{}
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
        \lincapbracebot{(4.6,9)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-c}
  \end{subfigure}
  \begin{subfigure}{0.24\linewidth}
    \centering
    \begin{tikzpicture}[scale=.5, every node={scale=.5}]
      % recurrent parts
      \stdstackstart[13]
      \actsf{(0,2)}{(4.5,4)} {\footnotesize Trusted\\ \footnotesize stack frame 1}

      \inactsf{(0,7)}{(4.5,9)} {\footnotesize Trusted\\ \footnotesize stack frame 2}
      \begin{scope}
        \clip (-.1,-.1) rectangle (4.6,13.1);
        \draw[fill=gray!50] (0,9) rectangle (4.5,13.5);
      \end{scope}

      \lincapbrace{(4.6,2)}{(4.6,7)}{}
      \lincapbrace{(4.6,7)}{(4.6,9)}{}

      \fill[red,draw=red,opacity=.4] (-.1,6.9) rectangle (4.6,9.1);
      \begin{scope}
        \clip (4.8,1) rectangle (9,13);
        \lincapbracebot{(4.6,9)}{(4.6,13.5)}{}
      \end{scope}

    \end{tikzpicture}
    \caption{}
    \label{fig:stack-base-abuse-d}
  \end{subfigure}
  \caption{}
  \label{fig:stk-base-abuse}
\end{figure}


% \begin{itemize}
% \item informally explain how an adversary may try to abuse stack and return caps
% \item informally explain how we prevent this using linear capabilities
% \item use the tikz pictures from the PriSC presentation to explain all of this
% \end{itemize}

\section{Formulating Security with a Fully Abstract Overlay Semantics}
\label{sec:form-secur-with}
A central contribution of this paper is to prove that \stktokens{} actually guarantees LSE and WBCF.
Our proof uses a novel approach called full abstract overlay semantics.
In this approach, we first define an overlay semantics for \trgcm{} which has LSE and WBCF by construction.
An overlay semantics is basically a different view on an existing semantics.
For instance, it may have new syntactic constructs and have special semantics for these things, but they will correspond to something on the underlying machine.
In the overlay semantics we are about to define for \trgcm{}, there is an explicit stack pointer construct on the machine, but on the underlying semantics the stack pointer corresponds directly to a linear capability for the part of memory the overlay semantics has deemed to be the stack.
When we have defined the overlay semantics, we prove full-abstractness for a compilation from the overlay semantics to the underlying semantics. 
Generally speaking, the compilation from an overlay semantics to an underlying semantics should be straightforward as it is really just a different view on the same thing. 
In this case, the compilation even turns out to be the identity function!
\todo[inline]{Maybe also introduce reasonability here}

\begin{figure}[htb]
  \centering
  \[
    \arraycolsep=1.4pt
    \begin{array}{rcl}
      \src{\SealableCaps} & \defbnf& \SealableCaps \mid \src{\stkptr{\permbnf,\basebnf,\aendbnf,\addrbnf}} \mid \src{\retptrd(\basebnf,\aendbnf)}\\
                          & &  \mid \src{\retptrc(\basebnf,\aendbnf,\addrbnf)}\\
      \multicolumn{3}{c}{
      \begin{array}{lcrclcr}
        \src{\StkFrame} & \defeq & \src{\Addr \times \MemSeg} & \phantom{skipskipsip} & \src{\Stack} & \defeq & \src{ \StkFrame^*}
      \end{array}
                                                                                                                }\\
      \src{\ExecConf} & \defeq & \Mem \times \Reg \; \src{\times \; \Stack \times \MemSeg} \\
    \end{array}
  \] 
\[
  \begin{array}{rcl}
    \offpc,\offsigma & \in & \nats \\
    \src{\Instr} & \defbnf &  \Instr \mid \scall{\offpc,\offsigma}{r}{r}
  \end{array}
\]
  \caption{The syntax of the capability machine with a built-in stack.}
  \label{fig:src-syntax}
\end{figure}

The overlay semantics we define for \trgcm{} (\srccm{}) is defined in Figure~\ref{fig:src-syntax} and \ref{fig:src-op-sem}.
The main things it adds to \trgcm{} is a built-in stack that can be used to store local state as well as a \texttt{call} instruction and a new interpretation of \texttt{xjmp} that corresponds to returning.
% Describe the things added to the syntax
% Built-in stack
% Stack pointer
% Return pointers

\begin{figure}[htb]
  \centering
  \label{fig:src-op-sem}
  \caption{An excerpt of the operational semantics of the capability machine with a built-in stack.}
\end{figure}

% Describe the changes to op sem
% Step relation change, call case and global constants
% Call semantics
% New xjmp semantics (can be defined in terms of a new xjmpresult function!)
% Example of alternative interpretation for the new syntactic constructs

% Well-formed components

% Reasonability 

% Full abstraction thm






% \begin{itemize}
% \item present our source language, its operational semantics (excerpts)
% \item tell more about components, specifically well-formed according to judgement
% \item mention our assumption of reasonability
% \item present the full abstraction theorem.
% \end{itemize}

\section{Proving full abstraction}
\label{sec:fa-proof}

\begin{itemize}
\item Logical relation
\item FTLR
\item Sketch high-level structure of the proof
\end{itemize}

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=.9}]
    % \draw[help lines,yellow] (0,0) grid (10,7);
    \node at (5,4.7) { ${\src{C_1}\mathrel{\sconeq} \src{C_2}}$ };

    \node at (3.4,4) { ${\plug{\trg{\context}}{\src{C_1}} \sterm[]{\gc}{}}$ };
    \node at (5,4) { $\mathrel{\Rightarrow}$ };
    \node at (6.6,4) { ${\plug{\trg{\context}}{\src{C_2}} \sterm[]{\gc}{}}$ };

    \node at (4.35,2.8) { (1) };
    \node at (5,3.6) { (2) };
    \node at (5.65,2.8) { (3) };

    \draw[out=100,in=260,double,-implies,double equal sign distance] (4,2.6) to (4,3.4);

    \draw[out=280,in=80,double,-implies,double equal sign distance] (6,3.4) to (6,2.6);

    \node[align=left] at (8.2,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{C_2}} \cong \comp{{\src{C_2}}}$};
    \node[align=left] at (1.8,3) { $ {\trg{\context}} \cong \trg{\context}$ \\
      $ {\src{C_1}} \cong \comp{{\src{C_1}}}$};
    % \node at (9,2.7) { $e  {\src{C_1}} \cong \comp{{\src{C_1}}} : tau$ };
    % \node at (8.7,3.3) { $ {\comp{\trg{\context}}} \cong \trg{\context} :{\emptyset},tau \ra e,{\cdots}$ };
    % \node at (.8,3) { $e  {\src{C_1}} \cong \comp{{\src{C_1}}} : tau$ };

    \node at (3.4,2) { ${\plug{\trg{\context}}{\src{C_1}} \term[]{}}$ };
    \node at (5,2.1) { $\overset{?}{\Rightarrow}$ };
    \node at (6.6,2) { ${\plug{\trg{\context}}{\src{C_2}} \term[]{}}$ };

    \node at (5,1.3) { ${\src{C_1}}\mathrel{\overset{?}{\tconeq}}{\src{C_2}}$ };

    \draw[out=-90,in=90,double,-implies,double equal sign distance] (0,5) to node[sloped, yshift =.7em]{\small Contextual equivalence preservation} (0,1);
  \end{tikzpicture}
  \caption{Proving one direction of fully abstract compilation (contextual equivalence preservation).}
\end{figure}

\section{Discussion}
\label{sec:discussion}
\begin{itemize}
\item mention that tail calls are supported through xjmp
\item explain how fully abstract overlay semantics could form one pass of a verified secure compiler.
\item Performance?  Implementability of linear caps?
\item Sharing stack references accross component boundaries is supported
\item Other notions of well-bracketedness (specifically one would be to allow different stacks)
\end{itemize}

\section{Related Work}

In this section, we discuss related work on securely enforcing control flow correctness and/or local state encapsulation.
We do not repeat the work we discussed in Section~\ref{sec:introduction}.

Capability machines originate with \citet{dennis_programming_1966} and we refer to \citet{levy_capability-based_1984} and \citet{watson_cheri:_2015} for an overview of previous work.
The capability machine formalized in Section~\ref{sec:cap-mach-w-seal-and-lin} is modeled after CHERI~\citep{watson_cheri:_2015,woodruff_cheri_2014}.
This is a recent and relatively mature capability machine, which combines capabilities with a virtual memory approach, in the interest of backwards compatibility and gradual adoption.
For simplicity, we have omitted features of CHERI that were not needed for modelling \stktokens{} (e.g.\ local capabilities, virtual memory).

Plenty of other papers enforce well-bracketed control flow at a low level, but most are restricted to preventing particular types of attacks and enforce only partial correctness of control flow.
This includes particularly the line of work on \emph{control-flow integrity}~\citep{abadi_control-flow_2005}.
This technique prevents certain classes of attacks by sanitizing addresses before direct and indirect jumps based on static information about a program's control graph and a shadow stack.
Contrary to \stktokens{}, CFI can be implemented on commodity hardware rather than capability machines.
However, its attacker model is different and its security goals are weaker.
They assume an attacker that is not able to execute code, but can overwrite arbitrary data at any time during execution (to model buffer overflows).
In terms of security goals, the technique does not enforce local stack encapsulation.
Also, it only enforces a weak form of control flow correctness, saying that jumps stay within the static control flow graph of a program~\cite{Abadi2005Theory}.
Such a property ignores temporal properties and seems hard to use for reasoning.
There is also more and more evidence that these partial security properties are not enough to prevent realistic attacks in practice~\citep{Evans:2015:CJW:2810103.2813646,Carlini2015ControlFlowBending}.

More closely related to our work are papers that use separate per-component stacks, a trusted stack manager and some form of memory isolation to enforce control-flow correctness as part of a secure compilation result~\citep{patrignani_modular_2016,juglaret_beyond_2016}.
Our work differs from theirs in that we use a different low-level security primitive (a capability machine with local capabilities rather than a machine with a primitive notion of compartments) and we do not use per-component stacks or a trusted stack manager, but a single shared stack and a decentralized calling convention based on linear capabilities.
Both prove a secure compilation result from a high-level language, which clearly implies a general form of control-flow correctness, but that result is not separated from the results about other aspects of their compiler.

CheriBSD applies a similar approach with separate per-component stacks and a trusted stack manager on a capability machine~\cite{watson_cheri:_2015}.
The authors use local capabilities to prevent components from accidentally leaking their stack pointer to other components, but there is no actual capability revocation at play.
They do not provide many details on this mechanism and it is, for example, not clear if and how they intend to deal with higher-order interfaces (C function pointers) or stack references shared accross component boundaries. 

The fact that our full abstraction result only applies to reasonable components (see Section~\ref{sec:form-secur-with}) makes it related to full abstraction results for unsafe languages.
In their study of compartmentalization primitives, \Citet{juglaret_beyond_2016} discuss the property of Secure Compartmentalizing Compilation (SCC): a variant of full abstraction that applies to unsafe source languages.
Essentially, they modify standard full abstraction so that preservation and reflection of contextual equivalence are only guaranteed for components that are {\itshape fully defined}, which means essentially that they do not exhibit undefined behavior in any fully defined context.
In follow-up work, \citet{DBLP:journals/corr/abs-1802-00588} extend this approach to scenarios where components only start to exhibit undefined behavior after a number of well-defined steps.
If we see reasonable behavior as defined behavior, then our full abstraction result can be seen as an application of this same idea.
Our results do not apply to dynamic compromise scenarios because they are intended to be used in the verification of a secure compiler, where these scenarios are not relevant.

\bibliography{references}


%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
 